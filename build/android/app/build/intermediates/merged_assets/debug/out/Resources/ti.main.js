'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* eslint-disable quote-props */
/* globals OS_ANDROID, OS_IOS */

// Add global constants.
Object.defineProperties(commonjsGlobal, {
  'OS_ANDROID': {
    value: true,
    writable: false
  },
  'OS_IOS': {
    value: false,
    writable: false
  },
  OS_VERSION_MAJOR: {
    value: Ti.Platform.versionMajor,
    writable: false
  },
  OS_VERSION_MINOR: {
    value: Ti.Platform.versionMinor,
    writable: false
  },
  OS_VERSION_PATCH: {
    value: Ti.Platform.versionPatch,
    writable: false
  }
});

// Copyright Node.js contributors. All rights reserved.
const kNodeModulesRE = /^(.*)[\\/]node_modules[\\/]/;
const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
const isBuffer = Symbol.for('titanium.buffer.isBuffer');
const colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

function removeColors(str) {
  return str.replace(colorRegExp, '');
}
function isError(e) {
  // An error could be an instance of Error while not being a native error
  // or could be from a different realm and not be instance of Error but still
  // be a native error.
  return isNativeError(e) || e instanceof Error;
}
let getStructuredStack;
class StackTraceError extends Error {}
StackTraceError.prepareStackTrace = (err, trace) => trace;
StackTraceError.stackTraceLimit = Infinity;
function isInsideNodeModules() {
  if (getStructuredStack === undefined) {
    getStructuredStack = () => new StackTraceError().stack;
  }
  let stack = getStructuredStack();

  // stack is only an array on v8, try to convert manually if string
  if (typeof stack === 'string') {
    const stackFrames = [];
    const lines = stack.split(/\n/);
    for (const line of lines) {
      const lineInfo = line.match(/(.*)@(.*):(\d+):(\d+)/);
      if (lineInfo) {
        const filename = lineInfo[2].replace('file://', '');
        stackFrames.push({
          getFileName: () => filename
        });
      }
    }
    stack = stackFrames;
  }

  // Iterate over all stack frames and look for the first one not coming
  // from inside Node.js itself:
  if (Array.isArray(stack)) {
    for (const frame of stack) {
      const filename = frame.getFileName();
      // If a filename does not start with / or contain \,
      // it's likely from Node.js core.
      if (!/^\/|\\/.test(filename)) {
        continue;
      }
      return kNodeModulesRE.test(filename);
    }
  }
  return false;
}
function join$1(output, separator) {
  let str = '';
  if (output.length !== 0) {
    const lastIndex = output.length - 1;
    for (let i = 0; i < lastIndex; i++) {
      // It is faster not to use a template string here
      str += output[i];
      str += separator;
    }
    str += output[lastIndex];
  }
  return str;
}
function uncurryThis(f) {
  return function () {
    return f.call.apply(f, arguments);
  };
}
const ALL_PROPERTIES$2 = 0;
const ONLY_ENUMERABLE$2 = 2;
const propertyFilter = {
  ALL_PROPERTIES: ALL_PROPERTIES$2,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$2
};
function getOwnNonIndexProperties(obj, filter) {
  const props = [];
  const keys = filter === ONLY_ENUMERABLE$2 ? Object.keys(obj) : Object.getOwnPropertyNames(obj);
  for (var i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!isAllDigits(key)) {
      props.push(key);
    }
  }
  return props;
}
function isAllDigits(s) {
  if (s.length === 0) {
    return false;
  }
  for (var i = 0; i < s.length; ++i) {
    const code = s.charCodeAt(i);
    if (code < 48 || code > 57) {
      return false;
    }
  }
  return true;
}

// Copyright Node.js contributors. All rights reserved.
const TypedArrayPrototype$1 = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_toStringTag = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype$1, Symbol.toStringTag).get);
function isObject(value) {
  return typeof value === 'object';
}
function isFunction(value) {
  return typeof value === 'function';
}
function checkPrototype(value, name) {
  return Object.prototype.toString.call(value) === `[object ${name}]`;
}
function isAnyArrayBuffer(value) {
  if (isArrayBuffer(value)) {
    return true;
  }
  return isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
  return isObject(value) && checkPrototype(value, 'Arguments');
}
function isArrayBuffer(value) {
  return isObject(value) && checkPrototype(value, 'ArrayBuffer');
}

// Cached to make sure no userland code can tamper with it.
const isArrayBufferView = ArrayBuffer.isView;
function isAsyncFunction(value) {
  return isFunction(value) && checkPrototype(value, 'AsyncFunction');
}
function isBigInt64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';
}
function isBigUint64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';
}
function isBooleanObject(value) {
  return isObject(value) && checkPrototype(value, 'Boolean');
}
function isBoxedPrimitive(value) {
  if (!isObject(value)) {
    return false;
  }
  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value)
  // || isBigIntObject(value)
  || isSymbolObject(value);
}
function isDataView(value) {
  return isObject(value) && checkPrototype(value, 'DataView');
}
function isDate(value) {
  return isObject(value) && checkPrototype(value, 'Date');
}

// @todo isExternal

function isFloat32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float32Array';
}
function isFloat64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float64Array';
}
function isGeneratorFunction(value) {
  return isFunction(value) && checkPrototype(value, 'GeneratorFunction');
}
function isGeneratorObject(value) {
  return isObject(value) && checkPrototype(value, 'Generator');
}
function isInt8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int8Array';
}
function isInt16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int16Array';
}
function isInt32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int32Array';
}
function isMap(value) {
  return isObject(value) && checkPrototype(value, 'Map');
}
function isMapIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Map Iterator';
}

// @todo isModuleNamespaceObject

function isNativeError(value) {
  // if not an instance of an Error, definitely not a native error
  if (!(value instanceof Error)) {
    return false;
  }
  if (!value || !value.constructor) {
    return false;
  }
  return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);
}
function isNumberObject(value) {
  return isObject(value) && checkPrototype(value, 'Number');
}
function isPromise(value) {
  return isObject(value) && checkPrototype(value, 'Promise');
}

// @todo isProxy

function isRegExp(value) {
  return isObject(value) && checkPrototype(value, 'RegExp');
}
function isSet(value) {
  return isObject(value) && checkPrototype(value, 'Set');
}
function isSetIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Set Iterator';
}
function isSharedArrayBuffer(value) {
  if (!global.SharedArrayBuffer) {
    return false;
  }
  return isObject(value) && checkPrototype(value, 'SharedArrayBuffer');
}
function isStringObject(value) {
  return isObject(value) && checkPrototype(value, 'String');
}
function isSymbolObject(value) {
  return isObject(value) && checkPrototype(value, 'Symbol');
}
function isTypedArray(value) {
  const isBuiltInTypedArray = TypedArrayProto_toStringTag(value) !== undefined;
  if (isBuiltInTypedArray) {
    return true;
  }
  return value[isBuffer] === true;
}
function isUint8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8Array';
}
function isUint8ClampedArray(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';
}
function isUint16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint16Array';
}
function isUint32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint32Array';
}
function isWeakMap(value) {
  return isObject(value) && checkPrototype(value, 'WeakMap');
}
function isWeakSet(value) {
  return isObject(value) && checkPrototype(value, 'WeakSet');
}

// @todo isWebAssemblyCompiledModule

var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isAnyArrayBuffer: isAnyArrayBuffer,
  isArgumentsObject: isArgumentsObject,
  isArrayBuffer: isArrayBuffer,
  isArrayBufferView: isArrayBufferView,
  isAsyncFunction: isAsyncFunction,
  isBigInt64Array: isBigInt64Array,
  isBigUint64Array: isBigUint64Array,
  isBooleanObject: isBooleanObject,
  isBoxedPrimitive: isBoxedPrimitive,
  isDataView: isDataView,
  isDate: isDate,
  isFloat32Array: isFloat32Array,
  isFloat64Array: isFloat64Array,
  isGeneratorFunction: isGeneratorFunction,
  isGeneratorObject: isGeneratorObject,
  isInt8Array: isInt8Array,
  isInt16Array: isInt16Array,
  isInt32Array: isInt32Array,
  isMap: isMap,
  isMapIterator: isMapIterator,
  isNativeError: isNativeError,
  isNumberObject: isNumberObject,
  isPromise: isPromise,
  isRegExp: isRegExp,
  isSet: isSet,
  isSetIterator: isSetIterator,
  isSharedArrayBuffer: isSharedArrayBuffer,
  isStringObject: isStringObject,
  isSymbolObject: isSymbolObject,
  isTypedArray: isTypedArray,
  isUint8Array: isUint8Array,
  isUint8ClampedArray: isUint8ClampedArray,
  isUint16Array: isUint16Array,
  isUint32Array: isUint32Array,
  isWeakMap: isWeakMap,
  isWeakSet: isWeakSet
});

// Copyright Node.js contributors. All rights reserved.
let error;
function lazyError() {
  if (!error) {
    // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
    // error = require('./errors').codes.ERR_INTERNAL_ASSERTION;
    error = codes.ERR_INTERNAL_ASSERTION;
  }
  return error;
}
function assert$1(value, message) {
  if (!value) {
    const ERR_INTERNAL_ASSERTION = lazyError();
    throw new ERR_INTERNAL_ASSERTION(message);
  }
}
function fail(message) {
  const ERR_INTERNAL_ASSERTION = lazyError();
  throw new ERR_INTERNAL_ASSERTION(message);
}
assert$1.fail = fail;

// Copyright Node.js contributors. All rights reserved.
const messages = new Map();
const codes = {};

// @todo implement this once needed
class SystemError extends Error {}

// Utility function for registering the error codes.
function E(sym, val, def, ...otherClasses) {
  // Special case for SystemError that formats the error message differently
  // The SystemErrors only have SystemError as their base classes.
  messages.set(sym, val);
  if (def === SystemError) {
    throw new Error('Node compatible SystemError not yet implemented.');
  } else {
    def = makeNodeErrorWithCode(def, sym);
  }
  if (otherClasses.length !== 0) {
    otherClasses.forEach((clazz) => {
      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);
    });
  }
  codes[sym] = def;
}
function makeNodeErrorWithCode(Base, key) {
  return class NodeError extends Base {
    constructor(...args) {
      super();
      const message = getMessage(key, args, this);
      Object.defineProperty(this, 'message', {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      });
      addCodeToName(this, super.name, key);
    }
    get code() {
      return key;
    }
    set code(value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      });
    }
    toString() {
      return `${this.name} [${key}]: ${this.message}`;
    }
  };
}
function getMessage(key, args, self) {
  const msg = messages.get(key);

  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (assert === undefined) {
  	assert = require('./internal/assert');
  }
  */

  if (typeof msg === 'function') {
    assert$1(msg.length <= args.length,
    // Default options do not count.
    `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${msg.length}).`);
    return msg.apply(self, args);
  }
  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
  assert$1(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);
  if (args.length === 0) {
    return msg;
  }
  args.unshift(msg);
  return format$1.apply(null, args);
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  // return lazyInternalUtilInspect().format.apply(null, args);
}

function addCodeToName(err, name, code) {
  // Add the error code to the name to include it in the stack trace.
  err.name = `${name} [${code}]`;
  // Access the stack to generate the error message including the error code
  // from the name.
  // @fixme: This only works on V8/Android, iOS/JSC has a different Error structure.
  // should we try to make errors behave the same across platforms?
  // eslint-disable-next-line no-unused-expressions
  err.stack;
  // Reset the name to the actual name.
  if (name === 'SystemError') {
    Object.defineProperty(err, 'name', {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true
    });
  } else {
    delete err.name;
  }
}
E('ERR_BUFFER_OUT_OF_BOUNDS',
// Using a default argument here is important so the argument is not counted
// towards `Function#length`.
(name = undefined) => {
  if (name) {
    return `"${name}" is outside of buffer bounds`;
  }
  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INTERNAL_ASSERTION', (message) => {
  const suffix = 'This is caused by either a bug in Titanium ' + 'or incorrect usage of Titanium internals.\n' + 'Please open an issue with this stack trace at ' + 'https://github.com/tidev/titanium-sdk/issues\n';
  return message === undefined ? suffix : `${message}\n${suffix}`;
}, Error);
E('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {
  assert$1(typeof name === 'string', '\'name\' must be a string');

  // determiner: 'must be' or 'must not be'
  let determiner;
  if (typeof expected === 'string' && expected.startsWith('not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  let msg;
  if (name.endsWith(' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = name.includes('.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  }

  // TODO(BridgeAR): Improve the output by showing `null` and similar.
  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
let maxStack_ErrorName;
let maxStack_ErrorMessage;
/**
 * Returns true if `err.name` and `err.message` are equal to engine-specific
 * values indicating max call stack size has been exceeded.
 * "Maximum call stack size exceeded" in V8.
 *
 * @param {Error} err The error to check
 * @returns {boolean}
 */
function isStackOverflowError(err) {
  if (maxStack_ErrorMessage === undefined) {
    try {
      function overflowStack() {
        overflowStack();
      }
      overflowStack();
    } catch (e) {
      maxStack_ErrorMessage = e.message;
      maxStack_ErrorName = e.name;
    }
  }
  return err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;
}
function oneOf(expected, thing) {
  assert$1(typeof thing === 'string', '`thing` has to be of type string');
  if (Array.isArray(expected)) {
    const len = expected.length;
    assert$1(len > 0, 'At least one expected value needs to be specified');
    expected = expected.map((i) => String(i));
    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

class FastBuffer extends Uint8Array {}

/**
 * loop over input, every 2 characters, parse as an int
 * basically each two characters are a "byte" or an 8-bit uint
 * we append them all together to form a single buffer holding all the values
 * @param {string} value string we're encoding in hex
 * @returns {integer[]} array of encoded bytes
 */
function stringToHexBytes(value) {
  const length = value.length / 2;
  const byteArray = [];
  for (let i = 0; i < length; i++) {
    const numericValue = parseInt(value.substr(i * 2, 2), 16);
    if (!Number.isNaN(numericValue)) {
      // drop bad hex characters
      byteArray.push(numericValue);
    }
  }
  return byteArray;
}

// Use a Proxy to hack array style index accessors
const arrayIndexHandler = {
  get(target, propKey, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);
      if (Number.isSafeInteger(num)) {
        return getAdjustedIndex(target, num);
      }
    } else if (propKey === isBuffer) {
      return true;
    }
    return Reflect.get(target, propKey, receiver);
  },
  set(target, propKey, value, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);
      if (Number.isSafeInteger(num)) {
        setAdjustedIndex(target, num, value);
        return true;
      }
    }
    return Reflect.set(target, propKey, value, receiver);
  },
  has(target, key) {
    if (typeof key === 'string') {
      const num = Number(key);
      if (Number.isSafeInteger(num)) {
        // ensure it's a positive "safe" integer within the range of the buffer
        return num >= 0 && num < target._tiBuffer.length;
      }
    }
    return key in target;
  }
};

// This is a special Buffer that wraps Ti.Buffer
// as a result it is *much* slower to read/write values
// because we need to go across the JS/Native boundary per-byte!
// We also need to use a Proxy to handle intercepting set/get of indices to redirect to the underlying Ti.Buffer
class SlowBuffer {
  /**
   * Constructs a new buffer.
   *
   * Primarily used internally in this module together with `newBuffer` to
   * create a new Buffer instance wrapping a Ti.Buffer.
   *
   * Also supports the deprecated Buffer() constructors which are safe
   * to use outside of this module.
   *
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   */
  constructor(tiBuffer, start = 0, length = tiBuffer.length - start) {
    Object.defineProperties(this, {
      byteOffset: {
        value: start
      },
      length: {
        value: length
      },
      _tiBuffer: {
        value: tiBuffer
      }
    });
  }

  /**
   * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access
   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
   * @param {integer} [start=0] start offset of array/buffer
   * @param {integer} [length] length of the underlying array/buffer to wrap
   * @returns {Buffer} wrapped inside a Proxy
   */
  static fromTiBuffer(tiBuffer, start, length) {
    return new Proxy(new SlowBuffer(tiBuffer, start, length), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer
  }

  static fromString(value, encoding) {
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }
    encoding = encoding.toLowerCase();
    if (encoding === 'base64') {
      const blob = Ti.Utils.base64decode(value);
      const blobStream = Ti.Stream.createStream({
        source: blob,
        mode: Ti.Stream.MODE_READ
      });
      const buffer = Ti.Stream.readAll(blobStream);
      blobStream.close();
      return SlowBuffer.fromTiBuffer(buffer);
    }
    if (encoding === 'hex') {
      const bytes = stringToHexBytes(value);
      const length = bytes.length;
      const tiBuffer = Ti.createBuffer({
        length
      });
      for (let i = 0; i < length; i++) {
        tiBuffer[i] = bytes[i] & 0xFF; // mask to one byte
      }

      return SlowBuffer.fromTiBuffer(tiBuffer);
    }
    const tiBuffer = Ti.createBuffer({
      value: value,
      type: getTiCodecCharset(encoding)
    });
    return SlowBuffer.fromTiBuffer(tiBuffer);
  }

  // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer
  get buffer() {
    // Get the slice of the array from byteOffset to length
    return Uint8Array.from(this).buffer;
  }
  _slice(offset, length) {
    return SlowBuffer.fromTiBuffer(this._tiBuffer, offset, length);
  }
  _fill(value, offset, end, encoding) {
    const valueType = typeof value;
    if (valueType === 'string') {
      const bufToFillWith = SlowBuffer.fromString(value, encoding);
      const fillBufLength = bufToFillWith.length;
      if (fillBufLength === 0) {
        throw new Error('no valid fill data');
      }
      // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);
      if (fillBufLength === 1) {
        this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);
        return this;
      }

      // multiple byte fill!
      const length = end - offset;
      for (let i = 0; i < length; i++) {
        // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
        const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
        this._tiBuffer[i + offset] = fillChar;
      }
      return this;
    }

    // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();
    this._tiBuffer.fill(value, offset, end);
  }
  getAdjustedIndex(index) {
    return getAdjustedIndex(this, index);
  }
  setAdjustedIndex(index, value) {
    return setAdjustedIndex(this, index, value);
  }

  // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer
  set(src, offset = 0) {
    const numBytes = src.length;
    // check src.length + offset doesn't go beyond our length!
    // FIXME: Re-enable
    // checkOffset(this, offset, numBytes);
    // copy src values into this buffer starting at offset
    for (let i = 0; i < numBytes; i++) {
      setAdjustedIndex(this, i + offset, src[i]);
    }
  }

  /**
   * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
   * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
   */
  toTiBuffer() {
    if (this.length === this._tiBuffer.length && this.byteOffset === 0) {
      return this._tiBuffer;
    }
    return this._tiBuffer.clone(this.byteOffset, this.length);
  }
}
function getAdjustedIndex(buf, index) {
  if (index < 0) {
    return undefined;
  }
  // Wrapping Ti.Buffer?
  if (buf._tiBuffer) {
    if (index >= buf._tiBuffer.length) {
      return undefined;
    }
    return buf._tiBuffer[index + buf.byteOffset];
  }
  // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?
  return buf[index];
}
function setAdjustedIndex(buf, index, value) {
  if (index < 0) {
    return;
  }
  // Wrapping Ti.Buffer?
  if (buf._tiBuffer) {
    if (index < buf._tiBuffer.length) {
      buf._tiBuffer[index + buf.byteOffset] = value;
    }
    return;
  }
  // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?
  buf[index] = value;
}

// https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings
const TI_CODEC_MAP = new Map();
TI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII);
/**
 * @param {string} encoding desired encoding name
 * @returns {integer} Ti.Codec constant that maps to the encoding
 */
function getTiCodecCharset(encoding) {
  return TI_CODEC_MAP.get(encoding);
}

/**
 * This implementation of Buffer uses a Ti.Buffer internally to back it.
 * This is likley an order of magnitude slower than using a variant that extends Uint8Array!
 * I think if we're not already wrapping a Ti.Buffer, it may be better to have two implementations
 * and, like browserify, just extend Uint8Array for any Buffers we need to read/write a lot
 * and then add a simple conversion method to turn it into a Ti.Buffer when needed.
 *
 * The Ti.Buffer impl has to go through the binding layer for reading/writing every byte.
 * If we anticipate the Buffer staying on the JS side, I'm willing to bet that the Uint8Array
 * the JS engine provides would be *way* faster.
 *
 * Also note that both Ti.Buffer and Node's Buffer were created before the JS engines had typed arrays
 * (and Uint8Array in particular) as a means of encapsulating a byte array. We should consider accepting
 * a Uint8Array in any of our APIs that take a Ti.Buffer and eventually deprecating/removing Ti.Buffer.
 */
const {
  ALL_PROPERTIES: ALL_PROPERTIES$1,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$1
} = propertyFilter;
const VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le'];

// Used to cheat for read/writes of doubles
const doubleArray = new Float64Array(1);
const uint8DoubleArray = new Uint8Array(doubleArray.buffer);

// Used to cheat to read/write floats
const floatArray = new Float32Array(1);
const uint8FloatArray = new Uint8Array(floatArray.buffer);

// Node.js does some very weird stuff here
FastBuffer.prototype.constructor = Buffer$1; // new FastBuffer() calls Buffer function?
Buffer$1.prototype = FastBuffer.prototype; // Then it hijacks Buffer's prototype to point at FastBuffer's?!
// Does this effectively mean Buffer extends Uint8Array, because FastBuffer did? This fails for me
// How the hell can we make it happy? We really want to extend Uint8Array if we can
// addBufferPrototypeMethods(Buffer.prototype); // Here's where it hangs some of the methods

Buffer$1.poolSize = 8192;

/**
 * Constructs a new buffer.
 *
 * Primarily used internally in this module together with `newBuffer` to
 * create a new Buffer instance wrapping a Ti.Buffer.
 *
 * Also supports the deprecated Buffer() constructors which are safe
 * to use outside of this module.
 *
 * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg the underlying data/bytes
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */
function Buffer$1(arg, encodingOrOffset, length) {
  if (arg === undefined) {
    return;
  }
  if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {
    showFlaggedDeprecation();
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(`The "string" argument must be of type "string". Received type ${typeof arg}`);
      }
      return Buffer$1.alloc(arg);
    }
    return Buffer$1.from(arg, encodingOrOffset, length);
  }

  // The slow case - we're wrapping a Ti.Buffer
  return SlowBuffer.fromTiBuffer(arg, encodingOrOffset, length);
}

/**
 * @param {integer[]|Buffer|string} value value we're wrapping
 * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
 * @param {integer} length length of the underlying array/buffer to wrap
 * @returns {Buffer}
 */
Buffer$1.from = function (value, encodingOrOffset, length) {
  const valueType = typeof value;
  if (valueType === 'string') {
    return fromString(value, encodingOrOffset);
  } else if (valueType === 'object') {
    if (isAnyArrayBuffer(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (Array.isArray(value) || value instanceof Uint8Array) {
      return fromArray(value);
    }
    if (Buffer$1.isBuffer(value)) {
      return fromBuffer(value);
    }
    // We want to limit the use of SlowBuffers to only when we're wrapping a Ti.Buffer, hopefully!
    if (value.apiName && value.apiName === 'Ti.Buffer') {
      return SlowBuffer.fromTiBuffer(value);
    }
  }
  throw new TypeError('The \'value\' argument must be one of type: \'string\', \'Array\', \'Buffer\', \'Ti.Buffer\'');
};

/**
 * @param {ArrayBuffer} obj ArrayBuffer to wrap
 * @param {number} [byteOffset=0] byte offste to begin
 * @param {number} [length] length to wrap
 * @returns {Buffer}
 */
function fromArrayBuffer(obj, byteOffset, length) {
  // Convert byteOffset to integer
  if (byteOffset === undefined) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }
  const maxLength = obj.byteLength - byteOffset;
  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('offset');
  }
  if (length === undefined) {
    length = maxLength;
  } else {
    // Convert length to non-negative integer.
    length = +length;
    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('length');
      }
    } else {
      length = 0;
    }
  }
  return new FastBuffer(obj, byteOffset, length);
}

/**
 * @param {string} value value to wrap
 * @param {string} [encoding='utf8'] character encoding
 * @returns {Buffer}
 */
function fromString(value, encoding = 'utf8') {
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError(`Unknown encoding: ${encoding}`);
  }
  encoding = encoding.toLowerCase();
  if (encoding === 'base64') {
    const blob = Ti.Utils.base64decode(value);
    return new FastBuffer(blob.toArrayBuffer());
  }
  if (encoding === 'hex') {
    return fromArray(stringToHexBytes(value));
  }
  // Convert the SlowBuffer to a fast buffer by just copying bytes recursively here
  return fromBuffer(SlowBuffer.fromString(value, encoding));
}

/**
 * @param {integer[]|Uint8Array|array} value values to wrap
 * @returns {Buffer}
 */
function fromArray(value) {
  const length = value.length;
  if (length === 0) {
    return new FastBuffer();
  }
  return new FastBuffer(value);
}

/**
 * Ideally this should only be used when we're copying a SlowBuffer into a new FastBuffer
 * @param {Buffer} value buffer to copy
 * @returns {Buffer}
 */
function fromBuffer(value) {
  const length = value.length;
  if (length === 0) {
    return new FastBuffer();
  }
  const buffer = Buffer$1.allocUnsafe(length);
  value.copy(buffer, 0, 0, length);
  return buffer;
}
Object.setPrototypeOf(Buffer$1, Uint8Array); // What is this doing?! Making Buffer.prototype point at Uint8Array now

/**
 * 0 is returned if target is the same as buf
 * 1 is returned if target should come before buf when sorted.
 * -1 is returned if target should come after buf when sorted.
 * @param {Buffer} target Buffer to compare against
 * @param {integer} [targetStart=0] index to start in target
 * @param {integer} [targetEnd=target.length] index to end in target
 * @param {integer} [sourceStart=0] index to start in this Buffer
 * @param {integer} [sourceEnd=this.length] index to end in this Buffer
 * @returns {integer}
 */
Buffer$1.prototype.compare = function (target, targetStart, targetEnd, sourceStart, sourceEnd) {
  if (!Buffer$1.isBuffer(target)) {
    throw new TypeError(`The "target" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  }
  if (targetStart === undefined) {
    targetStart = 0;
  }
  if (sourceStart === undefined) {
    sourceStart = 0;
  }
  if (targetEnd === undefined) {
    targetEnd = target.length;
  }
  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  }

  // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength
  if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {
    throw new RangeError('Index out of range'); // FIXME: set "code" to ERR_INDEX_OUT_OF_RANGE
  }

  // Use slices to make the loop easier
  const source = this.slice(sourceStart, sourceEnd);
  const sourceLength = source.length;
  const dest = target.slice(targetStart, targetEnd);
  const destLength = dest.length;
  const length = Math.min(sourceLength, destLength);
  for (let i = 0; i < length; i++) {
    const targetValue = dest.getAdjustedIndex(i);
    const sourceValue = source.getAdjustedIndex(i);
    if (targetValue !== sourceValue) {
      // No match! Return 1 or -1 based on what is greater!
      if (sourceValue < targetValue) {
        return -1;
      }
      return 1;
    }
  }

  // sort based on length!
  if (sourceLength < destLength) {
    return -1;
  }
  if (sourceLength > destLength) {
    return 1;
  }
  return 0;
};

/**
 * Copies from this to target
 * @param {Buffer} target destination we're copying into
 * @param {integer} [targetStart=0] start index to copy into in destination Buffer
 * @param {integer} [sourceStart=0] start index to copy from within `this`
 * @param {integer} [sourceEnd=this.length] end index to copy from within `this`
 * @returns {integer} number of bytes copied
 */
Buffer$1.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {
  if (targetStart === undefined) {
    targetStart = 0;
  }
  if (sourceStart === undefined) {
    sourceStart = 0;
  }
  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  }
  if (sourceStart === sourceEnd) {
    return 0;
  }
  if (target.length === 0 || this.length === 0) {
    return 0;
  }
  // TODO: check for out of bounds?
  let length = sourceEnd - sourceStart;
  // Cap length to remaining bytes in target!
  const remaining = target.length - targetStart;
  if (length > remaining) {
    sourceEnd = sourceStart + remaining;
    length = remaining;
  }
  // Determine actual number of bytes we'll copy, constrain by source buffer length as well as target (above)
  let numBytes = length;
  const sourceLen = this.length - sourceStart;
  if (numBytes > sourceLen) {
    numBytes = sourceLen;
  }

  // TODO: handle overlap when target === this!
  // TODO: Do we need to take target byteOffset into account here?
  let source = this;
  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(this.buffer, this.byteOffset + sourceStart, numBytes);
  }
  target.set(source, targetStart);
  return numBytes;
};

/**
 * Creates and returns an iterator of [index, byte] pairs from the contents of buf.
 * @returns {Iterator}
 */
// TODO: Is this only necessary for SlowBuffer?
Buffer$1.prototype.entries = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const entryIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: [nextIndex, buffer.getAdjustedIndex(nextIndex)],
          done: false
        };
        nextIndex++;
        return result;
      }
      return {
        value: undefined,
        done: true
      };
    },
    [Symbol.iterator]: function () {
      return this;
    }
  };
  return entryIterator;
};
Buffer$1.prototype.equals = function (otherBuffer) {
  if (!Buffer$1.isBuffer(otherBuffer)) {
    throw new TypeError('argument must be a Buffer');
  }
  if (otherBuffer === this) {
    return true;
  }
  return this.compare(otherBuffer) === 0;
};

/**
 * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`
 * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default
 * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.
 * @returns {this}
 */
Buffer$1.prototype.fill = function (value, offset, end, encoding) {
  const offsetType = typeof offset;
  if (offsetType === 'undefined') {
    // value supplied
    offset = 0;
    end = this.length;
    encoding = 'utf8';
  } else if (offsetType === 'string') {
    // value, encoding supplied
    encoding = offset;
    offset = 0;
    end = this.length;
  } else if (typeof end === 'string') {
    // value, offset, encoding supplied
    encoding = end;
    end = this.length;
  }
  this._fill(value, offset, end, encoding);
  return this;
};
const TypedArrayPrototype = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_byteLength = Object.getOwnPropertyDescriptor(TypedArrayPrototype, 'byteLength').get;
const TypedArrayFill = TypedArrayPrototype.fill;
Buffer$1.prototype._fill = function (value, offset, end, encoding) {
  if (typeof value === 'number') {
    // OOB check
    const byteLen = TypedArrayProto_byteLength.call(this);
    const fillLength = end - offset;
    if (offset > end || fillLength + offset > byteLen) {
      throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    TypedArrayFill.call(this, value, offset, end);
  } else {
    const bufToFillWith = SlowBuffer.fromString(value, encoding);
    const fillBufLength = bufToFillWith.length;
    if (fillBufLength === 0) {
      throw new Error('no valid fill data');
    }
    if (fillBufLength === 1) {
      TypedArrayFill.call(this, bufToFillWith._tiBuffer[0], offset, end);
      return this;
    }

    // multiple byte fill!
    const length = end - offset;
    for (let i = 0; i < length; i++) {
      // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
      const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
      this.setAdjustedIndex(i + offset, fillChar);
    }
  }
};
Buffer$1.prototype.includes = function (value, byteOffset, encoding) {
  return this.indexOf(value, byteOffset, encoding) !== -1;
};

/**
 * @param {string|Buffer|integer} value What to search for
 * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf
 * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf
 * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.
 */
Buffer$1.prototype.indexOf = function (value, byteOffset, encoding) {
  if (this.length === 0) {
    // empty buffer? can't find anything!
    return -1;
  }

  // if byteOffset is undefined, make it 0
  if (typeof byteOffset === 'undefined') {
    byteOffset = 0;
  } else if (typeof byteOffset === 'string') {
    // if it's a string, that's actually encoding
    encoding = byteOffset;
    byteOffset = 0;
  }

  // if we don't have an encoding yet, use utf8
  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }
  if (byteOffset < 0) {
    // convert negative indices
    byteOffset = this.length + byteOffset;
    if (byteOffset < 0) {
      // still negative? start at 0
      byteOffset = 0;
    }
  } else if (byteOffset >= this.length) {
    return -1; // can't find past end of buffer!
  }

  if (typeof value === 'number') {
    value &= 0xFF; // clamp to 255
    // This is a simpler case, we have a single byte we need to search for
    // so just loop through and try to find it
    return indexOf(this, value, byteOffset);
  }

  // coerce a string to a Buffer
  if (typeof value === 'string') {
    value = fromString(value, encoding);
  }

  // value is now a Buffer...
  const matchLength = value.length;
  if (matchLength === 0) {
    return -1; // never find empty value!
  }

  if (matchLength === 1) {
    // simple case, match one byte!
    return indexOf(this, value[0], byteOffset);
  }
  let currentIndex = byteOffset;
  const thisLength = this.length;
  if (matchLength > thisLength) {
    return -1; // can't match if the value is longer than this Buffer!
  }

  // FIXME: Can we rewrite this in a less funky way?
  // FIXME: Can stop earlier based on matchLength!
  firstMatch: while (currentIndex < thisLength) {
    // eslint-disable-line no-labels
    // match first byte!
    let firstByteMatch = indexOf(this, value[0], currentIndex);
    if (firstByteMatch === -1) {
      // couldn't even match the very first byte, so no match overall!
      return -1;
    }

    // ok, we found the first byte, now we need to see if the next consecutive bytes match!
    for (let x = 1; x < matchLength; x++) {
      if (firstByteMatch + x >= thisLength) {
        currentIndex = firstByteMatch + 1; // move past our first match
        continue firstMatch; // eslint-disable-line no-labels
      }

      if (this[firstByteMatch + x] !== value[x]) {
        // didn't match!
        currentIndex = firstByteMatch + 1; // move past our first match
        continue firstMatch; // eslint-disable-line no-labels
      }
    }

    return firstByteMatch; // the rest matched, hurray!
  }

  return -1;
};
Buffer$1.prototype.keys = function () {
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: nextIndex,
          done: false
        };
        nextIndex++;
        return result;
      }
      return {
        value: undefined,
        done: true
      };
    },
    [Symbol.iterator]: function () {
      return this;
    }
  };
  return myIterator;
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readDoubleBE = function (offset = 0) {
  checkOffset(this, offset, 8);

  // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder
  uint8DoubleArray[7] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[0] = this[offset++];
  return doubleArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
 * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readDoubleLE = function (offset = 0) {
  checkOffset(this, offset, 8);

  // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder
  uint8DoubleArray[0] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[7] = this[offset++];
  return doubleArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readFloatBE = function (offset = 0) {
  checkOffset(this, offset, 4);

  // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder
  uint8FloatArray[3] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[0] = this[offset++];
  return floatArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
 * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
 */
Buffer$1.prototype.readFloatLE = function (offset = 0) {
  checkOffset(this, offset, 4);

  // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder
  uint8FloatArray[0] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[3] = this[offset++];
  return floatArray[0];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.readInt8 = function (offset = 0) {
  const unsignedValue = this.readUInt8(offset);
  return unsignedToSigned(unsignedValue, 1);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readInt16BE = function (offset) {
  const unsignedValue = this.readUInt16BE(offset);
  return unsignedToSigned(unsignedValue, 2);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readInt16LE = function (offset = 0) {
  const unsignedValue = this.readUInt16LE(offset);
  return unsignedToSigned(unsignedValue, 2);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readInt32BE = function (offset = 0) {
  const unsignedValue = this.readUInt32BE(offset);
  return unsignedToSigned(unsignedValue, 4);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readInt32LE = function (offset = 0) {
  const unsignedValue = this.readUInt32LE(offset);
  return unsignedToSigned(unsignedValue, 4);
};

/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readIntBE = function (offset, byteLength) {
  const unsignedValue = this.readUIntBE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};

/**
 * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readIntLE = function (offset, byteLength) {
  const unsignedValue = this.readUIntLE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt8 = function (offset = 0) {
  checkOffset(this, offset, 1);
  return this[offset];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt16BE = function (offset = 0) {
  checkOffset(this, offset, 2);
  // first byte shifted and OR'd with second byte
  return this[offset] << 8 | this[offset + 1];
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt16LE = function (offset = 0) {
  checkOffset(this, offset, 2);
  // first byte OR'd with second byte shifted
  return this[offset] | this[offset + 1] << 8;
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt32BE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the "sign bit"
  // (because bit-wise operators assume a 32-bit number)
};

/**
 * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.readUInt32LE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the "sign bit"
};

/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readUIntBE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte
  // we're doing the same loop as #readUIntLE, just backwards!
  for (let i = byteLength - 1; i >= 0; i--) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};

/**
 * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.readUIntLE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte
  for (let i = 0; i < byteLength; i++) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};

/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */
Buffer$1.prototype.slice = function (start, end) {
  const thisLength = this.length;
  if (typeof start === 'undefined') {
    start = 0;
  } else if (start < 0) {
    start = thisLength + start;
    if (start < 0) {
      // if this is still negative, use 0 (that matches Node)
      start = 0;
    }
  }
  if (typeof end === 'undefined') {
    end = thisLength;
  } else if (end < 0) {
    end = thisLength + end;
  }
  // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.
  if (end > thisLength) {
    end = thisLength;
  }
  // What if end is less than start?
  let length = end - start;
  if (length <= 0) {
    length = 0; // return empty view of Buffer! retain byte offset, set length to 0
  }
  // Wrap the same ArrayBuffer object but specify the start/end to "crop" with
  return this._slice(this.byteOffset + start, length);
};
Buffer$1.prototype._slice = function (offset, length) {
  return new FastBuffer(this.buffer, offset, length);
};

/**
 * @param {integer} [start=0] Where the new `Buffer` will start.
 * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
 * @returns {Buffer}
 */
Buffer$1.prototype.subarray = function (start, end) {
  return this.slice(start, end);
};

/**
 * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.
 * @returns {Buffer}
 */
Buffer$1.prototype.swap16 = function () {
  const length = this.length;
  if (length % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (let i = 0; i < length; i += 2) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    this.setAdjustedIndex(i, second);
    this.setAdjustedIndex(i + 1, first);
  }
  return this;
};

/**
 * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.
 * @returns {Buffer}
 */
Buffer$1.prototype.swap32 = function () {
  const length = this.length;
  if (length % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (let i = 0; i < length; i += 4) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    this.setAdjustedIndex(i, fourth);
    this.setAdjustedIndex(i + 1, third);
    this.setAdjustedIndex(i + 2, second);
    this.setAdjustedIndex(i + 3, first);
  }
  return this;
};

/**
 * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.
 * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.
 * @returns {Buffer}
 */
Buffer$1.prototype.swap64 = function () {
  const length = this.length;
  if (length % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (let i = 0; i < length; i += 8) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    const fifth = this.getAdjustedIndex(i + 4);
    const sixth = this.getAdjustedIndex(i + 5);
    const seventh = this.getAdjustedIndex(i + 6);
    const eighth = this.getAdjustedIndex(i + 7);
    this.setAdjustedIndex(i, eighth);
    this.setAdjustedIndex(i + 1, seventh);
    this.setAdjustedIndex(i + 2, sixth);
    this.setAdjustedIndex(i + 3, fifth);
    this.setAdjustedIndex(i + 4, fourth);
    this.setAdjustedIndex(i + 5, third);
    this.setAdjustedIndex(i + 6, second);
    this.setAdjustedIndex(i + 7, first);
  }
  return this;
};

/**
 * @returns {object}
 */
Buffer$1.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    // Take advantage of slice working on "Array-like" objects (just like `arguments`)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
    data: [].slice.call(this)
  };
};

/**
 * @param {string} [encoding='utf8'] The character encoding to use
 * @param {integer} [start=0] The byte offset to start decoding at
 * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default
 * @returns {string}
 */
Buffer$1.prototype.toString = function (encoding, start, end) {
  // fast case of no args
  if (arguments.length === 0) {
    return this.toTiBuffer().toString();
  }
  const length = this.length;
  if (start >= length) {
    return ''; // start is past end of buffer, return empty string
  }

  if (start < 0 || typeof start !== 'number') {
    start = 0;
  }
  if (end > length || typeof end !== 'number') {
    // no end specified, or past end of buffer, use length of buffer
    end = length;
  } // else keep end as passed in

  if (end <= start) {
    return ''; // if end is before start return empty string
  }

  // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?
  if (start !== 0 || end !== length) {
    return this.slice(start, end).toString(encoding);
  }

  // base case, start is 0, end is length
  if (encoding === undefined) {
    encoding = 'utf8';
  } else {
    encoding = encoding.toLowerCase();
    // Throw if bad encoding!
    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }
  }
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return this.toTiBuffer().toString(); // we return utf-8 by default natively
  }

  if (encoding === 'base64') {
    return Ti.Utils.base64encode(this.toTiBuffer().toBlob()).toString();
  }
  if (encoding === 'hex') {
    return this.hexSlice(0, length);
  }
  if (encoding === 'latin1' || encoding === 'binary') {
    let latin1String = '';
    for (let i = 0; i < length; i++) {
      // each one is a "byte"
      latin1String += String.fromCharCode(this.getAdjustedIndex(i));
    }
    return latin1String;
  }
  if (encoding === 'ascii') {
    let ascii = '';
    for (let i = 0; i < length; i++) {
      // we store bytes (8-bit), but ascii is 7-bit. Node "masks" the last bit off, so let's do the same
      ascii += String.fromCharCode(this.getAdjustedIndex(i) & 0x7F);
    }
    return ascii;
  }

  // UCS2/UTF16
  return this.ucs2Slice(0, length);
};
Buffer$1.prototype.getAdjustedIndex = function (index) {
  return this[index];
};
Buffer$1.prototype.setAdjustedIndex = function (index, value) {
  return this[index] = value;
};
Buffer$1.prototype.hexSlice = function (start, end) {
  let hexStr = '';
  for (let i = start; i < end; i++) {
    // each one is a "byte"
    let hex = (this.getAdjustedIndex(i) & 0xff).toString(16);
    hex = hex.length === 1 ? '0' + hex : hex;
    hexStr += hex;
  }
  return hexStr;
};
Buffer$1.prototype.ucs2Slice = function (start, end) {
  let out = '';
  let i = start;
  while (i < end) {
    // utf-16/ucs-2 is 2-bytes per character
    const byte1 = this.getAdjustedIndex(i++);
    const byte2 = this.getAdjustedIndex(i++);
    const code_unit = (byte2 << 8) + byte1; // we mash together the two bytes
    out += String.fromCodePoint(code_unit);
  }
  return out;
};

/**
 * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
 * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
 */
Buffer$1.prototype.toTiBuffer = function () {
  const tiBuffer = Ti.createBuffer({
    length: this.length
  });
  copyBuffer(this, tiBuffer, 0, this.length);
  return tiBuffer;
};

/**
 * @param {Buffer} src source Buffer we're copying from
 * @param {Ti.Buffer} dest destination Ti.Buffer we're copying into
 * @param {integer} offset start offset we're copying to in destination
 * @param {integer} length number of bytes to copy
 * @returns {integer} actual number of bytes copied
 */
function copyBuffer(src, dest, offset, length) {
  const srcLength = src.length;
  const destLength = dest.length;
  let i = 0;
  for (; i < length; i++) {
    const destIndex = i + offset;
    // are we trying to write past end of destination? Or read past end of source? Stop!
    if (destIndex >= destLength || i >= srcLength) {
      break;
    }
    dest[destIndex] = src[i];
  }
  return i;
}

/**
 * Creates and returns an iterator for buf values (bytes)
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?
Buffer$1.prototype.values = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: buffer.getAdjustedIndex(nextIndex),
          done: false
        };
        nextIndex++;
        return result;
      }
      return {
        value: undefined,
        done: true
      };
    },
    [Symbol.iterator]: function () {
      return this;
    }
  };
  return myIterator;
};

/**
 * Called when buffer is used in a for..of loop. Delegates to #values()
 * @returns {Iterator}
 */
// TODO: Move to SlowBuffer?
Buffer$1.prototype[Symbol.iterator] = function () {
  return this.values();
};

/**
 * Writes string to buf at offset according to the character encoding in encoding.
 * The length parameter is the number of bytes to write. If buf did not contain enough space to
 * fit the entire string, only part of string will be written. However, partially encoded
 * characters will not be written.
 * @param {string} string String to write to `buf`.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write string
 * @param {integer} [length=buf.length - offset] Number of bytes to write
 * @param {string} [encoding='utf8'] The character encoding of string
 * @returns {integer}
 */
Buffer$1.prototype.write = function (string, offset, length, encoding) {
  if (typeof offset === 'string') {
    encoding = offset;
    offset = 0;
    length = this.length;
  } else if (typeof length === 'string') {
    encoding = length;
    length = this.length - offset;
  } else {
    // we cap `length` at the length of our buffer
    const remaining = this.length - offset;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = encoding || 'utf8';
  // so we need to convert `remaining` bytes of our string into a byte array/buffer
  const src = fromString(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?

  // then stick that into our buffer starting at `offset`!
  return src.copy(this, offset, 0, length);
};
Buffer$1.prototype.writeDoubleBE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeDoubleLE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeFloatBE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  return offset; // at this point, we should have already added 4 to offset
};

Buffer$1.prototype.writeFloatLE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  return offset; // at this point, we should have already added 4 to offset
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, -128, 127);
  if (value >= 0) {
    // just write it normally
    this.setAdjustedIndex(offset, value);
  } else {
    // convert from signed to 2's complement bits
    this.setAdjustedIndex(offset, 0xFF + value + 1); // max value, plus the negative number, add one
  }

  return offset + 1;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value >>> 8); // just shift over a byte
  this.setAdjustedIndex(offset + 1, value & 0xFF); // mask to first byte

  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xFF);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);
  if (value < 0) {
    value = minMaxBase * 2 + value;
  }
  let multiplier = 1;
  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0x100;
  }
  return offset + byteLength;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);
  if (value < 0) {
    value = minMaxBase * 2 + value;
  }
  let multiplier = 1;
  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }
  return offset + byteLength;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, 0, 255);
  this.setAdjustedIndex(offset, value);
  return offset + 1;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value >>> 8);
  this.setAdjustedIndex(offset + 1, value & 0xff);
  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xff);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
 * @returns {integer}
 */
Buffer$1.prototype.writeUInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeUIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;
  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }
  return offset + byteLength;
};

/**
 * @param {integer} value Number to be written to buf.
 * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
 * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
 * @returns {integer}
 */
Buffer$1.prototype.writeUIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }
  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;
  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }
  return offset + byteLength;
};

// TODO: Implement remaining instance methods:
// buf.lastIndexOf(value[, byteOffset][, encoding])
// buf.readBigInt64BE([offset])
// buf.readBigInt64LE([offset])
// buf.readBigUInt64BE([offset])
// buf.readBigUInt64LE([offset])
// buf.writeBigInt64BE(value[, offset])
// buf.writeBigInt64LE(value[, offset])
// buf.writeBigUInt64BE(value[, offset])
// buf.writeBigUInt64LE(value[, offset])

// FIXME: We need to minimize using a backing Ti.Buffer whenever possible, because
// going back and forth across the bridge for every byte is *very* expensive
// Ideally we should have a "SlowBuffer" that is used when we explicitly wrap a Ti.Buffer
// So that writes are passed through. Otherwise we should avoid using one at all costs
// i.e. when we do Buffer.concat and are only doing reads - why do we need a Ti.Buffer?
// Can we have Ti.Buffer really just wrap a Uint8Array and add it's own methods?
Buffer$1.allocUnsafe = function (length) {
  return new FastBuffer(length);
};
Buffer$1.allocUnsafeSlow = function (length) {
  return Buffer$1.allocUnsafe(length);
};
Buffer$1.alloc = function (length, fill = 0, encoding = 'utf8') {
  const buf = Buffer$1.allocUnsafe(length);
  if (fill !== 0) {
    buf.fill(fill, encoding);
  }
  return buf;
};

/**
 * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string
 * @param {string} [encoding='utf8'] encoding whose byte length we need to grab
 * @returns {integer}
 */
Buffer$1.byteLength = function (string, encoding = 'utf8') {
  if (typeof string !== 'string') {
    if (Buffer$1.isBuffer(string)) {
      return string.length; // return Buffer's length
    }

    return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView
  }

  let length = string.length;
  switch (encoding.toLowerCase()) {
    case 'utf8':
    case 'utf-8':
      return utf8ByteLength(string);
    case 'latin1':
    case 'binary':
    case 'ascii':
      return length;
    case 'ucs-2':
    case 'ucs2':
    case 'utf16le':
    case 'utf16-le':
      return 2 * length;
    case 'hex':
      return length / 2;
    case 'base64':
      // Subtract up to two padding chars from end of string!
      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }
      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }
      return Math.floor(length * 3 / 4);
    // drop fractional value
  }

  return utf8ByteLength(string);
};
Buffer$1.compare = function (buf1, buf2) {
  if (!Buffer$1.isBuffer(buf1)) {
    throw new TypeError(`The "buf1" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  }
  // TODO: Wrap UInt8Array args in buffers?
  return buf1.compare(buf2);
};

/**
 * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate
 * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.
 * @returns {Buffer}
 */
Buffer$1.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new TypeError('list argument must be an Array');
  }
  if (list.length === 0) {
    return new FastBuffer(); // one empty Buffer!
  }
  // allocate one Buffer of `totalLength`? Cap at totalLength?
  if (totalLength === undefined) {
    totalLength = 0;
    // generate the total length from each buffer's length?
    for (let i = 0; i < list.length; i++) {
      totalLength += list[i].length;
    }
  }
  const result = Buffer$1.allocUnsafe(totalLength);
  let position = 0;
  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(result, position);
    position += buf.length;
    if (position >= totalLength) {
      break;
    }
  }
  return result;
};

/**
 * @param {string} encoding possible encoding name
 * @returns {boolean}
 */
Buffer$1.isEncoding = function (encoding) {
  if (typeof encoding !== 'string') {
    return false;
  }
  return VALID_ENCODINGS.includes(encoding.toLowerCase());
};

/**
 * @param {*} obj possible Buffer instance
 * @returns {boolean}
 */
Buffer$1.isBuffer = function (obj) {
  return obj !== null && obj !== undefined && (obj instanceof Buffer$1 || obj[isBuffer] === true);
};
let INSPECT_MAX_BYTES = 50;
// Override how buffers are presented by util.inspect().
Buffer$1.prototype[customInspectSymbol] = function (recurseTimes, ctx) {
  const max = INSPECT_MAX_BYTES;
  const actualMax = Math.min(max, this.length);
  const remaining = this.length - max;
  let str = this.slice(0, actualMax).toString('hex').replace(/(.{2})/g, '$1 ').trim();
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  }
  // Inspect special properties as well, if possible.
  if (ctx) {
    let extras = false;
    const filter = ctx.showHidden ? ALL_PROPERTIES$1 : ONLY_ENUMERABLE$1;
    const obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {
      extras = true;
      obj[key] = this[key];
      return obj;
    }, Object.create(null));
    if (extras) {
      if (this.length !== 0) {
        str += ', ';
      }
      // '[Object: null prototype] {'.length === 26
      // This is guarded with a test.
      str += inspect(obj, {
        ...ctx,
        breakLength: Infinity,
        compact: true
      }).slice(27, -2);
    }
  }
  return `<${this.constructor.name} ${str}>`;
};
Buffer$1.prototype.inspect = Buffer$1.prototype[customInspectSymbol];

// HACK: ArrayBuffer.isView returns true for Node Buffer, but false for us. Until we can extend Uint8Array, we need to hack this sniffing method
const ArrayBufferIsView = ArrayBuffer.isView;
ArrayBuffer.isView = function (thing) {
  return ArrayBufferIsView(thing) || thing instanceof Buffer$1;
};
Object.setPrototypeOf(SlowBuffer.prototype, Buffer$1.prototype);
Object.setPrototypeOf(SlowBuffer, Buffer$1);
var BufferModule = {
  Buffer: Buffer$1,
  // TODO: Implement transcode()!
  transcode: (_source, _fromEncoding, _toEncoding) => {},
  INSPECT_MAX_BYTES: 50,
  kMaxLength: 2147483647,
  kStringMaxLength: 1073741799,
  constants: {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 1073741799
  }
};

/**
 * Searches a Buffer for the index of a single byte.
 * @param {Buffer} buffer buffer to search
 * @param {integer} singleByte byte we're looking for
 * @param {integer} offset start offset we search at
 * @returns {integer}
 */
function indexOf(buffer, singleByte, offset) {
  const length = buffer.length;
  for (let i = offset; i < length; i++) {
    if (buffer.getAdjustedIndex(i) === singleByte) {
      return i;
    }
  }
  return -1;
}

/**
 * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.
 * It's possible we may be able to use them when byteLength < 4 if that's faster.
 *
 * @param {integer} unsignedValue value before converting back to signed
 * @param {integer} byteLength number of bytes
 * @returns {integer} the signed value that is represented by the unsigned value's bytes
 */
function unsignedToSigned(unsignedValue, byteLength) {
  const bitLength = byteLength * 8;
  const maxPositiveValue = Math.pow(2, bitLength - 1);
  if (unsignedValue < maxPositiveValue) {
    return unsignedValue;
  }
  const maxUnsignedValue = Math.pow(2, bitLength);
  unsignedValue -= maxUnsignedValue;
  return unsignedValue;
}

/**
 * @param {string} string utf-8 string
 * @returns {integer}
 */
function utf8ByteLength(string) {
  // Just convert to a Ti.Buffer and let it tell us the length
  const buf = Ti.createBuffer({
    value: string,
    type: Ti.Codec.CHARSET_UTF8
  });
  const length = buf.length;
  buf.release(); // release the buffer since we just needed the length
  return length;
}

/**
 * Throws a RangeError if offset is out of bounds
 * @param {Buffer} buffer buffer we're operating on
 * @param {integer} offset user supplied offset
 * @param {integer} byteLength number of bytes needed in range
 * @throws {RangeError}
 */
function checkOffset(buffer, offset, byteLength) {
  const endOffset = buffer.length - byteLength;
  if (offset < 0 || offset > endOffset) {
    throw new RangeError(`The value of "offset" is out of range. It must be >= 0 and <= ${endOffset}. Received ${offset}`);
  }
}

/**
 * @param {integer} value user-supplied value
 * @param {integer} min minimum valid value
 * @param {integer} max maximum valid value
 * @throws {RangeError}
 */
function checkValue(value, min, max) {
  if (value < min || value > max) {
    throw new RangeError(`The value of "value" is out of range. It must be >= ${min} and <= ${max}. Received ${value}`);
  }
}
let bufferWarningAlreadyEmitted = false;
let nodeModulesCheckCounter = 0;
const bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';
function showFlaggedDeprecation() {
  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {
    // We don't emit a warning, because we either:
    // - Already did so, or
    // - Already checked too many times whether a call is coming
    //   from node_modules and want to stop slowing down things, or
    // - The code is inside `node_modules`.
    return;
  }
  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');
  bufferWarningAlreadyEmitted = true;
}

// Copyright Node.js contributors. All rights reserved.
const {
  ALL_PROPERTIES,
  ONLY_ENUMERABLE
} = propertyFilter;
const BooleanPrototype = Boolean.prototype;
const DatePrototype = Date.prototype;
const ErrorPrototype = Error.prototype;
const NumberPrototype = Number.prototype;
const MapPrototype = Map.prototype;
const RegExpPrototype = RegExp.prototype;
const StringPrototype = String.prototype;
const SetPrototype = Set.prototype;
const SymbolPrototype = Symbol.prototype;
const isIos = ['ipad', 'iphone'].includes("android");
const {
  ERR_INVALID_ARG_TYPE
} = codes;
const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
let hexSlice = uncurryThis(BufferModule.Buffer.prototype.hexSlice);
const builtInObjects = new Set(Object.getOwnPropertyNames(global).filter((e) => /^([A-Z][a-z]+)+$/.test(e)));
const inspectDefaultOptions = Object.seal({
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false
});
const kObjectType = 0;
const kArrayType = 1;
const kArrayExtrasType = 2;

/* eslint-disable no-control-regex */
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c]/g;
/* eslint-enable no-control-regex */

const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const kMinLineLength = 16;

// Constants to map the iterator state.
const kWeak = 0;
const kIterator = 1;
const kMapEntries = 2;

// Escaped special characters. Use empty strings to fill up unused entries.
/* eslint-disable quotes */
const meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '', '', '', '', '', "\\'", '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];
/* eslint-enable quotes */

function getUserOptions(ctx) {
  const obj = {
    stylize: ctx.stylize
  };
  for (const key of Object.keys(inspectDefaultOptions)) {
    obj[key] = ctx[key];
  }
  if (ctx.userOptions === undefined) {
    return obj;
  }
  return {
    ...obj,
    ...ctx.userOptions
  };
}

/**
 * Echos the value of any input. Tries to print the value out
 * in the best way possible given the different types.
 *
 * @param {any} value The value to print out.
 * @param {Object} opts Optional options object that alters the output.
 * @return {string} The string representation of `value`
 */
function inspect(value, opts) {
  // Default options
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters
  };
  if (arguments.length > 1) {
    // Legacy...
    if (arguments.length > 2) {
      if (arguments[2] !== undefined) {
        ctx.depth = arguments[2];
      }
      if (arguments.length > 3 && arguments[3] !== undefined) {
        ctx.colors = arguments[3];
      }
    }
    // Set user-specified options
    if (typeof opts === 'boolean') {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);
      for (const key of optKeys) {
        // TODO(BridgeAR): Find a solution what to do about stylize. Either make
        // this function public or add a new API with a similar or better
        // functionality.
        if (hasOwnProperty(inspectDefaultOptions, key) || key === 'stylize') {
          ctx[key] = opts[key];
        } else if (ctx.userOptions === undefined) {
          // This is required to pass through the actual user input.
          ctx.userOptions = opts;
        }
      }
    }
  }
  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }
  if (ctx.maxArrayLength === null) {
    ctx.maxArrayLength = Infinity;
  }
  return formatValue(ctx, value, 0);
}
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, 'defaultOptions', {
  get() {
    return inspectDefaultOptions;
  },
  set(options) {
    if (options === null || typeof options !== 'object') {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }
    Object.assign(inspectDefaultOptions, options);
  }
});

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = Object.assign(Object.create(null), {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
});

// Don't use 'blue' not visible on cmd.exe
inspect.styles = Object.assign(Object.create(null), {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  // "name": intentionally not styling
  regexp: 'red',
  module: 'underline'
});
function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }
  if (quotes === -2) {
    return `\`${str}\``;
  }
  return `'${str}'`;
}
const escapeFn = (str) => meta[str.charCodeAt(0)];

// Escape control characters, single quotes and the backslash.
// This is similar to JSON stringify escaping.
function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39;

  // Check for double quotes. If not present, do not escape single quotes and
  // instead wrap the text in double quotes. If double quotes exist, check for
  // backticks. If they do not exist, use those as fallback instead of the
  // double quotes.
  // eslint-disable-next-line quotes
  if (str.includes("'")) {
    // This invalidates the charCode and therefore can not be matched for
    // anymore.
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes('`') && !str.includes('${')) {
      singleQuote = -2;
    }
    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  }

  // Some magic numbers that worked out fine while benchmarking with v8 6.0
  if (str.length < 5000 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }
  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }
  let result = '';
  let last = 0;
  const lastIndex = str.length;
  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);
    if (point === singleQuote || point === 92 || point < 32) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }
      last = i + 1;
    }
  }
  if (last !== lastIndex) {
    result += str.slice(last);
  }
  return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];
  if (style !== undefined) {
    const color = inspect.colors[style];
    return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
  }
  return str;
}
function stylizeNoColor(str) {
  return str;
}

// Return a new empty array to push in the results of the default formatter.
function getEmptyFormatArray() {
  return [];
}
function getConstructorName(obj, _ctx) {
  let firstProto;
  // const tmp = obj;
  while (obj) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value.name;
    }
    obj = Object.getPrototypeOf(obj);
    if (firstProto === undefined) {
      firstProto = obj;
    }
  }
  if (firstProto === null) {
    return null;
  }

  /*
   @todo this calls into native, can we replace this somehow?
  return `${internalGetConstructorName(tmp)} <${inspect(firstProto, {
  	...ctx,
  	customInspect: false
  })}>`;
  */

  return null;
}
function getPrefix(constructor, tag, fallback) {
  if (constructor === null) {
    if (tag !== '') {
      return `[${fallback}: null prototype] [${tag}] `;
    }
    return `[${fallback}: null prototype] `;
  }
  if (tag !== '' && constructor !== tag) {
    return `${constructor} [${tag}] `;
  }
  return `${constructor} `;
}

// Look up the keys of the object.
function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);
  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);
    if (symbols.length !== 0) {
      keys.push(...symbols);
    }
  } else {
    // This might throw if `value` is a Module Namespace Object from an
    // unevaluated module, but we don't want to perform the actual type
    // check because it's expensive.
    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209
    // and modify this logic as needed.
    try {
      keys = Object.keys(value);
    } catch (err) {
      // @fixme how to du isModuleNamespaceObject?
      /*
      assert(isNativeError(err) && err.name === 'ReferenceError' &&
      			 isModuleNamespaceObject(value));
      */
      keys = Object.getOwnPropertyNames(value);
    }
    if (symbols.length !== 0) {
      keys.push(...symbols.filter((key) => propertyIsEnumerable(value, key)));
    }
  }
  return keys;
}
function getCtxStyle(value, constructor, tag) {
  let fallback = '';
  if (constructor === null) {
    fallback = 'Object';
  }
  return getPrefix(constructor, tag, fallback);
}
function findTypedConstructor(value) {
  for (const [check, clazz] of [[isUint8Array, Uint8Array], [isUint8ClampedArray, Uint8ClampedArray], [isUint16Array, Uint16Array], [isUint32Array, Uint32Array], [isInt8Array, Int8Array], [isInt16Array, Int16Array], [isInt32Array, Int32Array], [isFloat32Array, Float32Array], [isFloat64Array, Float64Array]]) {
    if (check(value)) {
      return clazz;
    }
  }
}
let lazyNullPrototypeCache;
// Creates a subclass and name
// the constructor as `${clazz} : null prototype`
function clazzWithNullPrototype(clazz, name) {
  if (lazyNullPrototypeCache === undefined) {
    lazyNullPrototypeCache = new Map();
  } else {
    const cachedClass = lazyNullPrototypeCache.get(clazz);
    if (cachedClass !== undefined) {
      return cachedClass;
    }
  }
  class NullPrototype extends clazz {
    get [Symbol.toStringTag]() {
      return '';
    }
  }
  Object.defineProperty(NullPrototype.prototype.constructor, 'name', {
    value: `[${name}: null prototype]`
  });
  lazyNullPrototypeCache.set(clazz, NullPrototype);
  return NullPrototype;
}
function noPrototypeIterator(ctx, value, recurseTimes) {
  let newVal;
  if (isSet(value)) {
    const clazz = clazzWithNullPrototype(Set, 'Set');
    newVal = new clazz(SetPrototype.values(value));
  } else if (isMap(value)) {
    const clazz = clazzWithNullPrototype(Map, 'Map');
    newVal = new clazz(MapPrototype.entries(value));
  } else if (Array.isArray(value)) {
    const clazz = clazzWithNullPrototype(Array, 'Array');
    newVal = new clazz(value.length);
  } else if (isTypedArray(value)) {
    const constructor = findTypedConstructor(value);
    const clazz = clazzWithNullPrototype(constructor, constructor.name);
    newVal = new clazz(value);
  }
  if (newVal !== undefined) {
    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));
    return formatRaw(ctx, newVal, recurseTimes);
  }
}
function formatValue(ctx, value, recurseTimes, typedArray) {
  // Primitive types cannot have properties.
  if (typeof value !== 'object' && typeof value !== 'function') {
    return formatPrimitive(ctx.stylize, value, ctx);
  }
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
  // Memorize the context for custom inspection on proxies.
  const context = value;
  /*
  @fixme check for proxies
  // Always check for proxies to prevent side effects and to prevent triggering
  // any proxy handlers.
  const proxy = getProxyDetails(value);
  if (proxy !== undefined) {
  	if (ctx.showProxy) {
  		return formatProxy(ctx, proxy, recurseTimes);
  	}
  	value = proxy[0];
  }
  */
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it.
  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];
    if (typeof maybeCustom === 'function'
    // Filter out the util module, its inspect function is special.
    && maybeCustom !== inspect
    // Also filter out any prototype objects using the circular check.
    && !(value.constructor && value.constructor.prototype === value)) {
      // This makes sure the recurseTimes are reported as before while using
      // a counter internally.
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx));
      // If the custom inspection method returned `this`, don't go into
      // infinite recursion.
      if (ret !== context) {
        if (typeof ret !== 'string') {
          return formatValue(ctx, ret, recurseTimes);
        }
        return ret.replace(/\n/g, `\n${' '.repeat(ctx.indentationLvl)}`);
      }
    }
  }
  // Using an array here is actually better for the average case than using
  // a Set. `seen` will only check for the depth and will never grow too large.
  if (ctx.seen.includes(value)) {
    let index = 1;
    if (ctx.circular === undefined) {
      ctx.circular = new Map([[value, index]]);
    } else {
      index = ctx.circular.get(value);
      if (index === undefined) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }
    return ctx.stylize(`[Circular *${index}]`, 'special');
  }
  return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  const constructor = getConstructorName(value);
  let tag = value[Symbol.toStringTag];
  // Only list the tag in case it's non-enumerable / not an own property.
  // Otherwise we'd print this twice.
  if (typeof tag !== 'string' || tag !== '' && (ctx.showHidden ? hasOwnProperty : propertyIsEnumerable)(value, Symbol.toStringTag)) {
    tag = '';
  }
  let base = '';
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;
  let extrasType = kObjectType;

  // Iterators and the rest are split to reduce checks.
  if (value[Symbol.iterator]) {
    noIterator = false;
    if (Array.isArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      // Only set the constructor for non ordinary ("Array [...]") arrays.
      const prefix = getPrefix(constructor, tag, 'Array');
      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];
      if (value.length === 0 && keys.length === 0) {
        return `${braces[0]}]`;
      }
      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Set');
      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, '}'];
      formatter = formatSet;
    } else if (isMap(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Map');
      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }
      braces = [`${prefix}{`, '}'];
      formatter = formatMap;
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const prefix = constructor !== null ? getPrefix(constructor, tag) : getPrefix(constructor, tag, findTypedConstructor(value).name);
      braces = [`${prefix}[`, ']'];
      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }
      formatter = formatTypedArray;
      extrasType = kArrayExtrasType;
    } else if (isMapIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Map', tag);
      formatter = formatIterator;
    } else if (isSetIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Set', tag);
      formatter = formatIterator;
    } else {
      noIterator = true;
    }
  }
  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ['{', '}'];
    if (constructor === 'Object') {
      if (isArgumentsObject(value)) {
        braces[0] = '[Arguments] {';
      } else if (tag !== '') {
        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;
      }
      if (keys.length === 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === 'function') {
      base = getFunctionBase(value, constructor, tag);
      if (keys.length === 0) {
        return ctx.stylize(base, 'special');
      }
    } else if (isRegExp(value)) {
      // Make RegExps say that they are RegExps
      // eslint-disable-next-line security/detect-non-literal-regexp
      const regExp = constructor !== null ? value : new RegExp(value);
      base = RegExpPrototype.toString.call(regExp);
      const prefix = getPrefix(constructor, tag, 'RegExp');
      if (prefix !== 'RegExp ') {
        base = `${prefix}${base}`;
      }
      if (keys.length === 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base, 'regexp');
      }
    } else if (isDate(value)) {
      // Make dates with properties first say the date
      base = Number.isNaN(DatePrototype.getTime.call(value)) ? DatePrototype.toString.call(value) : DatePrototype.toISOString.call(value);
      const prefix = getPrefix(constructor, tag, 'Date');
      if (prefix !== 'Date ') {
        base = `${prefix}${base}`;
      }
      if (keys.length === 0) {
        return ctx.stylize(base, 'date');
      }
    } else if (isError(value)) {
      base = formatError(value, constructor, tag, ctx);
      if (keys.length === 0) {
        return base;
      } else if (isIos) {
        const nativeErrorProps = ['line', 'column', 'sourceURL'];
        if (keys.every((key) => nativeErrorProps.includes(key))) {
          return base;
        }
      }
    } else if (isAnyArrayBuffer(value)) {
      // Fast path for ArrayBuffer and SharedArrayBuffer.
      // Can't do the same for DataView because it has a non-primitive
      // .buffer property that we need to recurse for.
      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' : 'SharedArrayBuffer';
      const prefix = getPrefix(constructor, tag, arrayType);
      if (typedArray === undefined) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0) {
        return `${prefix}{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }
      braces[0] = `${prefix}{`;
      keys.unshift('byteLength');
    } else if (isDataView(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;
      // .buffer goes last, it's not a primitive like the others.
      keys.unshift('byteLength', 'byteOffset', 'buffer');
    } else if (isPromise(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;
      formatter = formatPromise;
    } else if (isWeakSet(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
      /*
       * @fixme how to do isModuleNamespaceObject?
      } else if (isModuleNamespaceObject(value)) {
      	braces[0] = `[${tag}] {`;
      	formatter = formatNamespaceObject;
      */
    } else if (isBoxedPrimitive(value)) {
      base = getBoxedBase(value, ctx, keys, constructor, tag);
      if (keys.length === 0) {
        return base;
      }
    } else {
      // The input prototype got manipulated. Special handle these. We have to
      // rebuild the information so we are able to display everything.
      if (constructor === null) {
        const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);
        if (specialIterator) {
          return specialIterator;
        }
      }
      if (isMapIterator(value)) {
        braces = getIteratorBraces('Map', tag);
        formatter = formatIterator;
      } else if (isSetIterator(value)) {
        braces = getIteratorBraces('Set', tag);
        formatter = formatIterator;
        // Handle other regular objects again.
      } else {
        if (keys.length === 0) {
          return `${getCtxStyle(value, constructor, tag)}{}`;
        }
        braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
      }
    }
  }
  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }
    return ctx.stylize(constructorName, 'special');
  }
  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;
  try {
    output = formatter(ctx, value, recurseTimes, keys, braces);
    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
  } catch (err) {
    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
  }
  if (ctx.circular !== undefined) {
    const index = ctx.circular.get(value);
    if (index !== undefined) {
      const reference = ctx.stylize(`<ref *${index}>`, 'special');
      // Add reference always to the very beginning of the output.
      if (ctx.compact !== true) {
        base = base === '' ? reference : `${reference} ${base}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }
  ctx.seen.pop();
  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? undefined : ctx.sorted;
    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }
  const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength;
  // If any indentationLvl exceeds this limit, limit further inspecting to the
  // minimum. Otherwise the recursive algorithm might continue inspecting the
  // object even though the maximum string size (~2 ** 28 on 32 bit systems and
  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at
  // exactly 2 ** 27 but a bit higher. This depends on the object shape.
  // This limit also makes sure that huge objects don't block the event loop
  // significantly.
  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }
  return res;
}
function getIteratorBraces(type, tag) {
  if (tag !== `${type} Iterator`) {
    if (tag !== '') {
      tag += '] [';
    }
    tag += `${type} Iterator`;
  }
  return [`[${tag}] {`, '}'];
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
  let fn;
  let type;
  if (isNumberObject(value)) {
    fn = NumberPrototype;
    type = 'Number';
  } else if (isStringObject(value)) {
    fn = StringPrototype;
    type = 'String';
    // For boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    // Make boxed primitive Strings look like such
    keys.splice(0, value.length);
  } else if (isBooleanObject(value)) {
    fn = BooleanPrototype;
    type = 'Boolean';
  } else {
    fn = SymbolPrototype;
    type = 'Symbol';
  }
  let base = `[${type}`;
  if (type !== constructor) {
    if (constructor === null) {
      base += ' (null prototype)';
    } else {
      base += ` (${constructor})`;
    }
  }
  base += `: ${formatPrimitive(stylizeNoColor, fn.valueOf(value), ctx)}]`;
  if (tag !== '' && tag !== constructor) {
    base += ` [${tag}]`;
  }
  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base;
  }
  return ctx.stylize(base, type.toLowerCase());
}
function getFunctionBase(value, constructor, tag) {
  let type = 'Function';
  if (isGeneratorFunction(value)) {
    type = `Generator${type}`;
  }
  if (isAsyncFunction(value)) {
    type = `Async${type}`;
  }
  let base = `[${type}`;
  if (constructor === null) {
    base += ' (null prototype)';
  }
  if (value.name === '') {
    base += ' (anonymous)';
  } else {
    base += `: ${value.name}`;
  }
  base += ']';
  if (constructor !== type && constructor !== null) {
    base += ` ${constructor}`;
  }
  if (tag !== '' && constructor !== tag) {
    base += ` [${tag}]`;
  }
  return base;
}
function formatError(err, constructor, tag, ctx) {
  let stack = err.stack || ErrorPrototype.toString.call(err);
  // try to normalize JavaScriptCore stack to match v8
  if (isIos) {
    const lines = stack.split('\n');
    stack = `${err.name}: ${err.message}`;
    if (lines.length > 0) {
      stack += lines.map((stackLine) => {
        const atSymbolIndex = stackLine.indexOf('@');
        const source = stackLine.slice(atSymbolIndex + 1);
        const sourcePattern = /(.*):(\d+):(\d+)/;
        let symbolName = 'unknown';
        if (atSymbolIndex !== -1) {
          symbolName = stackLine.slice(0, atSymbolIndex);
        }
        const sourceMatch = source.match(sourcePattern);
        if (sourceMatch) {
          let filePath = sourceMatch[1];
          const lineNumber = sourceMatch[2];
          const column = sourceMatch[3];
          if (filePath.startsWith('file:')) {
            filePath = filePath.replace(`file://${Ti.Filesystem.resourcesDirectory}`, '');
          }
          return `\n    at ${symbolName} (${filePath}:${lineNumber}:${column})`;
        } else {
          return `\n    at ${symbolName} (${source})`;
        }
      }).join('');
    }
  }

  // A stack trace may contain arbitrary data. Only manipulate the output
  // for "regular errors" (errors that "look normal") for now.
  const name = err.name || 'Error';
  let len = name.length;
  if (constructor === null || name.endsWith('Error') && stack.startsWith(name) && (stack.length === len || stack[len] === ':' || stack[len] === '\n')) {
    let fallback = 'Error';
    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || '';
      len = fallback.length;
      fallback = fallback || 'Error';
    }
    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  }

  // Ignore the error message if it's contained in the stack.
  let pos = err.message && stack.indexOf(err.message) || -1;
  if (pos !== -1) {
    pos += err.message.length;
  }
  // Wrap the error in brackets in case it has no stack trace.
  let stackStart = stack.indexOf('\n    at', pos);
  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    // Highlight userland code and node modules.
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split('\n');
    for (const line of lines) {
      // This adds underscores to all node_modules to quickly identify them.
      let nodeModule;
      newStack += '\n';
      let pos = 0;
      while (nodeModule = nodeModulesRegExp.exec(line)) {
        // '/node_modules/'.length === 14
        newStack += line.slice(pos, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], 'module');
        pos = nodeModule.index + nodeModule[0].length;
      }
      newStack += pos === 0 ? line : line.slice(pos);
    }
    stack = newStack;
  }
  // The message and the stack have to be indented as well!
  if (ctx.indentationLvl !== 0) {
    const indentation = ' '.repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `\n${indentation}`);
  }
  return stack;
}
function formatPromise(ctx, _value, _recurseTimes) {
  // Node calls into native to get promise details which we can't do
  return [ctx.stylize('<unknown>', 'special')];
}
function formatProperty(ctx, value, recurseTimes, key, type) {
  let name, str;
  let extra = ' ';
  const desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key],
    enumerable: true
  };
  if (desc.value !== undefined) {
    const diff = type !== kObjectType || ctx.compact !== true ? 2 : 3;
    ctx.indentationLvl += diff;
    str = formatValue(ctx, desc.value, recurseTimes);
    if (diff === 3) {
      const len = ctx.colors ? removeColors(str).length : str.length;
      if (ctx.breakLength < len) {
        extra = `\n${' '.repeat(ctx.indentationLvl)}`;
      }
    }
    ctx.indentationLvl -= diff;
  } else if (desc.get !== undefined) {
    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';
    const s = ctx.stylize;
    const sp = 'special';
    if (ctx.getters && (ctx.getters === true || ctx.getters === 'get' && desc.set === undefined || ctx.getters === 'set' && desc.set !== undefined)) {
      try {
        const tmp = value[key];
        ctx.indentationLvl += 2;
        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;
        } else if (typeof tmp === 'object') {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;
        }
        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== undefined) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = ctx.stylize('undefined', 'undefined');
  }
  if (type === kArrayType) {
    return str;
  }
  if (typeof key === 'symbol') {
    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, 'symbol')}]`;
  } else if (desc.enumerable === false) {
    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;
  } else if (keyStrRegExp.test(key)) {
    name = ctx.stylize(key, 'name');
  } else {
    name = ctx.stylize(strEscape(key), 'string');
  }
  return `${name}:${extra}${str}`;
}
function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;
  if (ctx.maxArrayLength < output.length) {
    // This makes sure the "... n more items" part is not taken into account.
    outputLength--;
  }
  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.
  const dataLen = new Array(outputLength);
  // Calculate the total length of all output entries and the individual max
  // entries length of all output entries. We have to remove colors first,
  // otherwise the length would not be calculated properly.
  for (; i < outputLength; i++) {
    const len = ctx.colors ? removeColors(output[i]).length : output[i].length;
    dataLen[i] = len;
    totalLength += len + separatorSpace;
    if (maxLength < len) {
      maxLength = len;
    }
  }
  // Add two to `maxLength` as we add a single whitespace character plus a comma
  // in-between two entries.
  const actualMax = maxLength + separatorSpace;
  // Check if at least three entries fit next to each other and prevent grouping
  // of arrays that contains entries of very different length (i.e., if a single
  // entry is longer than 1/5 of all other entries combined). Otherwise the
  // space in-between small entries would be enormous.
  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
    // Dynamically check how many columns seem possible.
    const columns = Math.min(
    // Ideally a square should be drawn. We expect a character to be about 2.5
    // times as high as wide. This is the area formula to calculate a square
    // which contains n rectangles of size `actualMax * approxCharHeights`.
    // Divide that by `actualMax` to receive the correct number of columns.
    // The added bias increases the columns for short entries.
    Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax),
    // Do not exceed the breakLength.
    Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax),
    // Limit array grouping for small `compact` modes as the user requested
    // minimal grouping.
    ctx.compact * 4,
    // Limit the columns to a maximum of fifteen.
    15);
    // Return with the original output if no grouping should happen.
    if (columns <= 1) {
      return output;
    }
    const tmp = [];
    const maxLineLength = [];
    for (let i = 0; i < columns; i++) {
      let lineMaxLength = 0;
      for (let j = i; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }
      lineMaxLength += separatorSpace;
      maxLineLength[i] = lineMaxLength;
    }
    let order = 'padStart';
    if (value !== undefined) {
      for (let i = 0; i < output.length; i++) {
        if (typeof value[i] !== 'number') {
          order = 'padEnd';
          break;
        }
      }
    }
    // Each iteration creates a single line of grouped entries.
    for (let i = 0; i < outputLength; i += columns) {
      // The last lines may contain less entries than columns.
      const max = Math.min(i + columns, outputLength);
      let str = '';
      let j = i;
      for (; j < max - 1; j++) {
        // Calculate extra color padding in case it's active. This has to be
        // done line by line as some lines might contain more colors than
        // others.
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
        str += `${output[j]}, `[order](padding, ' ');
      }
      if (order === 'padStart') {
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - separatorSpace;
        str += output[j].padStart(padding, ' ');
      } else {
        str += output[j];
      }
      tmp.push(str);
    }
    if (ctx.maxArrayLength < output.length) {
      tmp.push(output[outputLength]);
    }
    output = tmp;
  }
  return output;
}
function handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {
  if (isStackOverflowError(err)) {
    ctx.seen.pop();
    ctx.indentationLvl = indentationLvl;
    return ctx.stylize(`[${constructorName}: Inspection interrupted 'prematurely. Maximum call stack size exceeded.]`, 'special');
  }
  throw err;
}
function formatNumber(fn, value) {
  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.
  return fn(Object.is(value, -0) ? '-0' : `${value}`, 'number');
}
function formatBigInt(fn, value) {
  return fn(`${value}n`, 'bigint');
}
function formatPrimitive(fn, value, ctx) {
  if (typeof value === 'string') {
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/\n/).map((line) => fn(strEscape(line), 'string')).join(` +\n${' '.repeat(ctx.indentationLvl + 2)}`);
    }
    return fn(strEscape(value), 'string');
  }
  if (typeof value === 'number') {
    return formatNumber(fn, value);
  }
  /*
  if (typeof value === 'bigint') {
  	return formatBigInt(fn, value);
  }
  */
  if (typeof value === 'boolean') {
    return fn(`${value}`, 'boolean');
  }
  if (typeof value === 'undefined') {
    return fn('undefined', 'undefined');
  }
  // es6 symbol primitive
  return fn(SymbolPrototype.toString.call(value), 'symbol');
}

// The array is sparse and/or has extra keys
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;
  for (; i < keys.length && output.length < maxLength; i++) {
    const key = keys[i];
    const tmp = +key;
    // Arrays can only have up to 2^32 - 1 entries
    if (tmp > 2 ** 32 - 2) {
      break;
    }
    if (`${index}` !== key) {
      if (!numberRegExp.test(key)) {
        break;
      }
      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? 's' : '';
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
      index = tmp;
      if (output.length === maxLength) {
        break;
      }
    }
    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));
    index++;
  }
  const remaining = value.length - index;
  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? 's' : '';
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatArrayBuffer(ctx, value) {
  const buffer = new Uint8Array(value);
  /*
  // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  if (hexSlice === undefined) {
  	hexSlice = uncurryThis(require('../../buffer').default.Buffer.prototype.hexSlice);
  }
  */
  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, '$1 ').trim();
  const remaining = buffer.length - ctx.maxArrayLength;
  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  }
  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];
}
function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];
  for (var i = 0; i < len; i++) {
    // Special handle sparse arrays.
    if (!hasOwnProperty(value, i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }
    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatTypedArray(ctx, value, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ? formatNumber : formatBigInt;
  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }
  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;
  }
  if (ctx.showHidden) {
    // .buffer goes last, it's not a primitive like the others.
    ctx.indentationLvl += 2;
    for (const key of ['BYTES_PER_ELEMENT', 'length', 'byteLength', 'byteOffset', 'buffer']) {
      const str = formatValue(ctx, value[key], recurseTimes, true);
      output.push(`[${key}]: ${str}`);
    }
    ctx.indentationLvl -= 2;
  }
  return output;
}
function formatSet(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const v of value) {
    output.push(formatValue(ctx, v, recurseTimes));
  }
  ctx.indentationLvl -= 2;
  // With `showHidden`, `length` will display as a hidden property for
  // arrays. For consistency's sake, do the same for `size`, even though this
  // property isn't selected by Object.getOwnPropertyNames().
  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }
  return output;
}
function formatMap(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;
  for (const [k, v] of value) {
    output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
  }
  ctx.indentationLvl -= 2;
  // See comment in formatSet
  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }
  return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  let output = new Array(maxLength);
  ctx.indentationLvl += 2;
  for (var i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }
  ctx.indentationLvl -= 2;
  if (state === kWeak && !ctx.sorted) {
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    output = output.sort();
  }
  const remaining = entries.length - maxLength;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  // Entries exist as [key1, val1, key2, val2, ...]
  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;
  if (state === kWeak) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)}` + ` => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    }
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [formatValue(ctx, entries[pos], recurseTimes), formatValue(ctx, entries[pos + 1], recurseTimes)];
      output[i] = reduceToSingleString(ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);
    }
  }
  ctx.indentationLvl -= 2;
  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }
  return output;
}
function formatWeakCollection(ctx) {
  return [ctx.stylize('<items unknown>', 'special')];
}
function formatWeakSet(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}
function formatWeakMap(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}
function formatIterator(ctx, value, recurseTimes, _keys, braces) {
  const entries = [];
  let isKeyValue = false;
  let result = value.next();
  while (!result.done) {
    const currentEntry = result.value;
    entries.push(currentEntry);
    if (currentEntry[0] !== currentEntry[1]) {
      isKeyValue = true;
    }
    result = value.next();
  }
  if (isKeyValue) {
    // Mark entry iterators as such.
    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }
  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}
function isBelowBreakLength(ctx, output, start, base) {
  // Each entry is separated by at least a comma. Thus, we start with a total
  // length of at least `output.length`. In addition, some cases have a
  // whitespace in-between each other that is added to the total as well.
  let totalLength = output.length + start;
  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }
  for (var i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }
    if (totalLength > ctx.breakLength) {
      return false;
    }
  }
  // Do not line up properties on the same line if `base` contains line breaks.
  return base === '' || !base.includes('\n');
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {
      // Memorize the original output length. In case the the output is grouped,
      // prevent lining up the entries on a single line.
      const entries = output.length;
      // Group array elements together if the array contains at least six
      // separate entries.
      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      }
      // `ctx.currentDepth` is set to the most inner depth of the currently
      // inspected object part while `recurseTimes` is the actual current depth
      // that is inspected.
      //
      // Example:
      //
      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }
      //
      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max
      // depth of 1.
      //
      // Consolidate all entries of the local most inner depth up to
      // `ctx.compact`, as long as the properties are smaller than
      // `ctx.breakLength`.
      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        // Line up all entries on a single line in case the entries do not
        // exceed `breakLength`. Add 10 as constant to start next to all other
        // factors that may reduce `breakLength`.
        const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
        if (isBelowBreakLength(ctx, output, start, base)) {
          return `${base ? `${base} ` : ''}${braces[0]} ${join$1(output, ', ')} ${braces[1]}`;
        }
      }
    }
    // Line up each entry on an individual line.
    const indentation = `\n${' '.repeat(ctx.indentationLvl)}`;
    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` + `${join$1(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  }
  // Line up all entries on a single line in case the entries do not exceed
  // `breakLength`.
  if (isBelowBreakLength(ctx, output, 0, base)) {
    return `${braces[0]}${base ? ` ${base}` : ''} ${join$1(output, ', ')} ` + braces[1];
  }
  const indentation = ' '.repeat(ctx.indentationLvl);
  // If the opening "brace" is too large, like in the case of "Set {",
  // we need to force the first item to be on the next line or the
  // items will not line up correctly.
  const ln = base === '' && braces[0].length === 1 ? ' ' : `${base ? ` ${base}` : ''}\n${indentation}  `;
  // Line up each entry on an individual line.
  return `${braces[0]}${ln}${join$1(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function format$1(...args) {
  return formatWithOptions(undefined, ...args);
}
const firstErrorLine = (error) => error.message.split('\n')[0];
let CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(e);
      }
    }
    if (err.name === 'TypeError' && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }
    throw err;
  }
}

/* eslint-disable max-depth */
function formatWithOptions(inspectOptions, ...args) {
  const first = args[0];
  let a = 0;
  let str = '';
  let join = '';
  if (typeof first === 'string') {
    if (args.length === 1) {
      return first;
    }
    let tempStr;
    let lastPos = 0;
    for (var i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        // '%'
        const nextChar = first.charCodeAt(++i);
        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              // 's'
              const tempArg = args[++a];
              if (typeof tempArg === 'number') {
                tempStr = formatNumber(stylizeNoColor, tempArg);
                /*
                } else if (typeof tempArg === 'bigint') {
                	tempStr = `${tempArg}n`;
                */
              } else {
                let constr;
                if (typeof tempArg !== 'object' || tempArg === null || typeof tempArg.toString === 'function' && (hasOwnProperty(tempArg, 'toString')
                // A direct own property on the constructor prototype in
                // case the constructor is not an built-in object.
                || (constr = tempArg.constructor) && !builtInObjects.has(constr.name) && constr.prototype && hasOwnProperty(constr.prototype, 'toString'))) {
                  tempStr = String(tempArg);
                } else {
                  tempStr = inspect(tempArg, {
                    ...inspectOptions,
                    compact: 3,
                    colors: false,
                    depth: 0
                  });
                }
              }
              break;
            case 106:
              // 'j'
              tempStr = tryStringify(args[++a]);
              break;
            case 100:
              // 'd'
              const tempNum = args[++a];
              /*
              if (typeof tempNum === 'bigint') {
              	tempStr = `${tempNum}n`;
              } else
              */
              if (typeof tempNum === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, Number(tempNum));
              }
              break;
            case 79:
              // 'O'
              tempStr = inspect(args[++a], inspectOptions);
              break;
            case 111:
              // 'o'
              {
                tempStr = inspect(args[++a], {
                  ...inspectOptions,
                  showHidden: true,
                  showProxy: true,
                  depth: 4
                });
                break;
              }
            case 105:
              // 'i'
              const tempInteger = args[++a];
              /*
              if (typeof tempInteger === 'bigint') {
              	tempStr = `${tempInteger}n`;
              } else */
              if (typeof tempInteger === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseInt(tempInteger));
              }
              break;
            case 102:
              // 'f'
              const tempFloat = args[++a];
              if (typeof tempFloat === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseFloat(tempFloat));
              }
              break;
            case 37:
              // '%'
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;
            default:
              // Any other character is not a correct placeholder
              continue;}

          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }
          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }
    if (lastPos !== 0) {
      a++;
      join = ' ';
      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }
  while (a < args.length) {
    const value = args[a];
    str += join;
    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;
    join = ' ';
    a++;
  }
  return str;
}
/* eslint-enable max-depth */

function noop$1() {}
function logTime(self, label, logData) {
  label = `${label}`;
  const startTime = self._times.get(label);
  if (!startTime) {
    process.emitWarning(`Label "${label}" does not exist`);
    return true;
  }
  const duration = Date.now() - startTime;
  if (logData) {
    self.log(`${label}: ${duration}ms`, ...logData);
  } else {
    self.log(`${label}: ${duration}ms`);
  }
  return false;
}
const kColorInspectOptions = {
  colors: true
};
const kNoColorInspectOptions = {};
let tableWarned; // boolean flag for one-time warning about console.table not being implemented

// Make a function that can serve as the callback passed to `stream.write()`.
function createWriteErrorHandler(stream) {
  return (err) => {
    // This conditional evaluates to true if and only if there was an error
    // that was not already emitted (which happens when the _write callback
    // is invoked asynchronously).
    if (err !== null && !stream._writableState.errorEmitted) {
      // If there was an error, it will be emitted on `stream` as
      // an `error` event. Adding a `once` listener will keep that error
      // from becoming an uncaught exception, but since the handler is
      // removed after the event, non-console.* writes won't be affected.
      // we are only adding noop if there is no one else listening for 'error'
      if (stream.listenerCount('error') === 0) {
        stream.once('error', noop$1);
      }
    }
  };
}
class Console {
  constructor(options, stderr, ignoreErrors) {
    if (options && options.apiName === 'Ti.API') {
      // Passing in Ti.API module where we retain log levels
      this._apiModule = options;
    } else {
      // Node.JS streams
      if (!options || typeof options.write === 'function') {
        // no args, or first arg is a stream
        options = {
          stdout: options,
          stderr,
          ignoreErrors
        };
      }
      this._stdout = options.stdout; // TODO: enforce has write function?
      this._stderr = options.stderr || this._stdout;
      this._ignoreErrors = options.ignoreErrors !== false;
      if (this._ignoreErrors) {
        this._stdoutErrorHandler = createWriteErrorHandler(this._stdout);
        this._stderrErrorHandler = createWriteErrorHandler(this._stderr);
      }
      this._colorMode = options.colorMode || 'auto'; // TODO: enforce boolean or 'auto'
      this._inspectOptions = options.inspectOptions; // TODO: enforce undefined or typeof 'object'
    }

    this._times = new Map();
    this._counts = new Map();
    this._groupIndent = '';
  }
  _writeToConsole(level, string) {
    if (this._groupIndent.length !== 0) {
      if (string.includes('\n')) {
        string = string.replace(/\n/g, `\n${this._groupIndent}`);
      }
      string = this._groupIndent + string;
    }

    // Support wrapping Ti.API (which retains log level)
    if (this._apiModule) {
      this._apiModule[level](string);
    } else {
      // Support Node.JS streams like stdout/stderr which don't have log levels
      const useStdErr = level === 'warn' || level === 'error' || level === 'trace';
      const stream = useStdErr ? this._stderr : this._stdout;
      if (this._ignoreErrors === false) {
        return stream.write(string);
      }

      // There may be an error occurring synchronously (e.g. for files or TTYs
      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so
      // handle both situations.
      try {
        // Add and later remove a noop error handler to catch synchronous errors.
        if (stream.listenerCount('error') === 0) {
          stream.once('error', noop$1);
        }
        const errorHandler = useStdErr ? this._stderrErrorHandler : this._stdoutErrorHandler;
        stream.write(string, errorHandler);
      } catch (e) {
        // Console is a debugging utility, so it swallowing errors is not desirable
        // even in edge cases such as low stack space.
        if (isStackOverflowError(e)) {
          throw e;
        }
        // Sorry, there's no proper way to pass along the error here.
      } finally {
        stream.removeListener && stream.removeListener('error', noop$1);
      }
    }
  }
  info(...args) {
    this._writeToConsole('info', formatWithOptions(kColorInspectOptions, ...args));
  }
  warn(...args) {
    this._writeToConsole('warn', formatWithOptions(kNoColorInspectOptions, ...args));
  }
  error(...args) {
    this._writeToConsole('error', formatWithOptions(kNoColorInspectOptions, ...args));
  }
  debug(...args) {
    this._writeToConsole('debug', formatWithOptions(kColorInspectOptions, ...args));
  }
  trace(...args) {
    this._writeToConsole('trace', formatWithOptions(kColorInspectOptions, ...args));
  }
  clear() {} // no-op

  group(...data) {
    if (data.length > 0) {
      this.log(...data);
    }
    this._groupIndent += '  ';
  }
  groupEnd() {
    this._groupIndent = this._groupIndent.slice(0, this._groupIndent.length - 2);
  }
  dir(obj, options) {
    this._writeToConsole('info', inspect(obj, {
      customInspect: false,
      ...options
    }));
  }
  assert(value, ...args) {
    if (!value) {
      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;
      this.warn(...args); // The arguments will be formatted in warn() again
    }
  }

  count(label = 'default') {
    // Ensures that label is a string, and only things that can be
    // coerced to strings. e.g. Symbol is not allowed
    label = `${label}`;
    let count = this._counts.get(label);
    if (count === undefined) {
      count = 1;
    } else {
      count++;
    }
    this._counts.set(label, count);
    this.log(`${label}: ${count}`);
  }
  countReset(label = 'default') {
    if (!this._counts.has(label)) {
      process.emitWarning(`Count for '${label}' does not exist`);
      return;
    }
    this._counts.delete(`${label}`);
  }
  time(label = 'default') {
    label = `${label}`;
    if (this._times.has(label)) {
      process.emitWarning(`Label ${label}" already exists`);
      return;
    }
    this._times.set(label, Date.now());
  }
  timeEnd(label = 'default') {
    const warned = logTime(this, label);
    if (!warned) {
      this._times.delete(label);
    }
  }
  timeLog(label = 'default', ...logData) {
    logTime(this, label, logData);
  }

  // TODO: implement console.table()
  table() {
    if (!tableWarned) {
      tableWarned = true;
      process.emitWarning('"console.table" is not yet implemented in Titanium!');
    }
  }
}
Console.prototype.log = Console.prototype.info; // Treat log as alias to info
Console.prototype.dirxml = Console.prototype.log; // Treat dirxml as alias to log
Console.prototype.groupCollapsed = Console.prototype.group;
const globalConsole = new Console(Ti.API);
globalConsole.Console = Console;
global.console = globalConsole;

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

{
  Date.prototype.toLocaleDateString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);
    const oldOptions = properties.options;
    if (!oldOptions || !oldOptions.dateStyle && !oldOptions.month && !oldOptions.day && !oldOptions.year) {
      const defaultOptions = {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric'
      };
      properties.options = Object.assign(defaultOptions, oldOptions);
    }
    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };
  Date.prototype.toLocaleTimeString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);
    const oldOptions = properties.options;
    if (!oldOptions || !oldOptions.timeStyle && !oldOptions.hour && !oldOptions.minute && !oldOptions.second) {
      const defaultOptions = {
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric'
      };
      properties.options = Object.assign(defaultOptions, oldOptions);
    }
    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };
  Date.prototype.toLocaleString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);
    const oldOptions = properties.options;
    let hasOption = false;
    if (oldOptions) {
      hasOption = !!oldOptions.dateStyle || !!oldOptions.timeStyle || !!oldOptions.weekday || !!oldOptions.month || !!oldOptions.day || !!oldOptions.year || !!oldOptions.hour || !!oldOptions.minute || !!oldOptions.second;
    }
    if (!hasOption) {
      const defaultOptions = {
        month: 'numeric',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric'
      };
      properties.options = Object.assign(defaultOptions, oldOptions);
    }
    const formatter = new Intl.DateTimeFormat(properties.locale, properties.options);
    return formatter.format(this);
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

// Add a toJSON() method to all Error objects needed to output non-enumerable properties.
// The JSON.stringify() will automatically call this method if it exists to provide custom output.
// Notes:
// - In V8, all Error properties are not enumerable. We need this or else stringify() will return "{}".
// - In JavaScriptCore, only the "stack" property is not enumerable. We want to reveal this.
if (typeof Error.prototype.toJSON !== 'function') {
  Error.prototype.toJSON = function () {
    var properties = {};
    Object.getOwnPropertyNames(this).forEach(function (name) {
      properties[name] = this[name];
    }, this);
    return properties;
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* globals OS_ANDROID */

/**
 * Generates a "creation" properties dictionary for Titanium's Collator, DateTimeFormat, and NumberFormat proxies
 * from the given Intl type's constructor arguments.
 * @param {Object[]} args
 * The arguments array that was passed into Intl Collator, DateTimeFormat, or NumberFormat type's constructor.
 * @param {Function} supportedFormatLocalesFunction Reference to a supportedLocalesOf() function.
 * @return {Object} Returns a properties dictionary to be passed into a Titanium proxy's constructor.
 */
function makeTiFormatCreationPropertiesFrom(args, supportedFormatLocalesFunction) {
  const properties = {};
  if (args.length >= 1) {
    if (typeof args[0] === 'string') {
      properties.locale = args[0];
    } else if (Array.isArray(args[0])) {
      const supportedLocales = supportedFormatLocalesFunction(args[0]);
      if (supportedLocales.length > 0) {
        properties.locale = supportedLocales[0];
      }
    }
  }
  if (args.length >= 2 && typeof args[1] === 'object') {
    properties.options = args[1];
  }
  return properties;
}

// Add "Intl" APIs missing on Android.
{
  // Set up an "Intl.Collator" type which wraps our undocumented "Ti.Locale.Collator" proxy.
  function TiCollator() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedCollatorLocales);
    const collator = new Ti.Locale.Collator(properties);
    collator.compare = collator.compare.bind(collator);
    return collator;
  }
  TiCollator.supportedLocalesOf = Ti.Locale.getSupportedCollatorLocales;

  // Set up an "Intl.DateTimeFormat" type which wraps our undocumented "Ti.Locale.DateTimeFormat" proxy.
  function TiDateTimeFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedDateTimeFormatLocales);
    return new Ti.Locale.DateTimeFormat(properties);
  }
  TiDateTimeFormat._makeTiCreationPropertiesFrom = (args) => {
    return makeTiFormatCreationPropertiesFrom(args, Ti.Locale.getSupportedDateTimeFormatLocales);
  };
  TiDateTimeFormat.supportedLocalesOf = Ti.Locale.getSupportedDateTimeFormatLocales;

  // Set up an "Intl.NumberFormat" type which wraps our undocumented "Ti.Locale.NumberFormat" proxy.
  function TiNumberFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedNumberFormatLocales);
    return new Ti.Locale.NumberFormat(properties);
  }
  TiNumberFormat.supportedLocalesOf = Ti.Locale.getSupportedNumberFormatLocales;

  // Make our custom "Intl" module available globally.
  commonjsGlobal.Intl = {
    Collator: TiCollator,
    DateTimeFormat: TiDateTimeFormat,
    NumberFormat: TiNumberFormat,
    getCanonicalLocales: Ti.Locale.getCanonicalLocales
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

{
  Number.prototype.toLocaleString = function () {
    const formatter = new Intl.NumberFormat(...arguments);
    return formatter.format(this.valueOf());
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

{
  String.prototype.localeCompare = function (compareString, locales, options) {
    const collator = new Intl.Collator(locales, options);
    return collator.compare(this, compareString);
  };
  String.prototype.toLocaleLowerCase = function (locale) {
    return Ti.Locale.makeLowerCase(this, locale);
  };
  String.prototype.toLocaleUpperCase = function (locale) {
    return Ti.Locale.makeUpperCase(this, locale);
  };
}

/**
 * This file is used to hijack the standard require to allow for JS
 * implementations of "core" modules.
 *
 * You add a binding from the "core" module id to the under the hood JS
 * implementation. We then intercept require calls to handle requests for these modules
 * and lazily load the file.
 */

/**
 * Used by @function bindObjectToCoreModuleId
 * @type {map<string, object>}
 */
const bindings = new Map();

/**
 * Used by @function redirectCoreModuleIdToPath
 * @type {map<string, string>}
 */
const redirects = new Map();

/**
 * Does the request look like a typical core module? (no '.' or '/' characters)
 * @param {string} path original require path/id
 * @returns {boolean}
 */
function isHijackableModuleId(path) {
  if (!path || path.length < 1) {
    return false;
  }
  const firstChar = path.charAt(0);
  return firstChar !== '.' && firstChar !== '/';
}

// Hack require to point to this as core module "binding". (Note that iOS does not have a global require.)
const originalRequire = global.require ? global.require : require.main.require.bind(require.main);
// This works for Windows as-is, and also intercepts the call on Android/iOS for ti.main.js (the first file executed)
global.require = function (moduleId) {
  if (bindings.has(moduleId)) {
    return bindings.get(moduleId);
  }
  if (redirects.has(moduleId)) {
    moduleId = redirects.get(moduleId);
  }
  return originalRequire(moduleId);
};

// ... but we still need to hack it when requiring from other files for Android/iOS (due to module.js impl)
const originalModuleRequire = global.Module.prototype.require;
global.Module.prototype.require = function (path, context) {
  if (bindings.has(path)) {
    return bindings.get(path);
  }
  if (redirects.has(path)) {
    path = redirects.get(path);
  }
  return originalModuleRequire.call(this, path, context);
};

/**
 * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {*} binding an already constructured value/object to return
 */
function register(moduleId, binding) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }
  if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    redirects.delete(moduleId);
  } else if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }
  bindings.set(moduleId, binding);
}

/**
 * Registers a binding from a short module id to the full under the hood filepath if given a string.
 * This allows for lazy instantiation of the module on-demand
 *
 * @param {string} moduleId the module id to "hijack"
 * @param {string} filepath the full filepath to require under the hood.
 *                              This should be an already resolved absolute path,
 *                              as otherwise the context of the call could change what gets loaded!
 */
function redirect(moduleId, filepath) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }
  if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    bindings.delete(moduleId);
  } else if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }
  redirects.set(moduleId, filepath);
}

// FIXME: There's a collision here with global.binding declared in KrollBridge.m on iOS
if (!global.binding) {
  global.binding = {};
}
global.binding.register = register;
global.binding.redirect = redirect;

// Load all JavaScript extensions/polyfills
register('console', globalConsole);

/* globals OS_ANDROID */
{
  // Avoid circular references in JSON structure
  Object.defineProperty(Titanium.Activity.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};
      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];
        if (k === 'window' || k === 'intent' || k.charAt(0) === '_') {
          continue;
        }
        serialized[k] = this[k];
      }
      return serialized;
    },
    enumerable: false
  });
}

/* globals OS_ANDROID */
{
  const Properties = Titanium.App.Properties;
  function nullOrDefaultValue(defaultValue) {
    if (typeof defaultValue === 'undefined') {
      return null;
    }
    return defaultValue;
  }
  function propertyGetter(delegate) {
    return function (key, defaultValue) {
      if (!Properties.hasProperty(key)) {
        return nullOrDefaultValue(defaultValue);
      }
      return delegate.call(Properties, key);
    };
  }
  ['getBool', 'getDouble', 'getInt', 'getString'].forEach(function (getter) {
    Properties[getter] = propertyGetter(Properties[getter]);
  });
  Properties.getList = Properties.getObject = function (key, defaultValue) {
    if (!Properties.hasProperty(key)) {
      return nullOrDefaultValue(defaultValue);
    }
    return JSON.parse(Properties.getString(key));
  };
  Properties.setList = Properties.setObject = function (key, val) {
    Properties.setString(key, JSON.stringify(val));
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID, OS_IOS, OS_VERSION_MAJOR */
const buffer = Ti.createBuffer({
  value: ''
});
const blob = buffer.toBlob();
const BlobPrototype = Object.getPrototypeOf(blob);
{
  // This doesn't "stick" for iOS. It is implemented natively.
  // Web Blob has an arrayBuffer() method that returns a Promise
  // https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer
  Object.defineProperty(BlobPrototype, 'arrayBuffer', {
    value: function () {
      return new Promise((resolve, reject) => {
        let buf;
        try {
          buf = this.toArrayBuffer();
        } catch (err) {
          return reject(err);
        }
        resolve(buf);
      });
    },
    enumerable: true
  });
}

/* globals OS_ANDROID */
{
  const Locale = Titanium.Locale;
  const wrappedGetString = Locale.getString;
  Locale.getString = function (key, defaultValue) {
    const defaultValueType = typeof defaultValue;
    // If the hint/default is not a string, ignore it!
    if (defaultValueType !== 'string') {
      return wrappedGetString.call(Locale, key);
    }
    return wrappedGetString.call(Locale, key, defaultValue);
  };
  commonjsGlobal.L = Locale.getString;
}

// Keeps an object alive until dispose() is called.
// This is currently used to keep "top level" objects
// (ex: windows, tab groups) alive until their lifecycle ends.
function PersistentHandle(object) {
  this.cell = PersistentHandle.lastId++;
  PersistentHandle.objects[this.cell] = object;
}

// Objects retained by persistent handles.
// Each element in this array acts as a storage "cell"
// keeping the object reachable and alive until it is removed.
PersistentHandle.objects = {};
PersistentHandle.lastId = 0;
PersistentHandle.prototype.dispose = function () {
  if (this.cell === -1) {
    // This handle has already been disposed.
    return;
  }
  delete PersistentHandle.objects[this.cell];
  this.cell = -1;
};

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
{
  const HTTPClient = Titanium.Network.HTTPClient;
  const _send = HTTPClient.prototype.send;
  HTTPClient.prototype.send = function (options) {
    // Retain the httpclient until the request has been finished.
    const handle = new PersistentHandle(this);
    this.on('disposehandle', function () {
      handle.dispose();
      if (kroll.DBG) {
        kroll.log('HTTPClient', 'The persistent handle is disposed.');
      }
    });
    _send.call(this, options);
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

{
  function iPhoneConstant(name) {
    Titanium.API.error('!!!');
    Titanium.API.error('!!! WARNING : Use of unsupported constant Ti.UI.iPhone.' + name + ' !!!');
    Titanium.API.error('!!!');
    return 0;
  }

  // TODO: Remove me. Only for temporary compatibility
  Titanium.UI.iPhone = {
    ActivityIndicatorStyle: {
      get BIG() {
        return iPhoneConstant('ActivityIndicatorStyle.BIG');
      },
      get DARK() {
        return iPhoneConstant('ActivityIndicatorStyle.DARK');
      }
    },
    AnimationStyle: {
      get FLIP_FROM_LEFT() {
        return iPhoneConstant('AnimationStyle.FLIP_FROM_LEFT');
      }
    },
    ProgressBarStyle: {
      get SIMPLE() {
        return iPhoneConstant('ProgressBarStyle.SIMPLE');
      }
    },
    SystemButton: {
      get FLEXIBLE_SPACE() {
        return iPhoneConstant('SystemButton.FLEXIBLE_SPACE');
      },
      get DISCLOSURE() {
        return iPhoneConstant('SystemButton.DISCLOSURE');
      }
    },
    SystemButtonStyle: {
      get BAR() {
        return iPhoneConstant('SystemButtonStyle.BAR');
      }
    },
    TableViewCellSelectionStyle: {
      get NONE() {
        return iPhoneConstant('TableViewCellSelectionStyle.NONE');
      }
    },
    TableViewSeparatorStyle: {
      get NONE() {
        return iPhoneConstant('TableViewSeparatorStyle.NONE');
      }
    },
    RowAnimationStyle: {
      get NONE() {
        return iPhoneConstant('RowAnimationStyle.NONE');
      }
    },
    TableViewScrollPosition: {
      get MIDDLE() {
        return iPhoneConstant('TableViewScrollPosition.MIDDLE');
      }
    },
    TableViewStyle: {
      get GROUPED() {
        return iPhoneConstant('TableViewStyle.GROUPED');
      }
    }
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

/* global OS_ANDROID */

{
  const ListView = Titanium.UI.ListView;
  const defaultTemplate = {
    properties: {
      height: '45dp'
    },
    childTemplates: [{
      type: 'Ti.UI.Label',
      bindId: 'title',
      properties: {
        left: '6dp',
        width: '75%'
      }
    }, {
      type: 'Ti.UI.ImageView',
      bindId: 'image',
      properties: {
        right: '25dp',
        width: '15%'
      }
    }]
  };
  function createListView(options) {
    if (!options) {
      options = {};
    }
    options.templates = {
      [Titanium.UI.LIST_ITEM_TEMPLATE_DEFAULT]: defaultTemplate,
      ...options.templates
    };
    const templates = options.templates;
    for (const binding in templates) {
      const currentTemplate = templates[binding];
      processTemplate(currentTemplate);
      processChildTemplates(currentTemplate);
    }
    return new ListView(options);
  }

  // Create ListItemProxy, add events, then store it in 'tiProxy' property
  function processTemplate(properties) {
    const cellProxy = Titanium.UI.createListItem();
    const events = properties.events;
    properties.tiProxy = cellProxy;
    addEventListeners(events, cellProxy);
  }

  // Recursive function that process childTemplates and append corresponding proxies to
  // property 'tiProxy'. I.e: type: "Titanium.UI.Label" -> tiProxy: LabelProxy object
  function processChildTemplates(properties) {
    if (!Object.prototype.hasOwnProperty.call(properties, 'childTemplates')) {
      return;
    }
    const childProperties = properties.childTemplates;
    if (!childProperties) {
      return;
    }
    for (let i = 0; i < childProperties.length; i++) {
      const child = childProperties[i];
      const proxyType = child.type;
      if (proxyType) {
        const creationProperties = child.properties;
        const creationFunction = lookup(proxyType);

        // Create proxy.
        let childProxy;
        if (creationProperties) {
          childProxy = creationFunction(creationProperties);
        } else {
          childProxy = creationFunction();
        }
        // Add event listeners.
        const events = child.events;
        addEventListeners(events, childProxy);

        // Append proxy to tiProxy property.
        child.tiProxy = childProxy;
      }
      processChildTemplates(child);
    }
  }

  // Add event listeners.
  function addEventListeners(events, proxy) {
    if (events !== undefined) {
      for (const eventName in events) {
        proxy.addEventListener(eventName, events[eventName]);
      }
    }
  }
  function lookupProxyConstructor(namespace) {
    const namespaceIndex = namespace.lastIndexOf('.');
    const proxyName = namespace.slice(namespaceIndex + 1);
    const parentNamespace = namespace.substring(0, namespaceIndex);
    const segments = parentNamespace.split('.');
    let parentProxy = commonjsGlobal;
    for (let i = 0; i < segments.length; i++) {
      parentProxy = parentProxy[segments[i]];
    }
    if (parentProxy) {
      const method = parentProxy[`create${proxyName}`];
      if (method) {
        return method;
      }
    }
    throw new Error(`Could not lookup constructor for namespace: "${namespace}"`);
  }

  // Convert name of UI elements into a constructor function.
  // i.e: lookup("Titanium.UI.Label") returns Titanium.UI.createLabel function.
  function lookup(namespace) {
    // Handle Titanium widgets.
    if (/^(Ti|Titanium)/.test(namespace)) {
      return lookupProxyConstructor(namespace);

      // Handle Alloy widgets.
    } else {
      let widget;
      try {
        // Attempt to load alloy widget.
        widget = commonjsGlobal.Module.main.require(`/alloy/widgets/${namespace}/controllers/widget`);
      } catch (e) {
        try {
          // Widget does not exist, attempt to load namespace.
          widget = commonjsGlobal.Module.main.require(namespace);
        } catch (err) {
          // Namespace does not exist, fall back to legacy behaviour.
          return lookupProxyConstructor(namespace);
        }
      }
      if (widget) {
        return function (parameters) {
          const obj = new widget(parameters);
          return obj.getView();
        };
      }
    }
  }

  // Overwrite list view constructor function with our own.
  Titanium.UI.createListView = createListView;
}

/* globals OS_ANDROID */
{
  // Avoid circular references in JSON structure
  Object.defineProperty(Titanium.UI.NavigationWindow.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};
      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];
        if (k === 'parent' || k === 'window' || k.charAt(0) === '_') {
          continue;
        }
        serialized[k] = this[k];
      }
      return serialized;
    },
    enumerable: false
  });
}

/**
 * This script is used at runtime for Ti.UI.fetchSemanticColor - as well as at build time by both iOS/Android.
 * It provides a common interface for handling colors and converting to necessary string forms.
 */
const HEX_3_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F3
const HEX_4_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F38
const HEX_6_REGEX = /^#?([a-f\d]){6}$/i; // i.e. #00FF33
const HEX_8_REGEX = /^#?([a-f\d]){8}$/i; // i.e. #00FF3388

/**
 * @param {number} integer in range of 0-255
 * @returns {string} 2-character hex string value
 */
function paddedHex(integer) {
  const str = integer.toString(16);
  if (str.length === 1) {
    return `0${str}`;
  }
  return str;
}
class Color {
  /**
   * @param {number} r red value in range 0-255
   * @param {number} g green value in range 0-255
   * @param {number} b blue value in range 0-255
   * @param {number} [a=1.0] alpha value in range 0.0-1.0
   */
  constructor(r, g, b, a = 1.0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.alpha = a;
  }

  /**
   * indicates if this is a fully opaque color (alpha is 1.0 or was undefined)
   * @returns {boolean}
   */
  isOpaque() {
    return this.alpha === 1.0;
  }

  /**
   * Converts the alpha value into equivalent hex string value properly.
   * @returns {string}
   */
  alphaHex() {
    // need to round to avoid nonsensical values like '7f.8' for a 0.5 alpha
    return paddedHex(Math.round(this.alpha * 255.0));
  }

  /**
   * Discards any alpha value. To be used internally, not external api. Does not provide leading '#' symbol.
   * @returns {string}
   */
  _toRGBHexString() {
    return `${paddedHex(this.r)}${paddedHex(this.g)}${paddedHex(this.b)}`;
  }

  /**
   * Used by CSS.
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0)
   * @returns {string}
   */
  toRGBAHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }
    return `#${this._toRGBHexString()}${this.alphaHex()}`;
  }

  /**
   * Used by Android/iOS
   * Converts this color to a hex string with leading '#' symbol and 6- or 8-
   * hexadecimal characters (depending on if alpha is 1.0). Alpha is the first entry (if there is alpha.)
   * @returns {string}
   */
  toARGBHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }
    return `#${this.alphaHex()}${this._toRGBHexString()}`;
  }

  /**
   * For commonality with native iOS TiColor proxy. Produces an AARRGGBB (or RRGGBB if full alpha) hex string
   * @returns {string}
   */
  toHex() {
    return this.toARGBHexString();
  }

  /**
   * Converts this color to an rgba expression. This expression is more consistent across platforms.
   * (whereas iOS/Android differ in expectations for hex strings.)
   * @returns {string}
   */
  toRGBAString() {
    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.alpha.toFixed(3)})`;
  }

  /**
   * @returns {Color}
   */
  static fallback() {
    return new Color(0, 0, 0); // return black to match native impl in iOS
  }

  /**
   * The supplied hex string MUST be in form '#000000' (i.e. leading pound symbol, 6 hex characters after)
   * @param {string} hex hexadecimal color string
   * @param {number} [alpha] alpha value
   * @returns {Color}
   */
  static fromHex6String(hex, alpha) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const r = parseInt(hex.substr(startIndex, 2), 16);
    const g = parseInt(hex.substr(startIndex + 2, 2), 16);
    const b = parseInt(hex.substr(startIndex + 4, 2), 16);
    return new Color(r, g, b, alpha);
  }

  /**
   * The supplied hex string MUST be in form '#00000000' (i.e. leading pound symbol, 8 hex characters after)
   * @param {string} hex hexadecimal color string
   * @returns {Color}
   */
  static fromHex8String(hex) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const alpha = parseInt(hex.substr(startIndex, 2), 16); // alpha is now 0-255
    const r = parseInt(hex.substr(startIndex + 2, 2), 16);
    const g = parseInt(hex.substr(startIndex + 4, 2), 16);
    const b = parseInt(hex.substr(startIndex + 6, 2), 16);
    return new Color(r, g, b, alpha / 255.0); // convert to 0.0-1.0 (percent)
  }

  /**
   * Note that the hex value can contain alpha, but must follow the CSS standard of #RRGGBBAA (NOT the Android standard of #AARRGGBB)
   * @param {string|object} entry possible hex string or an object
   * @param {string|number} [hex.alpha] alpha value in percent (0.0-100.0) when hex is an object
  	 * @param {string} [hex.color] hex string for the base color when hex is an object
   * @returns {Color}
   * @throws if entry has both an explicit alpha value AND a hex string containing an alpha value
   */
  static fromSemanticColorsEntry(entry) {
    let color = entry;
    let alpha = 1.0;
    let hadAlpha = false;
    if (Object.prototype.hasOwnProperty.call(entry, 'alpha')) {
      alpha = parseFloat(entry.alpha) / 100.0; // convert from 0-100 range to 0-1 range
      hadAlpha = true;
      color = entry.color; // if it has an alpha property assume it has a color property too!
    }

    // expand the shorter hex string forms to 6 or 8 digits
    if (color.length === 3) {
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      color = color.replace(HEX_3_REGEX, (m, r, g, b) => r + r + g + g + b + b);
    } else if (color.length === 4) {
      // Expand shorthand form (e.g. "03F8") to full form (e.g. "0033FF88")
      color = color.replace(HEX_4_REGEX, (m, a, r, g, b) => a + a + r + r + g + g + b + b);
    }
    if (HEX_6_REGEX.exec(color)) {
      return Color.fromHex6String(color, alpha);
    }
    if (HEX_8_REGEX.exec(color)) {
      if (hadAlpha) {
        throw new Error(`Color ${entry} had an explicit alpha value AND a hex value containing alpha. Use one or the other.`);
      }
      return Color.fromHex8String(color);
    }
    // uh-oh, something is up!
    return Color.fallback();
  }
}
var color = Color;

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */

// As Android passes a new instance of Ti.UI to every JS file we can't just
// Ti.UI within this file, we must call kroll.binding to get the Titanium
// namespace that is passed in with require and that deal with the .UI
// namespace that is on that directly.
const UI = kroll.binding('Titanium').Titanium.UI;

// Make our read-only constants
// TODO: Remove in SDK 10, DEPRECATED in 9.1.0
Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_LIGHT', {
  value: 'light',
  writable: false
});
Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_DARK', {
  value: 'dark',
  writable: false
});
Object.defineProperty(UI, 'semanticColorType', {
  get: () => {
    // TODO: Guard against ios < 13 and Android api < 29?
    // Assume "light" mode unless we explicitly know it's dark
    if (Ti.UI.userInterfaceStyle === Ti.UI.USER_INTERFACE_STYLE_DARK) {
      return UI.SEMANTIC_COLOR_TYPE_DARK;
    }
    return UI.SEMANTIC_COLOR_TYPE_LIGHT;
  }
});

// on Android/iOS < 13, we need to roll our own fetchSemanticColor impl
// on iOS 13+, we have a native version
{
  let colorset;
  UI.fetchSemanticColor = function fetchSemanticColor(colorName) {
    // Load all semantic colors from JSON if not done already.
    // Do so via require() in case this file was changed while running LiveView.
    if (!colorset) {
      const colorsetFileName = 'semantic.colors.json';
      try {
        const colorsetFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, colorsetFileName);
        if (colorsetFile.exists()) {
          // eslint-disable-next-line security/detect-non-literal-require
          colorset = require(`/${colorsetFileName}`);
        }
      } catch (error) {
        console.error(`Failed to load colors file '${colorsetFileName}'`);
        return color.fallback().toHex();
      }
    }
    try {
      if (true) {
        // On Android, use custom string references to be handled by "TiColorHelper.java".
        if (colorset[colorName]) {
          // Add all theme colors to a single string.
          // Example: "ti.semantic.color:dark=<ColorString>;light=<ColorString>"
          const colorArray = [];
          for (const colorType in colorset[colorName]) {
            const colorObj = color.fromSemanticColorsEntry(colorset[colorName][colorType]);
            colorArray.push(`${colorType}=${colorObj.toRGBAString()}`);
          }
          return 'ti.semantic.color:' + colorArray.join(';');
        } else if (Ti.Android.R.color[colorName]) {
          // We're referencing a native "res" color entry.
          return `@color/${colorName}`;
        }
      }
    } catch (error) {
      console.error(`Failed to lookup color for ${colorName}`);
    }
    return color.fallback().toHex();
  };
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID, OS_IOS */
{
  const Tab = Titanium.UI.Tab;
  function createTab(options) {
    const tab = new Tab(options);
    if (options) {
      tab._window = options.window;
    }
    return tab;
  }
  Titanium.UI.createTab = createTab;
  Tab.prototype.open = function (window, options) {
    if (!window) {
      return;
    }
    if (!options) {
      options = {};
    }

    // When we open a window using tab.open(win), we treat it as
    // opening a HW window on top of the tab.
    options.tabOpen = true;
    window.open(options);
  };
  Tab.prototype.close = function (options) {
    const window = this.getWindow();
    if (window) {
      window.close(options);
      this.setWindow(null);
    }
  };
  const _setWindow = Tab.prototype.setWindow;
  Tab.prototype.setWindow = function (window) {
    this._window = window;
    _setWindow.call(this, window);
  };

  // TODO: Remove! This is an undocumented accessor method
  Tab.prototype.getWindow = function () {
    return this._window;
  };
  Object.defineProperty(Tab.prototype, 'window', {
    enumerable: true,
    set: Tab.prototype.setWindow,
    get: Tab.prototype.getWindow
  });
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

{
  const TabGroup = Titanium.UI.TabGroup;

  // Avoid circular loops in toJSON()
  Object.defineProperty(TabGroup.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};
      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];
        if (k === 'activity' || k.charAt(0) === '_') {
          continue;
        }
        serialized[k] = this[k];
      }
      return serialized;
    },
    enumerable: false
  });
  Object.defineProperty(Titanium.UI.Tab.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};
      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];
        if (k === 'window' || k === 'tabGroup' || k.charAt(0) === '_') {
          continue;
        }
        serialized[k] = this[k];
      }
      return serialized;
    },
    enumerable: false
  });
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
/* globals OS_ANDROID */

{
  const View = Titanium.UI.View;
  const _add = View.prototype.add;
  View.prototype.add = function (child) {
    if (child instanceof Titanium.TiWindow) {
      throw new Error('Cannot add window/tabGroup to a view.');
    }
    this._children = this._children || [];
    _add.call(this, child);
    // The children have to be retained by the view in the Javascript side
    // in order to let V8 know the relationship between children and the view.
    // Therefore, as long as its window is open, all its children won't be detached
    // or garbage collected and V8 will recoganize the closures and retain all
    // the related proxies.
    this._children.push(child);
  };
  const _remove = View.prototype.remove;
  View.prototype.remove = function (child) {
    _remove.call(this, child);

    // Remove the child in the Javascript side so it can be detached and garbage collected.
    const children = this._children || [];
    const childIndex = children.indexOf(child);
    if (childIndex !== -1) {
      children.splice(childIndex, 1);
    }
  };

  // Do not serialize the parent view. Doing so will result
  // in a circular reference loop.
  Object.defineProperty(Titanium.TiView.prototype, 'toJSON', {
    value: function () {
      const keys = Object.keys(this);
      const keyCount = keys.length;
      const serialized = {};
      for (let i = 0; i < keyCount; i++) {
        const k = keys[i];
        if (k === 'parent' || k.charAt(0) === '_') {
          continue;
        }
        serialized[k] = this[k];
      }
      return serialized;
    },
    enumerable: false
  });
}

/* globals OS_ANDROID */
{
  const createWebView = Titanium.UI.createWebView;
  function createWebViewWrapper(...args) {
    const webView = createWebView.apply(this, args);
    webView.onCreateWindow = function (e) {
      if (!e.isUserGesture) {
        return null;
      }
      const win = Titanium.UI.createWindow({}, {
        fullscreen: false // Force new activity.
      });

      const newWebView = Titanium.UI.createWebView();
      win.add(newWebView);
      win.open();
      return newWebView;
    };
    return webView;
  }
  Titanium.UI.createWebView = createWebViewWrapper;
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
{
  const TAG = 'Window';
  const Script = kroll.binding('evals').Script; // Android-specific way to grab binding, hangs off 'script' on iOS
  const Window = Titanium.UI.Window;
  Window.prototype._cachedActivityProxy = null;
  function createWindow(options) {
    const window = new Window(options);
    window._children = [];
    return window;
  }
  Titanium.UI.createWindow = createWindow;

  // Activity getter (account for scenario when heavy weight window's activity is not created yet)
  function activityProxyGetter() {
    const activityProxy = this._getWindowActivityProxy();
    if (activityProxy) {
      return activityProxy;
    }
    if (this._cachedActivityProxy == null) {
      // eslint-disable-line
      this._cachedActivityProxy = {};
    }
    return this._cachedActivityProxy;
  }
  Window.prototype.getActivity = activityProxyGetter;
  Object.defineProperty(Window.prototype, 'activity', {
    get: activityProxyGetter
  });
  const _open = Window.prototype.open;
  Window.prototype.open = function (options) {
    // Retain the window until it has closed.
    const handle = new PersistentHandle(this);
    const self = this;
    this.once('close', function (e) {
      if (e._closeFromActivityForcedToDestroy) {
        if (kroll.DBG) {
          kroll.log(TAG, 'Window is closed because the activity is forced to destroy by Android OS.');
        }
        return;
      }

      // Dispose the URL context if the window's activity is destroyed.
      if (self._urlContext) {
        Script.disposeContext(self._urlContext);
        self._urlContext = null;
      }
      handle.dispose();
      if (kroll.DBG) {
        kroll.log(TAG, 'Window is closed normally.');
      }
    });
    return _open.call(this, options);
  };
  const _add = Window.prototype.add;
  Window.prototype.add = function (child) {
    if (child instanceof Titanium.TiWindow) {
      throw new Error('Cannot add window/tabGroup to another window/tabGroup.');
    }
    _add.call(this, child);

    // The children have to be retained by the window in the Javascript side
    // in order to let V8 know the relationship between children and the window.
    // Therefore, as long as the window is open, all its children won't be detached
    // or garbage collected and V8 will recoganize the closures and retain all
    // the related proxies.
    this._children.push(child);
  };
  const _remove = Window.prototype.remove;
  Window.prototype.remove = function (child) {
    _remove.call(this, child);

    // Remove the child in the Javascript side so it can be detached and garbage collected.
    const children = this._children;
    if (children) {
      const childIndex = children.indexOf(child);
      if (childIndex !== -1) {
        children.splice(childIndex, 1);
      }
    }
  };
  Window.prototype.postWindowCreated = function () {
    if (kroll.DBG) {
      kroll.log(TAG, 'Checkpoint: postWindowCreated()');
    }
    if (this._cachedActivityProxy) {
      this._internalActivity.extend(this._cachedActivityProxy);
    }
  };
}

/**
 * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events
 * @param {string} eventName the name of the event to register for
 * @param {function} listener the listener callback/function to invoke when the event is emitted
 * @param {boolean} prepend whether to prepend or append the listener
 * @returns {EventEmitter}
 */
function _addListener(emitter, eventName, listener, prepend) {
  if (!emitter._eventsToListeners) {
    // no events/listeners registered
    emitter._eventsToListeners = {}; // initialize it
  }
  // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)
  if (emitter._eventsToListeners.newListener) {
    emitter.emit('newListener', eventName, listener);
  }
  const eventListeners = emitter._eventsToListeners[eventName] || [];
  if (prepend) {
    eventListeners.unshift(listener);
  } else {
    eventListeners.push(listener);
  }
  emitter._eventsToListeners[eventName] = eventListeners;

  // Check max listeners and spit out warning if >
  const max = emitter.getMaxListeners();
  const length = eventListeners.length;
  if (max > 0 && length > max) {
    const w = new Error(`Possible EventEmitter memory leak detected. ${length} ${eventName} listeners added. Use emitter.setMaxListeners() to increase limit`);
    w.name = 'MaxListenersExceededWarning';
    w.emitter = emitter;
    w.type = eventName;
    w.count = length;
    process.emitWarning(w);
  }
  return emitter;
}
function onceWrap(emitter, eventName, listener) {
  function wrapper(...args) {
    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves
    this.listener.apply(this.emitter, args); // then forward the event callback
  }
  // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter
  const wrapperThis = {
    emitter,
    eventName,
    listener
  };
  const bound = wrapper.bind(wrapperThis); // bind to force "this" to refer to our custom object tracking the wrapper/emitter/listener
  bound.listener = listener; // have to add listener property for "unwrapping"
  wrapperThis.wrappedFunc = bound;
  return bound;
}

// many consumers make use of this via util.inherits, which does not chain constructor calls!
// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it
class EventEmitter {
  constructor() {
    this._eventsToListeners = {};
    this._maxListeners = undefined;
  }
  addListener(eventName, listener) {
    return _addListener(this, eventName, listener, false);
  }
  on(eventName, listener) {
    return this.addListener(eventName, listener);
  }
  prependListener(eventName, listener) {
    return _addListener(this, eventName, listener, true);
  }
  once(eventName, listener) {
    this.on(eventName, onceWrap(this, eventName, listener));
  }
  prependOnceListener(eventName, listener) {
    this.prependListener(eventName, onceWrap(this, eventName, listener));
  }
  removeListener(eventName, listener) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return this;
    }
    const eventListeners = this._eventsToListeners[eventName] || [];
    const length = eventListeners.length;
    let foundIndex = -1;
    let unwrappedListener;
    // Need to search LIFO, and need to handle wrapped functions (once wrappers)
    for (let i = length - 1; i >= 0; i--) {
      if (eventListeners[i] === listener || eventListeners[i].listener === listener) {
        foundIndex = i;
        unwrappedListener = eventListeners[i].listener;
        break;
      }
    }
    if (foundIndex !== -1) {
      if (length === 1) {
        // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!
        delete this._eventsToListeners[eventName];
      } else {
        // we had 2+ listeners, so store array without this given listener
        eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]
      }
      // Don't emit if there's no listeners for 'removeListener' type!
      if (this._eventsToListeners.removeListener) {
        this.emit('removeListener', eventName, unwrappedListener || listener);
      }
    }
    return this;
  }
  off(eventName, listener) {
    return this.removeListener(eventName, listener);
  }
  emit(eventName, ...args) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return false;
    }
    const eventListeners = this._eventsToListeners[eventName] || [];
    for (const listener of eventListeners.slice()) {
      // must operate on copy because listeners ,ay get remove as side-effect of calling
      listener.call(this, ...args);
    }
    return eventListeners.length !== 0;
  }
  listenerCount(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return 0;
    }
    const eventListeners = this._eventsToListeners[eventName] || [];
    return eventListeners.length;
  }
  eventNames() {
    return Object.getOwnPropertyNames(this._eventsToListeners || {});
  }
  listeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }
    // Need to "unwrap" once wrappers!
    const raw = this._eventsToListeners[eventName] || [];
    return raw.map((l) => l.listener || l); // here we unwrap the once wrapper if there is one or fall back to listener function
  }

  rawListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }
    return (this._eventsToListeners[eventName] || []).slice(0); // return a copy
  }

  getMaxListeners() {
    return this._maxListeners || EventEmitter.defaultMaxListeners;
  }
  setMaxListeners(n) {
    this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)
    return this;
  }
  removeAllListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      this._eventsToListeners = {}; // initialize it
    }

    if (!this._eventsToListeners.removeListener) {
      // no need to emit! we can just wipe!
      if (eventName === undefined) {
        // remove every type!
        this._eventsToListeners = {};
      } else {
        // remove specific type
        delete this._eventsToListeners[eventName];
      }
      return this;
    }

    // yuck, we'll have to emit 'removeListener' events as we go
    if (eventName === undefined) {
      // Remove all types (but do 'removeListener' last!)
      const names = Object.keys(this._eventsToListeners).filter((name) => name !== 'removeListener');
      names.forEach((name) => this.removeAllListeners(name));
      this.removeAllListeners('removeListener');
      this._eventsToListeners = {};
    } else {
      // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)
      const listeners = this._eventsToListeners[eventName] || [];
      for (let i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(eventName, listeners[i]);
      }
    }
    return this;
  }
}
EventEmitter.defaultMaxListeners = 10;
EventEmitter.listenerCount = function (emitter, eventName) {
  return emitter.listenerCount(eventName);
};
EventEmitter.EventEmitter = EventEmitter;

/**
 * @param  {*} arg passed in argument value
 * @param  {string} name name of the argument
 * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)
 * @return {void}
 * @throws {TypeError}
 */
function assertArgumentType(arg, name, typename) {
  const type = typeof arg;
  if (type !== typename.toLowerCase()) {
    throw new TypeError(`The "${name}" argument must be of type ${typename}. Received type ${type}`);
  }
}

// Start our process uptime timer immediately!
const startTime = Date.now();

/**
 * This function 'standardizes' the reported architectures to the equivalents reported by Node.js
 * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.
 * iOS values: "arm64", "armv7", "x86_64", "i386", "Unknown"
 * Android values: "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64", "unknown"
 * Windows values: "x64", "ia64", "ARM", "x86", "unknown"
 * @param {string} original original architecture reported by Ti.Platform
 * @returns {string}
 */
function standardizeArch(original) {
  switch (original) {
    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'
    // 'armeabi' is a dead ABI for Android, removed in NDK r17
    case 'armv7':
    case 'armeabi':
    case 'armeabi-v7a':
    case 'ARM':
      return 'arm';

    // coerce 'arm64-v8a' -> 'arm64'
    case 'arm64-v8a':
      return 'arm64';

    // coerce 'i386', 'x86' -> 'ia32'
    case 'i386':
    case 'x86':
      return 'ia32';

    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'
    case 'x86_64':
    case 'ia64':
      return 'x64';

    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17
    case 'mips64':
      return 'mips';

    // coerce 'Unknown' -> 'unknown'
    case 'Unknown':
      return 'unknown';
    default:
      return original;}

}
const process$1 = new EventEmitter();
process$1.abort = () => {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here
process$1.arch = standardizeArch(Ti.Platform.architecture);
process$1.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?
Object.defineProperty(process$1, 'argv0', {
  value: '',
  // TODO: Path to .app on iOS?
  writable: false,
  enumerable: true,
  configurable: false
});
process$1.binding = () => {
  throw new Error('process.binding is unsupported and not user-facing API');
};
process$1.channel = undefined;
process$1.chdir = () => {
  throw new Error('process.chdir is unsupported');
};
process$1.config = {};
process$1.connected = false;
process$1.cpuUsage = () => {
  // FIXME: Can we look at OS.cpus to get this data?
  return {
    user: 0,
    system: 0
  };
};
process$1.cwd = () => __dirname;
Object.defineProperty(process$1, 'debugPort', {
  get: function () {
    let value = 0; // default to 0
    try {
      if ("android" === 'android') {
        const assets = kroll.binding('assets');
        const json = assets.readAsset('deploy.json');
        if (json) {
          const deployData = JSON.parse(json);
          if (deployData.debuggerPort !== -1) {
            // -1 means not set (not in debug mode)
            value = deployData.debuggerPort;
          }
        }
      }
    } catch (error) {

      // ignore
    } // overwrite this getter with static value
    Object.defineProperty(this, 'debugPort', {
      value: value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    return value;
  },
  enumerable: true,
  configurable: true
});
process$1.disconnect = () => {}; // no-op
process$1.dlopen = () => {
  throw new Error('process.dlopen is not supported');
};
process$1.emitWarning = function (warning, options, code, ctor) {
  // eslint-disable-line no-unused-vars
  let type;
  let detail;
  if (typeof options === 'string') {
    type = options;
  } else if (typeof options === 'object') {
    type = options.type;
    code = options.code;
    detail = options.detail;
  }
  if (typeof warning === 'string') {
    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8
    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);
    warning = new Error(warning);
    warning.name = type || 'Warning';
    if (code !== undefined) {
      warning.code = code;
    }
    if (detail !== undefined) {
      warning.detail = detail;
    }
  }
  // TODO: Throw TypeError if not an instanceof Error at this point!
  const isDeprecation = warning.name === 'DeprecationWarning';
  if (isDeprecation && process$1.noDeprecation) {
    return; // ignore
  }

  if (isDeprecation && process$1.throwDeprecation) {
    throw warning;
  }
  this.emit('warning', warning);
};
function loadEnvJson() {
  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');
    if (jsonFile.exists()) {
      return JSON.parse(jsonFile.read().text);
    }
  } catch (error) {
    Ti.API.error(`Failed to read "_env_.json". Reason: ${error.message}`);
  }
  return {};
}
Object.defineProperty(process$1, 'env', {
  get: function () {
    delete this.env;
    return this.env = loadEnvJson();
  },
  enumerable: true,
  configurable: true
});
process$1.execArgv = [];
process$1.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?
process$1.exit = () => {
  throw new Error('process.exit is not supported');
};
process$1.exitCode = undefined;
process$1.noDeprecation = false;
process$1.pid = 0;
// FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?
process$1.platform = "android";
process$1.ppid = 0;
// TODO: Add release property (Object)
// TODO: Can we expose stdout/stderr/stdin natively?
// Don't wrap console.log/error because technically global console wraps process.stdout/stderr (or should)
process$1.stderr = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.error(chunk);
    if (callback) {
      callback();
    }
    return true;
  }
};
process$1.stdout = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.info(chunk);
    if (callback) {
      callback();
    }
    return true;
  }
};
process$1.title = Ti.App.name;
process$1.throwDeprecation = false;
process$1.traceDeprecation = false;
process$1.umask = () => 0; // just always return 0
process$1.uptime = () => {
  const diffMs = Date.now() - startTime;
  return diffMs / 1000.0; // convert to "seconds" with fractions
};

process$1.version = "12.5.1";
process$1.versions = {
  modules: '',
  // TODO: Report module api version (for current platform!)
  v8: '',
  // TODO: report android's v8 version (if on Android!)
  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?
  // TODO: Report ios/Android/Windows platform versions?
};

process$1[Symbol.toStringTag] = 'process';
global.process = process$1;
// handle spitting out warnings
const WARNING_PREFIX = `(titanium:${process$1.pid}) `;
process$1.on('warning', (warning) => {
  const isDeprecation = warning.name === 'DeprecationWarning';
  // if we're not doing deprecations, ignore!
  if (isDeprecation && process$1.noDeprecation) {
    return;
  }
  // TODO: Check process.traceDeprecation and if set, include stack trace in message!
  let msg = WARNING_PREFIX;
  if (warning.code !== undefined) {
    msg += `[${warning.code}] `;
  }
  if (warning.toString) {
    msg += warning.toString();
  }
  if (warning.detail) {
    msg += `\n${warning.detail}`;
  }
  console.error(msg);
});
let uncaughtExceptionCallback = null;
process$1.hasUncaughtExceptionCaptureCallback = () => uncaughtExceptionCallback !== null;
process$1.setUncaughtExceptionCaptureCallback = (fn) => {
  if (fn === null) {
    uncaughtExceptionCallback = null;
    return;
  }
  assertArgumentType(fn, 'fn', 'function');
  if (uncaughtExceptionCallback !== null) {
    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');
  }
  uncaughtExceptionCallback = fn;
};
Ti.App.addEventListener('uncaughtException', function (event) {
  // Create an Error instance that wraps the data from the event
  // ideally we'd just forward along the original Error!
  const error = new Error(event.message);
  error.stack = event.backtrace;
  error.fileName = event.sourceName;
  error.lineNumber = event.line;
  error.columnNumber = event.lineOffset;
  if (process$1.hasUncaughtExceptionCaptureCallback()) {
    return uncaughtExceptionCallback(error);
  }
  // otherwise forward the event!
  process$1.emit('uncaughtException', error);
});

// Use a nice predictable class/structure for our Immediate/Tick "timers"
// JS engine should be able to optimize easier
class CallbackWithArgs {
  constructor(func, args) {
    this.func = func;
    this.args = args;
  }
  run() {
    if (this.args) {
      this.func.apply(null, this.args);
    } else {
      this.fun();
    }
  }
}
// nextTick vs setImmediate should be handled in a semi-smart way
// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)
// Then we should go through the "immediate" queue
// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/
const tickQueue = [];
const immediateQueue = [];
let drainingTickQueue = false;
let drainQueuesTimeout = null;

/**
 * Iteratively runs all "ticks" until there are no more.
 * This can cause infinite recursion if a tick schedules another forever.
 */
function drainTickQueue() {
  if (drainingTickQueue) {
    return;
  }
  drainingTickQueue = true;
  while (tickQueue.length) {
    const tick = tickQueue.shift();
    tick.run();
  }
  drainingTickQueue = false;
}
function drainQueues() {
  // drain the full tick queue first...
  drainTickQueue();
  // tick queue should be empty!
  const immediatesRemaining = processImmediateQueue();
  if (immediatesRemaining !== 0) {
    // re-schedule draining our queues, as we have at least one more "immediate" to handle
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  } else {
    drainQueuesTimeout = null;
  }
}

/**
 * Attempts to process "immediates" (in a much more leisurely way than ticks)
 * We give a 100ms window to run them in before re-scheduling the timeout to process them again.
 * If any ticks are added during invocation of immediate, we drain the tick queue fully before
 * proceeding to next immediate (if we still have time in our window).
 * @returns {number} number of remaining immediates to be processed
 */
function processImmediateQueue() {
  const immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates
  while (immediateQueue.length && Date.now() < immediateDeadline) {
    const immediate = immediateQueue.shift();
    immediate.run();
    if (tickQueue.length > 0) {
      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)
      drainTickQueue();
    }
  }
  return immediateQueue.length;
}
process$1.nextTick = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  tickQueue.push(new CallbackWithArgs(callback, args));
  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
};
global.setImmediate = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  const immediate = new CallbackWithArgs(callback, args);
  immediateQueue.push(immediate);
  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
  return immediate;
};
global.clearImmediate = function (immediate) {
  const index = immediateQueue.indexOf(immediate);
  if (index !== -1) {
    immediateQueue.splice(index, 1);
  }
};

const FORWARD_SLASH = 47; // '/'
const BACKWARD_SLASH = 92; // '\\'

/**
 * Is this [a-zA-Z]?
 * @param  {number}  charCode value from String.charCodeAt()
 * @return {Boolean}          [description]
 */
function isWindowsDeviceName(charCode) {
  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
}

/**
 * [isAbsolute description]
 * @param  {boolean} isPosix whether this impl is for POSIX or not
 * @param  {string} filepath   input file path
 * @return {Boolean}          [description]
 */
function isAbsolute(isPosix, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length;
  // empty string special case
  if (length === 0) {
    return false;
  }
  const firstChar = filepath.charCodeAt(0);
  if (firstChar === FORWARD_SLASH) {
    return true;
  }
  // we already did our checks for posix
  if (isPosix) {
    return false;
  }
  // win32 from here on out
  if (firstChar === BACKWARD_SLASH) {
    return true;
  }
  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {
    const thirdChar = filepath.charAt(2);
    return thirdChar === '/' || thirdChar === '\\';
  }
  return false;
}

/**
 * [dirname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */
function dirname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length;
  if (length === 0) {
    return '.';
  }

  // ignore trailing separator
  let fromIndex = length - 1;
  const hadTrailing = filepath.endsWith(separator);
  if (hadTrailing) {
    fromIndex--;
  }
  const foundIndex = filepath.lastIndexOf(separator, fromIndex);
  // no separators
  if (foundIndex === -1) {
    // handle special case of root windows paths
    if (length >= 2 && separator === '\\' && filepath.charAt(1) === ':') {
      const firstChar = filepath.charCodeAt(0);
      if (isWindowsDeviceName(firstChar)) {
        return filepath; // it's a root windows path
      }
    }

    return '.';
  }
  // only found root separator
  if (foundIndex === 0) {
    return separator; // if it was '/', return that
  }
  // Handle special case of '//something'
  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {
    return '//';
  }
  return filepath.slice(0, foundIndex);
}

/**
 * [extname description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @return {string}            [description]
 */
function extname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const index = filepath.lastIndexOf('.');
  if (index === -1 || index === 0) {
    return '';
  }
  // ignore trailing separator
  let endIndex = filepath.length;
  if (filepath.endsWith(separator)) {
    endIndex--;
  }
  return filepath.slice(index, endIndex);
}
function lastIndexWin32Separator(filepath, index) {
  for (let i = index; i >= 0; i--) {
    const char = filepath.charCodeAt(i);
    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {
      return i;
    }
  }
  return -1;
}

/**
 * [basename description]
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath   input file path
 * @param  {string} [ext]      file extension to drop if it exists
 * @return {string}            [description]
 */
function basename(separator, filepath, ext) {
  assertArgumentType(filepath, 'path', 'string');
  if (ext !== undefined) {
    assertArgumentType(ext, 'ext', 'string');
  }
  const length = filepath.length;
  if (length === 0) {
    return '';
  }
  const isPosix = separator === '/';
  let endIndex = length;
  // drop trailing separator (if there is one)
  const lastCharCode = filepath.charCodeAt(length - 1);
  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {
    endIndex--;
  }

  // Find last occurence of separator
  let lastIndex = -1;
  if (isPosix) {
    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);
  } else {
    // On win32, handle *either* separator!
    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1);
    // handle special case of root path like 'C:' or 'C:\\'
    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {
      return '';
    }
  }

  // Take from last occurrence of separator to end of string (or beginning to end if not found)
  const base = filepath.slice(lastIndex + 1, endIndex);

  // drop trailing extension (if specified)
  if (ext === undefined) {
    return base;
  }
  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;
}

/**
 * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.
 *
 * When multiple, sequential path segment separation characters are found (e.g.
 * / on POSIX and either \ or / on Windows), they are replaced by a single
 * instance of the platform-specific path segment separator (/ on POSIX and \
 * on Windows). Trailing separators are preserved.
 *
 * If the path is a zero-length string, '.' is returned, representing the
 * current working directory.
 *
 * @param  {string} separator  platform-specific file separator
 * @param  {string} filepath  input file path
 * @return {string} [description]
 */
function normalize(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  if (filepath.length === 0) {
    return '.';
  }

  // Windows can handle '/' or '\\' and both should be turned into separator
  const isWindows = separator === '\\';
  if (isWindows) {
    filepath = filepath.replace(/\//g, separator);
  }
  const hadLeading = filepath.startsWith(separator);
  // On Windows, need to handle UNC paths (\\host-name\\resource\\dir) special to retain leading double backslash
  const isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\';
  const hadTrailing = filepath.endsWith(separator);
  const parts = filepath.split(separator);
  const result = [];
  for (const segment of parts) {
    if (segment.length !== 0 && segment !== '.') {
      if (segment === '..') {
        result.pop(); // FIXME: What if this goes above root? Should we throw an error?
      } else {
        result.push(segment);
      }
    }
  }
  let normalized = hadLeading ? separator : '';
  normalized += result.join(separator);
  if (hadTrailing) {
    normalized += separator;
  }
  if (isUNC) {
    normalized = '\\' + normalized;
  }
  return normalized;
}

/**
 * [assertSegment description]
 * @param  {*} segment [description]
 * @return {void}         [description]
 */
function assertSegment(segment) {
  if (typeof segment !== 'string') {
    throw new TypeError(`Path must be a string. Received ${segment}`);
  }
}

/**
 * The `path.join()` method joins all given path segments together using the
 * platform-specific separator as a delimiter, then normalizes the resulting path.
 * Zero-length path segments are ignored. If the joined path string is a zero-
 * length string then '.' will be returned, representing the current working directory.
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       The joined filepath
 */
function join(separator, paths) {
  const result = [];
  // naive impl: just join all the paths with separator
  for (const segment of paths) {
    assertSegment(segment);
    if (segment.length !== 0) {
      result.push(segment);
    }
  }
  return normalize(separator, result.join(separator));
}

/**
 * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string[]} paths [description]
 * @return {string}       [description]
 */
function resolve(separator, paths) {
  let resolved = '';
  let hitRoot = false;
  const isPosix = separator === '/';
  // go from right to left until we hit absolute path/root
  for (let i = paths.length - 1; i >= 0; i--) {
    const segment = paths[i];
    assertSegment(segment);
    if (segment.length === 0) {
      continue; // skip empty
    }

    resolved = segment + separator + resolved; // prepend new segment
    if (isAbsolute(isPosix, segment)) {
      // have we backed into an absolute path?
      hitRoot = true;
      break;
    }
  }
  // if we didn't hit root, prepend cwd
  if (!hitRoot) {
    resolved = (global.process ? process.cwd() : '/') + separator + resolved;
  }
  const normalized = normalize(separator, resolved);
  if (normalized.charAt(normalized.length - 1) === separator) {
    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\host-name\\resource\\'
    // Don't remove trailing separator if this is root path on windows!
    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {
      return normalized;
    }
    // otherwise trim trailing separator
    return normalized.slice(0, normalized.length - 1);
  }
  return normalized;
}

/**
 * The `path.relative()` method returns the relative path `from` from to `to` based
 * on the current working directory. If from and to each resolve to the same
 * path (after calling `path.resolve()` on each), a zero-length string is returned.
 *
 * If a zero-length string is passed as `from` or `to`, the current working directory
 * will be used instead of the zero-length strings.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {string} from [description]
 * @param  {string} to   [description]
 * @return {string}      [description]
 */
function relative(separator, from, to) {
  assertArgumentType(from, 'from', 'string');
  assertArgumentType(to, 'to', 'string');
  if (from === to) {
    return '';
  }
  from = resolve(separator, [from]);
  to = resolve(separator, [to]);
  if (from === to) {
    return '';
  }

  // we now have two absolute paths,
  // lets "go up" from `from` until we reach common base dir of `to`
  // const originalFrom = from;
  let upCount = 0;
  let remainingPath = '';
  while (true) {
    if (to.startsWith(from)) {
      // match! record rest...?
      remainingPath = to.slice(from.length);
      break;
    }
    // FIXME: Break/throw if we hit bad edge case of no common root!
    from = dirname(separator, from);
    upCount++;
  }
  // remove leading separator from remainingPath if there is any
  if (remainingPath.length > 0) {
    remainingPath = remainingPath.slice(1);
  }
  return ('..' + separator).repeat(upCount) + remainingPath;
}

/**
 * The `path.parse()` method returns an object whose properties represent
 * significant elements of the path. Trailing directory separators are ignored,
 * see `path.sep`.
 *
 * The returned object will have the following properties:
 *
 * - dir <string>
 * - root <string>
 * - base <string>
 * - name <string>
 * - ext <string>
 * @param  {string} separator platform-specific file separator
 * @param  {string} filepath [description]
 * @return {object}
 */
function parse(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const result = {
    root: '',
    dir: '',
    base: '',
    ext: '',
    name: ''
  };
  const length = filepath.length;
  if (length === 0) {
    return result;
  }

  // Cheat and just call our other methods for dirname/basename/extname?
  result.base = basename(separator, filepath);
  result.ext = extname(separator, result.base);
  const baseLength = result.base.length;
  result.name = result.base.slice(0, baseLength - result.ext.length);
  const toSubtract = baseLength === 0 ? 0 : baseLength + 1;
  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!
  const firstCharCode = filepath.charCodeAt(0);
  // both win32 and POSIX return '/' root
  if (firstCharCode === FORWARD_SLASH) {
    result.root = '/';
    return result;
  }
  // we're done with POSIX...
  if (separator === '/') {
    return result;
  }
  // for win32...
  if (firstCharCode === BACKWARD_SLASH) {
    // FIXME: Handle UNC paths like '\\\\host-name\\resource\\file_path'
    // need to retain '\\\\host-name\\resource\\' as root in that case!
    result.root = '\\';
    return result;
  }
  // check for C: style root
  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {
    if (length > 2) {
      // is it like C:\\?
      const thirdCharCode = filepath.charCodeAt(2);
      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {
        result.root = filepath.slice(0, 3);
        return result;
      }
    }
    // nope, just C:, no trailing separator
    result.root = filepath.slice(0, 2);
  }
  return result;
}

/**
 * The `path.format()` method returns a path string from an object. This is the
 * opposite of `path.parse()`.
 *
 * @param  {string} separator platform-specific file separator
 * @param  {object} pathObject object of format returned by `path.parse()`
 * @param  {string} pathObject.dir directory name
 * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided
 * @param  {string} pathObject.base file basename
 * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists
 * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists
 * @return {string}
 */
function format(separator, pathObject) {
  assertArgumentType(pathObject, 'pathObject', 'object');
  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;

  // append base to root if `dir` wasn't specified, or if
  // dir is the root
  if (!pathObject.dir || pathObject.dir === pathObject.root) {
    return `${pathObject.root || ''}${base}`;
  }
  // combine dir + / + base
  return `${pathObject.dir}${separator}${base}`;
}

/**
 * On Windows systems only, returns an equivalent namespace-prefixed path for
 * the given path. If path is not a string, path will be returned without modifications.
 * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces
 * @param  {string} filepath [description]
 * @return {string}          [description]
 */
function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    return filepath;
  }
  if (filepath.length === 0) {
    return '';
  }
  const resolvedPath = resolve('\\', [filepath]);
  const length = resolvedPath.length;
  if (length < 2) {
    // need '\\\\' or 'C:' minimum
    return filepath;
  }
  const firstCharCode = resolvedPath.charCodeAt(0);
  // if start with '\\\\', prefix with UNC root, drop the slashes
  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\') {
    // return as-is if it's an aready long path ('\\\\?\\' or '\\\\.\\' prefix)
    if (length >= 3) {
      const thirdChar = resolvedPath.charAt(2);
      if (thirdChar === '?' || thirdChar === '.') {
        return filepath;
      }
    }
    return '\\\\?\\UNC\\' + resolvedPath.slice(2);
  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {
    return '\\\\?\\' + resolvedPath;
  }
  return filepath;
}
const Win32Path = {
  sep: '\\',
  delimiter: ';',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(false, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: toNamespacedPath
};
const PosixPath = {
  sep: '/',
  delimiter: ':',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(true, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format(this.sep, pathObject);
  },
  toNamespacedPath: function (filepath) {
    return filepath; // no-op
  }
};

const path = PosixPath;
path.win32 = Win32Path;
path.posix = PosixPath;

const PosixConstants = {
  UV_UDP_REUSEADDR: 4,
  dlopen: {},
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18
  },
  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12
  },
  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20
  }
};

// default implementations
const OS = {
  EOL: '\n',
  arch: () => process.arch,
  constants: PosixConstants,
  cpus: () => {
    const count = Ti.Platform.processorCount;
    const array = [];
    for (let i = 0; i < count; i++) {
      array.push({
        model: 'unknown',
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0
        }
      });
    }
    return array;
  },
  endianness: () => {
    // TODO: Cache the value!
    const result = Ti.Codec.getNativeByteOrder();
    if (result === Ti.Codec.LITTLE_ENDIAN) {
      return 'LE';
    }
    return 'BE';
  },
  freemem: () => Ti.Platform.availableMemory,
  getPriority: () => 0,
  // fake it
  homedir: () => Ti.Filesystem.applicationDataDirectory,
  // fake it
  hostname: () => Ti.Platform.address,
  // fake it
  loadavg: () => [0, 0, 0],
  // fake it
  networkInterfaces: () => {},
  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address
  platform: () => process.platform,
  release: () => Ti.Platform.version,
  setPriority: () => {},
  // no-op, fake it
  /**
   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.
   * @return {string} [description]
   */
  tmpdir: () => Ti.Filesystem.tempDirectory,
  /**
   * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.
   * @return {integer} [description]
   */
  totalmem: () => Ti.Platform.totalMemory,
  type: () => 'Unknown',
  // overridden per-platform at bottom
  /**
   * The `os.uptime()` method returns the system uptime in number of seconds.
   * @return {integer} [description]
   */
  uptime: () => Ti.Platform.uptime,
  userInfo: () => {
    // fake it!
    return {
      uid: -1,
      gid: -1,
      username: Ti.Platform.username,
      homedir: Ti.Filesystem.applicationDataDirectory,
      shell: null
    };
  }
};

// On specific platforms, override implementations because we don't have them
// yet and need to fake it, or to hack them
// I'm also doing this in blocks to assign implementations that don't need to consult platform
// type at runtime (hopefully speeding up execution at runtime)
{
  OS.cpus = () => Ti.Platform.cpus();
  OS.type = () => 'Linux';
}

const tty = {
  isatty: () => false,
  ReadStream: () => {
    throw new Error('tty.ReadStream is not implemented');
  },
  WriteStream: () => {
    throw new Error('tty.WriteStream is not implemented');
  }
};

const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const util = {
  format: format$1,
  formatWithOptions,
  inspect,
  isArray: Array.isArray,
  isBoolean: (value) => typeof value === 'boolean',
  isBuffer: BufferModule.Buffer.isBuffer,
  isFunction: (value) => typeof value === 'function',
  isNull: (value) => value === null,
  isNullOrUndefined: (value) => value === undefined || value === null,
  isNumber: (value) => typeof value === 'number',
  isObject: (value) => value !== null && typeof value === 'object',
  isPrimitive: (value) => typeof value !== 'object' && typeof value !== 'function' || value === null,
  isString: (value) => typeof value === 'string',
  isSymbol: (value) => typeof value === 'symbol',
  isUndefined: (value) => value === undefined,
  isRegExp: isRegExp,
  isDate: isDate,
  isError: (e) => Object.prototype.toString.call(e) === '[object Error]' || e instanceof Error,
  log: (string) => {
    const date = new Date();
    const time = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
    // Produces output like: "21 Feb 10:04:23 - message"
    console.log(`${date.getDate()} ${MONTHS[date.getMonth()]} ${time} - ${string}`);
  },
  print: (...args) => console.log(args.join('')),
  // FIXME: Shouldn't add trailing newline like console.log does!
  puts: (...args) => console.log(args.join('\n')),
  error: (...args) => console.error(args.join('\n')),
  debug: (string) => console.error(`DEBUG: ${string}`),
  types
};

/**
 * @param {Function} constructor subclass
 * @param {Function} superConstructor base class
 * @returns {void}
 */
util.inherits = function (constructor, superConstructor) {
  assertArgumentType(constructor, 'constructor', 'Function');
  assertArgumentType(superConstructor, 'superConstructor', 'Function');
  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');
  Object.defineProperty(constructor, 'super_', {
    value: superConstructor
  });
  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);
};

/**
 * @param {Function} original original function to wrap which is expected to have a final callback argument
 * @returns {Function} function that returns a Promise
 */
util.promisify = function (original) {
  assertArgumentType(original, 'original', 'Function');
  function wrapped(...args) {
    return new Promise((resolve, reject) => {
      original.call(this, ...args, (err, result) => {
        if (err) {
          return reject(err);
        }
        return resolve(result);
      });
    });
  }
  // TODO: Copy properties from original to wrapped
  // TODO: hook prototype chain up from wrapped to original
  // TODO: Support custom promisify hooks
  return wrapped;
};

/**
 * @param {Function} original original function to convert from async/Promise return value to a callback style
 * @returns {Function} wrapped function
 */
util.callbackify = function (original) {
  assertArgumentType(original, 'original', 'Function');
  function wrapped(...args) {
    const callback = args.pop();
    const promise = original.apply(this, args);
    promise.then((result) => {
      // eslint-disable-line promise/always-return
      callback(null, result); // eslint-disable-line promise/no-callback-in-promise
    }).catch((err) => {
      if (!err) {
        const wrappedError = new Error('Promise was rejected with falsy value');
        wrappedError.reason = err;
        err = wrappedError;
      }
      callback(err); // eslint-disable-line promise/no-callback-in-promise
    });
  }

  return wrapped;
};

/**
 * @param {Function} func function to deprecate/wrap
 * @param {string} string message to give when deprecation warning is emitted
 * @param {string} code deprecation code to use to group warnings
 * @returns {Function} wrapped function
 */
util.deprecate = function (func, string, code) {
  // eslint-disable-line no-unused-vars
  if (process.noDeprecation) {
    return func; // skip the wrapping!
  }
  // TODO: Support `code` argument by tracking a map of codes we've warned about
  function wrapped(...args) {
    let warned = false;
    if (!warned) {
      process.emitWarning(string, 'DeprecationWarning');
      warned = true;
    }
    return func.apply(this, args);
  }
  return wrapped;
};
// TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?
const noop = () => {};
util.debuglog = () => {
  return noop;
};

const DEFAULT_MESSAGES = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:'
};

// Fake enums to use internally
const COMPARE_TYPE = {
  Object: 0,
  Map: 1,
  Set: 2
};
const STRICTNESS = {
  Strict: 0,
  Loose: 1
};
class AssertionError extends Error {
  constructor(options) {
    let {
      actual,
      expected,
      message,
      operator
    } = options;
    if (!message) {
      // FIXME: Generate the rest of the message with diff of actual/expected!
      message = `${DEFAULT_MESSAGES[operator]}\n\n`;
    }
    super(message);
    this.actual = actual;
    this.expected = expected;
    this.operator = operator;
    this.generatedMessage = !message;
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
  }
}

// TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class
// that class holds impls for shared methods, subclasses override specific
// comparisons used (Object.is vs ===)?

const assert = (value, message) => assert.ok(value, message);
assert.AssertionError = AssertionError;
assert.ok = (...args) => {
  const value = args[0];
  if (value) {
    return;
  }
  let message = args[1];
  let generatedMessage = false;

  // Check if value (1st arg) was not supplied!
  // Have to use ugly hack on args definition to do so
  if (args.length === 0) {
    message = 'No value argument passed to `assert.ok()`';
    generatedMessage = true;
  } else if (message == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this
    // It treates ok failing like `value == true` failing
    message = 'The expression evaluated to a falsy value:\n\n';
    generatedMessage = true;
  } else if (message instanceof Error) {
    throw message;
  }
  const err = new AssertionError({
    actual: value,
    expected: true,
    message,
    operator: '=='
  });
  err.generatedMessage = generatedMessage;
  throw err;
};
function throwError(obj) {
  // If message is an Error object, throw that instead!
  if (obj.message instanceof Error) {
    throw obj.message;
  }
  throw new AssertionError(obj);
}
assert.equal = (actual, expected, message) => {
  if (actual == expected) {
    // eslint-disable-line eqeqeq
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'equal'
  });
};
assert.strictEqual = (actual, expected, message) => {
  if (Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'strictEqual'
  });
};
assert.notEqual = (actual, expected, message) => {
  if (actual != expected) {
    // eslint-disable-line eqeqeq
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'notEqual'
  });
};
assert.notStrictEqual = (actual, expected, message) => {
  if (!Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }
  throwError({
    actual,
    expected,
    message,
    operator: 'notStrictEqual'
  });
};
const isPrimitive = (value) => {
  return typeof value !== 'object' && typeof value !== 'function' || value === null;
};

/**
 * @param {Map} actual map we are comparing
 * @param {Map} expected map we're comparing against
 * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */
function compareMaps(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()
  for (const [key, value] of actual) {
    if (typeof key === 'object' && key !== null) {
      // non-null object. We need to do our own checking, not use get()/has()
      looseChecks.add(key);
    } else {
      // handle "primitives"
      if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {
        // yay! a nice easy match - both key and value matched exactly - move on
        continue;
      }
      if (strictness === STRICTNESS.Strict) {
        // if we didn't match key/value perfectly in strict mode, fail right away
        return false;
      }

      // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again
      looseChecks.add(key);
    }
  }
  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  }

  // only go through the second Map once!
  for (const [expectedKey, expectedValue] of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {
      return false;
    }

    // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!
    let found = false;
    for (const key of looseChecks) {
      // if both key and value matches
      if (deepEqual(key, expectedKey, strictness, references) && deepEqual(actual.get(key), expectedValue, strictness, references)) {
        found = true;
        looseChecks.delete(key); // remove from our looseChecks Set since we already matched it
        break;
      }
    }
    // if not found, we failed to match
    if (!found) {
      return false;
    }
  }
  // did we leave un-matched keys? if so, fail
  return looseChecks.size === 0;
}

/**
 * @param {Set} actual map we are comparing
 * @param {Set} expected map we're comparing against
 * @param {strictness.Loose|strictness.Strict} strictness how to compare
 * @param {object} references memoized references to objects in the deepEqual hierarchy
 * @returns {boolean}
 */
function compareSets(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()
  for (const value of actual) {
    if (typeof value === 'object' && value !== null) {
      // non-null object. We need to do our own checking, not use has()
      looseChecks.add(value);
    } else if (!expected.has(value)) {
      // FIXME: has does "same-value-zero" check, which is like Object.is except for -0/+0 being considered equal
      // so may need to special case that here, that'd have to be in an else below (since has will return true here)

      if (strictness === STRICTNESS.Strict) {
        // failed "same-value" match for primitive in strict mode, so fail right away
        return false;
      }

      // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here
      // add to set of values to check more thoroughly
      looseChecks.add(value);
    }
  }
  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  }

  // Try to whittle down the loose checks set to be empty...
  // only go through the second Set once!
  for (const expectedValue of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {
      return false;
    }
    let found = false;
    for (const object of looseChecks) {
      if (deepEqual(object, expectedValue, strictness, references)) {
        found = true; // found a match!
        looseChecks.delete(object); // remove from our looseChecks Set since we matched it
        break;
      }
    }
    // if not found, we failed to match
    if (!found) {
      return false;
    }
  }

  // did we leave un-matched values? if so, fail
  return looseChecks.size === 0;
}

/**
 * @param {*} actual value we are comparing
 * @param {*} expected values we're comparing against
 * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do
 * @param {object} [references] optional object to keep track of circular references in the hierarchy
 * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth
 * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth
 * @param {number} [references.depth] The current depth of the hierarchy
 * @returns {boolean}
 */
function deepEqual(actual, expected, strictness, references) {
  // if primitives, compare using Object.is
  // This handles: null, undefined, number, string, boolean
  if (isPrimitive(actual) && isPrimitive(expected)) {
    if (strictness === STRICTNESS.Strict) {
      return Object.is(actual, expected);
    } else {
      return actual == expected; // eslint-disable-line eqeqeq
    }
  }

  // Now we have various objects/functions:
  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays
  // notably, this includes "boxed" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc

  // Type tags of objects should be the same
  const actualTag = Object.prototype.toString.call(actual);
  const expectedTag = Object.prototype.toString.call(expected);
  if (actualTag !== expectedTag) {
    return false;
  }

  // [[Prototype]] of objects are compared using the Strict Equality Comparison.
  if (strictness === STRICTNESS.Strict) {
    // don't check prototype when doing "loose"
    const actualPrototype = Object.getPrototypeOf(actual);
    const expectedPrototype = Object.getPrototypeOf(expected);
    if (actualPrototype !== expectedPrototype) {
      return false;
    }
  }
  let comparison = COMPARE_TYPE.Object;
  if (util.types.isRegExp(actual)) {
    // RegExp source and flags should match
    if (!util.types.isRegExp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {
      return false;
    }
    // continue on to check properties...
  } else if (util.types.isDate(actual)) {
    // Date's underlying time should match
    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {
      return false;
    }
    // continue on to check properties...
  } else if (actual instanceof Error) {
    // Error's name and message must match
    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {
      return false;
    }
    // continue on to check properties...
  } else if (Array.isArray(actual)) {
    // if array lengths differ, quick fail
    if (!Array.isArray(expected) || actual.length !== expected.length) {
      return false;
    }
    // continue on to check properties...
  } else if (util.types.isBoxedPrimitive(actual)) {
    if (!util.types.isBoxedPrimitive(expected)) {
      return false;
    }
    // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!
    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {
      return false;
    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {
      return false;
    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {
      return false;
      // FIXME: Uncomment when we support BigInt cross-platform!
      // } else if (util.types.isBigIntObject(actual)
      // 	&& (!util.types.isBigIntObject(expected)
      // 		|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {
      // 	return false;
    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {
      return false;
    }
    // continue on to check properties...
  } else if (util.types.isSet(actual)) {
    if (!util.types.isSet(expected) || actual.size !== expected.size) {
      return false;
    }
    comparison = COMPARE_TYPE.Set;
    // continue on to check properties...
  } else if (util.types.isMap(actual)) {
    if (!util.types.isMap(expected) || actual.size !== expected.size) {
      return false;
    }
    comparison = COMPARE_TYPE.Map;
    // continue on to check properties...
  }

  // Now iterate over properties and compare them!
  const actualKeys = Object.keys(actual); // for an array, this will return the indices that have values
  const expectedKeys = Object.keys(expected); // and it just magically works
  // Must have same number of properties
  if (actualKeys.length !== expectedKeys.length) {
    return false;
  }

  // Are they the same keys? If one is missing, then no, fail right away
  if (!actualKeys.every((key) => Object.prototype.hasOwnProperty.call(expected, key))) {
    return false;
  }

  // Don't check own symbols when doing "loose"
  if (strictness === STRICTNESS.Strict) {
    const actualSymbols = Object.getOwnPropertySymbols(actual);
    const expectedSymbols = Object.getOwnPropertySymbols(expected);

    // Must have same number of symbols
    if (actualSymbols.length !== expectedSymbols.length) {
      return false;
    }
    if (actualSymbols.length > 0) {
      // Have to filter them down to enumerable symbols!
      for (const key of actualSymbols) {
        const actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);
        const expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);
        if (actualIsEnumerable !== expectedIsEnumerable) {
          return false; // they differ on whetehr symbol is enumerable, fail!
        } else if (actualIsEnumerable) {
          // it's enumerable, add to keys to check
          actualKeys.push(key);
          expectedKeys.push(key);
        }
      }
    }
  }

  // Avoid circular references!
  // Record map from objects to depth in the hierarchy
  if (references === undefined) {
    references = {
      actual: new Map(),
      expected: new Map(),
      depth: 0
    };
  } else {
    // see if we've already recorded these objects.
    // if so, make sure they refer to same depth in object hierarchy
    const memoizedActual = references.actual.get(actual);
    if (memoizedActual !== undefined) {
      const memoizedExpected = references.expected.get(expected);
      if (memoizedExpected !== undefined) {
        return memoizedActual === memoizedExpected;
      }
    }
    references.depth++;
  }
  // store the object -> depth mapping
  references.actual.set(actual, references.depth);
  references.expected.set(expected, references.depth);

  // When comparing Maps/Sets, compare elements before custom properties
  let result = true;
  if (comparison === COMPARE_TYPE.Set) {
    result = compareSets(actual, expected, strictness, references);
  } else if (comparison === COMPARE_TYPE.Map) {
    result = compareMaps(actual, expected, strictness, references);
  }
  if (result) {
    // Now loop over keys and compare them to each other!
    for (const key of actualKeys) {
      if (!deepEqual(actual[key], expected[key], strictness, references)) {
        result = false;
        break;
      }
    }
  }
  // wipe the object to depth mapping for these objects now
  references.actual.delete(actual);
  references.expected.delete(expected);
  return result;
}
assert.deepStrictEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual'
    });
  }
};
assert.notDeepStrictEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual'
    });
  }
};
assert.deepEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepEqual'
    });
  }
};
assert.notDeepEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepEqual'
    });
  }
};
assert.fail = (message = 'Failed') => throwError({
  message
});
const NO_EXCEPTION = {};
function execute(fn) {
  assertArgumentType(fn, 'fn', 'Function');
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION;
}
function isPromiseLike(fn) {
  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';
}
async function executePromise(fn) {
  let promise;
  const fnType = typeof fn;
  if (fnType === 'function') {
    promise = fn();
    if (!isPromiseLike(promise)) {
      throw new TypeError(`Expected instanceof Promise to be returned from the "fn" function but got ${typeof promise}`);
    }
  } else {
    if (!isPromiseLike(fn)) {
      throw new TypeError(`The "fn" argument must be of type Function or Promise. Received type ${fnType}`);
    }
    promise = fn;
  }
  try {
    await promise;
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION;
}
assert.throws = (fn, error, message) => {
  const actual = execute(fn);
  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'throws'
    });
    return;
  }

  // They didn't specify how to validate, so just roll with it
  if (!error) {
    return;
  }
  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.rejects = async function (asyncFn, error, message) {
  const actual = await executePromise(asyncFn);
  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'rejects'
    });
    return;
  }

  // They didn't specify how to validate, so just roll with it
  if (!error) {
    return;
  }
  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert.doesNotThrow = (fn, error, message) => {
  const actual = execute(fn);
  // no Error, just return
  if (actual === NO_EXCEPTION) {
    return;
  }

  // They didn't specify how to validate, so just re-throw
  if (!error) {
    throw actual;
  }

  // If error matches expected, throw an AssertionError
  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}`
    });
    return;
  }
  // doesn't match, re-throw
  throw actual;
};
assert.doesNotReject = async function (fn, error, message) {
  const actual = await executePromise(fn);
  // no Error, just return
  if (actual === NO_EXCEPTION) {
    return;
  }

  // They didn't specify how to validate, so just re-throw
  if (!error) {
    throw actual;
  }

  // If error matches expected, throw an AssertionError
  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}`
    });
    return;
  }
  // doesn't match, re-throw
  throw actual;
};

/**
 * @param {Error} actual the actual Error generated by the wrapped function/block
 * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error
 * @param {string} [message] custom message to append
 * @returns {boolean} true if the Error matches the expected value/object
 */
function checkError(actual, expected, message) {
  // What we do here depends on what `expected` is:
  // function - call it to validate
  // object - test properties against actual
  // Regexp - test against actual.toString()
  // Error type - check type matches
  // Error instance - compare properties
  if (typeof expected === 'object') {
    if (util.types.isRegExp(expected)) {
      return expected.test(actual); // does the error match the RegExp expression? if so, pass
    }

    // Test properties (`expected` is either a generic Object or an Error instance)
    const keys = Object.keys(expected);
    // If we're testing against an instance of an Error, we need to hack in name/message properties.
    if (expected instanceof Error) {
      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error
    }

    for (const key of keys) {
      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {
        if (!message) {
          // generate a meaningful message! Cheat by treating like equality check of values
          // then steal the message it generated
          try {
            throwError({
              actual: actual[key],
              expected: expected[key],
              operator: 'deepStrictEqual'
            });
          } catch (err) {
            message = err.message;
          }
        }
        throwError({
          actual,
          expected,
          message,
          operator: 'throws'
        });
        return false;
      }
    }
    return true; // They all matched, pass!
  } else if (typeof expected === 'function') {
    // if `expected` is a "type" and actual is an instance of that type, then pass
    if (expected.prototype != null && actual instanceof expected) {
      // eslint-disable-line no-eq-null,eqeqeq
      return true;
    }

    // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail
    if (Object.prototype.isPrototypeOf.call(Error, expected)) {
      return false;
    }

    // ok, let's assume what's left is that `expected` was a validation function,
    // so call it with empty `this` and single argument of the actual error we received
    return expected.call({}, actual);
  }
  return false;
}
assert.ifError = (value) => {
  if (value === null || value === undefined) {
    return;
  }
  throwError({
    actual: value,
    expected: null,
    message: `ifError got unwanted exception: ${value}`,
    operator: 'ifError'
  });
};

// Create "strict" copy which overrides "loose" methods to call strict equivalents
assert.strict = (value, message) => assert.ok(value, message);
// "Copy" methods from assert to assert.strict!
Object.assign(assert.strict, assert);
// Override the "loose" methods to point to the strict ones
assert.strict.deepEqual = assert.deepStrictEqual;
assert.strict.notDeepEqual = assert.notDeepStrictEqual;
assert.strict.equal = assert.strictEqual;
assert.strict.notEqual = assert.notStrictEqual;
// hang strict off itself
assert.strict.strict = assert.strict;

/**
 * @param {string} [encoding='utf8'] The character encoding the `StringDecoder` will use.
 */
function StringDecoder(encoding = 'utf8') {
  this.encoding = encoding.toLowerCase();
  switch (this.encoding) {
    case 'utf8':
    case 'utf-8':
      this._impl = new Utf8StringDecoder();
      break;
    case 'ucs2':
    case 'ucs-2':
    case 'utf16-le':
    case 'utf16le':
      this._impl = new Utf16StringDecoder();
      break;
    case 'base64':
      this._impl = new Base64StringDecoder();
      break;
    default:
      this._impl = new StringDecoderImpl(this.encoding);
      break;}

}

/**
 * Returns any remaining input stored in the internal buffer as a string.
 * Bytes representing incomplete UTF-8 and UTF-16 characters will be replaced with substitution
 * characters appropriate for the character encoding.
 *
 * If the buffer argument is provided, one final call to stringDecoder.write() is performed before returning the remaining input.
 * @param {Buffer} [buffer] containing the bytes to decode.
 * @returns {string}
 */
StringDecoder.prototype.end = function end(buffer) {
  return this._impl.end(buffer);
};

/**
 * Returns a decoded string, ensuring that any incomplete multibyte characters at the end of the Buffer, or
 * TypedArray, or DataView are omitted from the returned string and stored in an internal buffer for the
 * next call to stringDecoder.write() or stringDecoder.end().
 * @param {Buffer|TypedArray|DataView} buffer containing the bytes to decode.
 * @returns {string}
 */
StringDecoder.prototype.write = function write(buffer) {
  if (typeof buffer === 'string') {
    return buffer;
  }
  // empty string for empty buffer
  if (buffer.length === 0) {
    return '';
  }
  return this._impl.write(buffer);
};

/**
 * This is the base class. We override parts of it for certain encodings. For ascii/hex/binary/latin1 the impl is super-easy
 */
class StringDecoderImpl {
  constructor(encoding = 'utf8') {
    this.encoding = encoding;
    this.byteCount = 0;
    this.charLength = 1;
  }

  // the actual underlying implementation!
  end(buffer) {
    if (buffer && buffer.length !== 0) {
      return this.write(buffer);
    }
    return '';
  }
  write(buffer) {
    if (buffer && buffer.length !== 0) {
      return buffer.toString(this.encoding); // single byte character encodings are a cinch
    }

    return ''; // no buffer, or empty
  }
}

// For multi-byte encodings, let's implement some base logic...
class MultiByteStringDecoderImpl extends StringDecoderImpl {
  constructor(encoding, bytesPerChar) {
    super(encoding);
    this.incomplete = Buffer.allocUnsafe(bytesPerChar); // temporary incomplete character buffer
  }

  /**
   * @typedef {Object} IncompleteCharObject
   * @property {integer} bytesNeeded bytes missing to complete the character
   * @property {integer} charLength bytes expected to complete the character
   * @property {integer} index location in the buffer where the character starts
   */

  /**
   * Given a Buffer, sees if we have an incomplete "character" at the end of it.
   * Returns info on that:
   * - bytesNeeded: 0-3, number of bytes still remaining
   * - charLength: expected number of bytes for the incomplete character
   * - index: index in the buffer where the incomplete character begins
   * @param {Buffer} _buffer Buffer we are checking to see if it has an incompelte "character" at the end
   */
  _checkIncompleteBytes(_buffer) {
    throw new Error('subclasses must override!');
  }
  _incompleteEnd() {
    throw new Error('subclasses must override!');
  }
  _incompleteBufferEmptied() {
    // typically we reset byte count back to 0 and character length to 1
    this.byteCount = 0;
    this.charLength = 1;
  }
  end(buffer) {
    let result = super.end(buffer);
    if (this.byteCount !== 0) {
      // we have incomplete characters!
      result += this._incompleteEnd();
    }
    this._incompleteBufferEmptied(); // reset our internals to "wipe" the incomplete buffer
    return result;
  }
  write(buffer) {
    // first let's see if we had some multi-byte character we didn't finish...
    let char = '';
    if (this.byteCount !== 0) {
      // we still needed some bytes to finish the character
      // How many bytes do we still need? charLength - bytes we received
      const left = this.charLength - this.byteCount; // need 4, have 1? then we have 3 "left"

      const bytesCopied = Math.min(left, buffer.length); // copy up to that many bytes
      // copy bytes from `buffer` to our incomplete buffer
      buffer.copy(this.incomplete, this.byteCount, 0, bytesCopied);
      this.byteCount += bytesCopied; // record how many more bytes we copied...

      if (bytesCopied < left) {
        // still need more bytes to complete!
        return '';
      }

      // we were able to complete, yay!
      // grab the character we completed
      char = this.incomplete.slice(0, this.charLength).toString(this.encoding);
      // reset our counters
      this._incompleteBufferEmptied();
      // do we have any bytes left in this buffer?
      if (bytesCopied === buffer.length) {
        return char; // if not, return the character we finished!
      }
      // we still have more bytes, so slice the buffer up
      buffer = buffer.slice(bytesCopied, buffer.length);
    }

    // check this buffer to see if it indicates we need more bytes?
    const incompleteCharData = this._checkIncompleteBytes(buffer);
    if (incompleteCharData.bytesNeeded === 0) {
      return char + buffer.toString(this.encoding); // no incomplete bytes, return any character we completed plus the buffer
    }

    // ok so the buffer holds an incomplete character at it's end
    this.charLength = incompleteCharData.charLength; // record how many bytes we need for the 'character'
    const incompleteCharIndex = incompleteCharData.index; // this is the index of the multibyte character that is incomplete

    // copy from index of incomplete character to end of buffer
    const bytesToCopy = buffer.length - incompleteCharIndex;
    buffer.copy(this.incomplete, 0, incompleteCharIndex, buffer.length);
    this.byteCount = bytesToCopy; // record how many bytes we actually copied

    if (bytesToCopy < buffer.length) {
      // buffer had bytes before the incomplete character
      // so smush any character we may have completed with any complete characters in the buffer
      return char + buffer.toString(this.encoding, 0, incompleteCharIndex);
    }
    return char; // any now-completed character that was previously incomplete, possibly empty
  }
}

class Utf8StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf8', 4);
  }
  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    // FIXME: In Node, they check the last character first!
    // And they rely on Buffer#toString() to handle injecting the '\ufffd' character for busted multi-byte sequences!
    // iOS apparently just returns undefined in that special case and
    // Android differs here because we don't work backwards from the last char
    // Can we cheat here and...
    // see https://github.com/nodejs/string_decoder/blob/master/lib/string_decoder.js#L173-L198
    // - if we see a multi-byte character start, validate the next characters are continuation chars
    // - if they're not replace the sequence with '\ufffd', treat like that multi-byte character was "completed"

    // Note that even if we do hack this, if there's some invalid multi-byte UTF-8 in the buffer that isn't at the last 3 bytes
    // then we're at the mercy of the JS engine/platform code for handling that
    // Here's someone's hack there: https://gist.github.com/oleganza/997155

    // if buffer.length >= 3, check 3rd to last byte
    if (length >= 3) {
      let charLength = checkCharLengthForUTF8(buffer[length - 3]);
      if (charLength === 4) {
        return {
          bytesNeeded: 1,
          // we have 3 last bytes, need 4th
          index: length - 3,
          charLength: 4
        };
      }
    }
    // if buffer.length >= 2, check 2nd to last byte
    if (length >= 2) {
      let charLength = checkCharLengthForUTF8(buffer[length - 2]);
      if (charLength >= 3) {
        return {
          bytesNeeded: charLength - 2,
          // we have 2 bytes of whatever we need
          index: length - 2,
          charLength
        };
      }
    }
    // if buffer.length >= 1, check last byte
    if (length >= 1) {
      let charLength = checkCharLengthForUTF8(buffer[length - 1]);
      if (charLength >= 2) {
        return {
          bytesNeeded: charLength - 1,
          // we have 1 byte of whatever we need
          index: length - 1,
          charLength
        };
      }
    }
    // base case, no bytes needed - ends on complete character
    return {
      bytesNeeded: 0,
      index: length - 1,
      charLength: 1
    };
  }
  _incompleteEnd() {
    return '\ufffd'; // we replace the missing character with a special utf8 char
  }
}

class Utf16StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf16le', 4);
  }
  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 2;
    // ok, we have a multiple of 2 bytes
    if (modulo === 0) {
      // is the last byte a leading/high surrogate?
      const byte = buffer[buffer.length - 1];
      if (byte >= 0xD8 && byte <= 0xDB) {
        return {
          bytesNeeded: 2,
          charLength: 4,
          index: length - 2
        };
      }

      // we're good, not a surrogate, so we have our needed 2 bytes
      return {
        bytesNeeded: 0,
        charLength: 2
      };
    }

    // ok we have 1 byte left over, assume we need 2 to form the character
    return {
      bytesNeeded: 1,
      index: length - 1,
      charLength: 2
    };
  }
  _incompleteEnd() {
    // Just write out the last N bytes, hopefully the engine can handle it for us?
    return this.incomplete.toString('utf16le', 0, this.byteCount);
  }
}
class Base64StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('base64', 3);
    this.charLength = 3; // always 3!
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 3;
    // base64 needs 3 bytes always, so if we have that many (or a multiple), we have a complete buffer
    if (modulo === 0) {
      return {
        bytesNeeded: 0,
        charLength: 3
      };
    }

    // ok we have 1 or 2 bytes left over
    return {
      bytesNeeded: 3 - modulo,
      // always need 3, so if we have 1 left over -> need 2
      index: length - modulo,
      charLength: 3 // always need 3
    };
  }

  _incompleteBufferEmptied() {
    this.byteCount = 0;
    this.charLength = 3; // always 3!
  }

  _incompleteEnd() {
    // Just write out the last N bytes, it should insert the '=' placeholders
    // it's not really 'missing'/'incomplete', just needs placeholder insertion
    return this.incomplete.toString('base64', 0, this.byteCount);
  }
}
function checkCharLengthForUTF8(byte) {
  // 11110XXX => 1110 => 0x1E
  if (byte >> 3 === 0x1E) {
    return 4;
  }

  // 1110XXXX => 1110 => 0x1E
  if (byte >> 4 === 0x0E) {
    return 3;
  }

  // 110XXXXX => 110 => 0x06
  if (byte >> 5 === 0x06) {
    return 2;
  }
  return 1;
}
var StringDecoder$1 = {
  StringDecoder
};

// Keep track of printing out one-time warning messages for unsupported operations/options/arguments
const printedWarnings = {};
function oneTimeWarning(key, msg) {
  if (!printedWarnings[key]) {
    console.warn(msg);
    printedWarnings[key] = true;
  }
}
/**
 * Prints a one-time warning message that we do not support the given API and performs an effective no-op
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @returns {Function} no-op function
 */
function unsupportedNoop(moduleName, name) {
  return () => {
    const fqn = `${moduleName}.${name}`;
    oneTimeWarning(fqn, `"${fqn}" is not supported yet on Titanium and uses a no-op fallback.`);
    return undefined;
  };
}

/**
 * @param {string} moduleName name of the module/object
 * @param {string} name name of the function.property we don't support
 * @param {Function} callback async callback we call in a quick setTimeout
 */
function asyncUnsupportedNoop(moduleName, name, callback) {
  callback = maybeCallback(callback); // enforce we have a valid callback
  unsupportedNoop(moduleName, name)();
  setTimeout(callback, 1);
}

// Used to choose the buffer/chunk size when pumping bytes during copies
const COPY_FILE_CHUNK_SIZE = 8092; // what should we use here?

// Keep track of integer -> FileStream mappings
const fileDescriptors = new Map();
let fileDescriptorCount = 4; // global counter used to report file descriptor integers

// Map file system access flags to Ti.Filesystem.MODE_* constants
const FLAGS_TO_TI_MODE = new Map();
FLAGS_TO_TI_MODE.set('a', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('a+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('as+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('r', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('r+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('rs+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('w', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('w+', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx+', Ti.Filesystem.MODE_WRITE);

// Common errors
const permissionDenied = (syscall, path) => makeError('EACCES', 'permission denied', -13, syscall, path);
const noSuchFile = (syscall, path) => makeError('ENOENT', 'no such file or directory', -2, syscall, path);
const fileAlreadyExists = (syscall, path) => makeError('EEXIST', 'file already exists', -17, syscall, path);
const notADirectory = (syscall, path) => makeError('ENOTDIR', 'not a directory', -20, syscall, path);
const directoryNotEmpty = (syscall, path) => makeError('ENOTEMPTY', 'directory not empty', -66, syscall, path);
const illegalOperationOnADirectory = (syscall, path) => makeError('EISDIR', 'illegal operation on a directory', -21, syscall, path);
const fs = {
  constants: {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1
  }
};
class Stats {
  constructor(path) {
    this._file = null;
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 0;
    this.uid = 0;
    this.gid = 0;
    this.rdev = 0;
    this.size = 0;
    this.blksize = 4096; // FIXME: https://stackoverflow.com/questions/1315311/what-is-the-block-size-of-the-iphone-filesystem
    this.blocks = 0;
    this.atimeMs = this.mtimeMs = this.ctimeMs = this.birthtimeMs = 0;
    this.atime = this.mtime = this.ctime = this.birthtime = new Date(0);
    if (path) {
      this._file = getTiFileFromPathLikeValue(path);

      // TODO: use lazy getters here?
      this.ctime = this.birthtime = this._file.createdAt();
      this.atime = this.mtime = this._file.modifiedAt();
      this.atimeMs = this.atime.getTime();
      this.birthtimeMs = this.birthtime.getTime();
      this.ctimeMs = this.ctime.getTime();
      this.mtimeMs = this.mtime.getTime();
      this.size = this._file.size;
      this.blocks = Math.ceil(this.size / this.blksize);
      // TODO: Can we fake out the mode based on the readonly/writable/executable properties?
    }
  }

  isFile() {
    return this._file.isFile();
  }
  isDirectory() {
    return this._file.isDirectory();
  }
  isBlockDevice() {
    return false;
  }
  isCharacterDevice() {
    return false;
  }
  isSymbolicLink() {
    return this._file.symbolicLink;
  }
  isFIFO() {
    return false;
  }
  isSocket() {
    return false;
  }
}
fs.Stats = Stats;
class ReadStream {}
fs.ReadStream = ReadStream;
class WriteStream {}
fs.WriteStream = WriteStream;

/**
 * @callback statsCallback
 * @param {Error} err - Error if one occurred
 * @param {fs.Stats} stats - file stats
 */

/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 * @param {function} callback async callback
 */
fs.access = function (path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.constants.F_OK;
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.accessSync(path, mode);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};

/**
 * @param {string|URL|Buffer} path file path
 * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
 */
fs.accessSync = function (path, mode = fs.constants.F_OK) {
  // F_OK is just whether file exists or not, no permissions check
  // R_OK is read check
  // W_OK is write check
  // X_OK is execute check (acts like F_OK on Windows)
  const fileHandle = getTiFileFromPathLikeValue(path);
  if (!fileHandle.exists()) {
    throw noSuchFile('access', path);
  }

  // TODO: We have no means of testing if a file is readable. It's assumed all files that exist under the app are?
  if (mode & fs.constants.W_OK && !fileHandle.writable) {
    throw permissionDenied('access', path);
  }
  if (mode & fs.constants.X_OK && !fileHandle.executable && fileHandle.isFile()) {
    throw permissionDenied('access', path);
  }
};

/**
 * Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 * @param {Function} callback function to call back with error if failed
 */
fs.appendFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a'
  });
  fs.writeFile(file, data, options, callback);
};

/**
 * Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
 * @param {string|Buffer|URL|FileStream} file filepath to file
 * @param {string|Buffer} data data to append to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding='utf8'] encoding to use
 * @param {integer} [options.mode=0o666] mode to create file, if not created
 * @param {string} [options.flag='a'] file system flag
 */
fs.appendFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a'
  });
  fs.writeFileSync(file, data, options);
  // TODO: Use Ti.Filesystem.File.append() instead?
};

fs.chmod = (path, mode, callback) => asyncUnsupportedNoop('fs', 'chmod', callback);
fs.chmodSync = unsupportedNoop('fs', 'chmodSync');
fs.chown = (path, uid, gid, callback) => asyncUnsupportedNoop('fs', 'chown', callback);
fs.chownSync = unsupportedNoop('fs', 'chownSync');

/**
 * Callback for functions that can only throw errors
 *
 * @callback errorCallback
 * @param {Error} [err] - Error thrown
 */

/**
 * @param {integer} fd file descriptor
 * @param {errorCallback} callback callback function
 */
fs.close = (fd, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.closeSync(fd);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};

/**
 * @param {integer} fd file descriptor
 */
fs.closeSync = (fd) => {
  const stream = streamForDescriptor(fd);
  stream.close();
};

// Rather than use a hack to wrap sync version in setTimeout, use actual async APIs!
/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 * @param {errorCallback} callback callback called at end of operation
 */
fs.copyFile = function (src, dest, flags, callback) {
  if (typeof flags === 'function') {
    callback = flags;
    flags = 0;
  }
  callback = maybeCallback(callback);

  // FIXME: I don't know why, but changing this to use Ti.Filesystem.openStream(mode, path) fails (at least on iOS)
  const srcFile = Ti.Filesystem.getFile(src);
  const srcStream = srcFile.open(Ti.Filesystem.MODE_READ);
  const destFile = Ti.Filesystem.getFile(dest);
  const destStream = destFile.open(Ti.Filesystem.MODE_WRITE);
  pipe(srcStream, destStream, callback);
};

/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 */
fs.copyFileSync = function (src, dest, flags = 0) {
  const srcFile = Ti.Filesystem.getFile(src);
  if (flags === fs.constants.COPYFILE_EXCL && fs.existsSync(dest)) {
    throw fileAlreadyExists('copyFile', dest);
  }
  if (!srcFile.copy(dest)) {
    throw new Error(`Unable to copy ${src} to ${dest}`); // FIXME: What error should we give?
  }
};

// TODO: fs.createReadStream(path, options)
// /**
//  * @param {string|Buffer|URL} path path like
//  * @param {string|object} [options] options, if a string, it's the encoding
//  * @param {string} [options.flags='r'] See support of file system flags.
//  * @param {string} [options.encoding=null] encoding
//  * @param {integer} [options.fd=null] file descriptor, if specified, `path` is ignored
//  * @param {integer} [options.mode=0o666] permissions to set if file is created
//  * @param {boolean} [options.autoClose=true] if false, file descriptor will not be closed; if true even on error it will be closed
//  * @param {integer} [options.start] start index of range of bytes to read from file
//  * @param {integer} [options.end=Infinity] end index of range of bytes to read from file
//  * @param {integer} [options.highWaterMark=64 * 1024]
//  * @returns {fs.ReadStream}
//  */
// fs.createReadStream = (path, options) => {
// 	options = mergeDefaultOptions(options, { flags: 'r', encoding: null, fd: null, mode: 0o666, autoClose: true, end: Infinity, highWaterMark: 64 * 1024 });

// 	// FIXME: If options.fd, use that in place of path!
// 	const tiFile = getTiFileFromPathLikeValue(path);
// };
// TODO: fs.createWriteStream(path, options)

/**
 * @callback existsCallback
 * @param {boolean} exists - whether path exists
 */

/**
 * @param {string} path path to check
 * @param {existsCallback} callback callback function
 * @returns {void}
 */
fs.exists = function (path, callback) {
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(fs.existsSync(path));
  }, 1);
};

/**
 * @param {string} path path to check
 * @returns {boolean} whether a file or directory exists at that path
 */
fs.existsSync = function (path) {
  try {
    fs.accessSync(path);
    return true;
  } catch (e) {
    return false;
  }
};
fs.fchmod = (fd, mode, callback) => asyncUnsupportedNoop('fs', 'fchmod', callback);
fs.fchmodSync = unsupportedNoop('fs', 'fchmodSync');
fs.fchown = (fd, uid, gid, callback) => asyncUnsupportedNoop('fs', 'fchown', callback);
fs.fchownSync = unsupportedNoop('fs', 'fchownSync');
fs.fdatasync = (fd, callback) => asyncUnsupportedNoop('fs', 'fdatasync', callback);
fs.fdatasyncSync = unsupportedNoop('fs', 'fdatasyncSync');

/**
 * @param {integer} fd file descriptor
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {function} callback async callback function
 */
fs.fstat = (fd, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    let stats;
    try {
      stats = fs.fstatSync(fd, options);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, stats);
  }, 1);
};
/**
 * @param {integer} fd file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats} stats for file descriptor
 */
fs.fstatSync = (fd, _options) => {
  const path = pathForFileDescriptor(fd);
  return fs.statSync(path);
};

// TODO: Add versions of these APIs:
// fs.fsync(fd, callback)
// fs.fsyncSync(fd)
// fs.ftruncate(fd[, len], callback)
// fs.ftruncateSync(fd[, len])
// fs.futimes(fd, atime, mtime, callback)
// fs.futimesSync(fd, atime, mtime)
// fs.lchmod(path, mode, callback)
// fs.lchmodSync(path, mode)
// fs.lchown(path, uid, gid, callback)
// fs.lchownSync(path, uid, gid)
// fs.link(existingPath, newPath, callback)
// fs.linkSync(existingPath, newPath)

// FIXME: If symbolic link we need to follow link to target to get stats! Our API doesn't support that!
fs.lstat = (path, options, callback) => fs.stat(path, options, callback);
fs.lstatSync = (path, options) => fs.statSync(path, options);

/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 * @param {errorCallback} callback async callback
 */
fs.mkdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      recursive: false,
      mode: 0o777
    };
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.mkdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null);
  }, 1);
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {string|object} [options] options
 * @param {boolean} [options.recursive=false] recursivley create dirs?
 * @param {integer} [options.mode=0o777] permissions
 */
fs.mkdirSync = (path, options) => {
  const tiFile = getTiFileFromPathLikeValue(path);
  if (typeof options === 'number') {
    options = {
      recursive: false,
      mode: options
    };
  } else {
    options = mergeDefaultOptions(options, {
      recursive: false,
      mode: 0o777
    });
  }
  if (!tiFile.createDirectory(options.recursive) && !options.recursive) {
    if (tiFile.exists()) {
      // already existed!
      throw fileAlreadyExists('mkdir', path);
    }
    // We failed, probably because we didn't ask for recursive and parent doesn't exist, so reproduce node's error
    throw noSuchFile('mkdir', path);
  }
};

/**
 * @callback tempDirCallback
 * @param {Error} err - Error if one occurred
 * @param {string} folder - generated folder name
 */

/**
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @param {tempDirCallback} callback async callback
 */
fs.mkdtemp = (prefix, options, callback) => {
  assertArgumentType(prefix, 'prefix', 'string');
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8'
  });

  // try to be all async
  const tryMkdtemp = () => {
    const generated = randomCharacters(6, options.encoding); // generate six random characters
    const path = `${prefix}${generated}`;
    fs.mkdir(path, 0o700, (err) => {
      if (err) {
        if (err.code === 'EEXIST') {
          // retry!
          setTimeout(tryMkdtemp, 1);
          return;
        }
        // bubble up error
        callback(err);
        return;
      }
      // succeeded! Hurray!
      callback(null, path);
    });
  };
  setTimeout(tryMkdtemp, 1);
};

/**
 * Creates a unique temporary directory.
 * @param {string} prefix directory name prefix
 * @param {string|object} [options] options
 * @param {string} [options.encoding='utf-8'] prefix encoding
 * @returns {string} path to created directory
 */
fs.mkdtempSync = (prefix, options) => {
  assertArgumentType(prefix, 'prefix', 'string');
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8'
  });
  let retryCount = 0;
  const MAX_RETRIES = 100;
  while (retryCount < MAX_RETRIES) {
    const generated = randomCharacters(6, options.encoding); // generate six random characters
    const path = `${prefix}${generated}`;
    try {
      fs.mkdirSync(path, 0o700); // don't try recursive
      return path;
    } catch (e) {
      if (e.code !== 'EEXIST') {
        throw e; // bubble up error
      }
      // name was not unique, so retry
      retryCount++;
    }
  }
  throw new Error(`Failed to create a unique directory name with prefix ${prefix}`);
};

/**
 * @callback fileDescriptorCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} fileDescriptor - generated file descriptor
 */

/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [mode=0o666] file mode to use when creating file
 * @param {fileDescriptorCallback} callback async callback
 */
fs.open = (path, flags, mode, callback) => {
  // flags and mode are optional, we need to handle if not supplied!
  if (typeof flags === 'function') {
    callback = flags;
    flags = 'r';
    mode = 0o666;
  } else if (typeof mode === 'function') {
    callback = mode;
    mode = 0o666;
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    let fileDescriptor;
    try {
      fileDescriptor = fs.openSync(path, flags, mode);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, fileDescriptor);
  }, 1);
};

/**
 * @param {string|Buffer|URL} path path to file
 * @param {string} [flags='r'] file system access flags
 * @param {integer} [_mode=0o666] file mode to use when creating file
 * @returns {integer}
 */
fs.openSync = (path, flags = 'r', _mode = 0o666) => {
  const tiFile = getTiFileFromPathLikeValue(path);
  if (!tiFile.exists()) {
    // TODO: Support creating file with specific mode
    oneTimeWarning('fs.openSync.mode', 'fs.openSync\'s mode parameter is unsupported in Titanium and will be ignored');
    if (!tiFile.createFile()) {
      // Oh crap, we failed to create the file. why?
      if (!tiFile.parent.exists()) {
        // parent does not exist!
        throw noSuchFile('open', path);
      }
      throw new Error(`failed to create file at path ${path}`);
    }
  } else if (flags) {
    // file/dir exists...
    if ((flags.charAt(0) === 'w' || flags.charAt(0) === 'a') && tiFile.isDirectory()) {
      // If user is trying to write or append and it's a directory, fail
      throw illegalOperationOnADirectory('open', path);
    }
    if (flags.length > 1 && flags.charAt(1) === 'x') {
      // If user has "exclusive" flag on, fail if file already exists
      throw fileAlreadyExists('open', path);
    }
  }
  const tiMode = FLAGS_TO_TI_MODE.get(flags);
  if (tiMode === undefined) {
    // TODO: Make use of common error type/code for this once we have internal/errors.js
    const err = new TypeError(`The value "${String(flags)}" is invalid for option "flags"`);
    err.code = 'ERR_INVALID_OPT_VALUE';
    throw err;
  }
  return createFileDescriptor(path, tiFile.open(tiMode));
};

/**
 * @callback readCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} bytesRead - number of bytes read
 * @param {Buffer} buffer buffer
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} position where to begin reading from in the file
 * @param {readCallback} callback async callback
 */
fs.read = (fd, buffer, offset, length, position, callback) => {
  callback = maybeCallback(callback);
  const tiFileStream = streamForDescriptor(fd);
  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  }
  // FIXME: Allow using position argument!
  if (position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }
  tiFileStream.read(buffer.toTiBuffer(), offset, length, (readObj) => {
    if (!readObj.success) {
      callback(new Error(readObj.error));
      return;
    }
    callback(null, readObj.bytesProcessed, buffer);
  });
};

/**
 * @param {integer} fd file descriptor
 * @param {Buffer|Ti.Buffer} buffer buffer to read into
 * @param {integer} offset the offset in the buffer to start writing at.
 * @param {integer} length integer specifying the number of bytes to read.
 * @param {integer} _position where to begin reading from in the file
 * @returns {integer} bytes read
 */
fs.readSync = (fd, buffer, offset, length, _position) => {
  const fileStream = streamForDescriptor(fd);
  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  }

  // FIXME: Allow using position argument!
  if (_position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }
  return fileStream.read(buffer.toTiBuffer(), offset, length);
};

/**
 * @callback filesCallback
 * @param {Error} err - Error if one occurred
 * @param {string[]|Buffer[]|fs.Dirent[]} files - file listing
 */

/**
 * @param {string} path directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @param {filesCallback} callback async callback
 */
fs.readdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    let result;
    try {
      result = fs.readdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }
    callback(null, result);
  }, 1);
};

/**
 * @param {string} filepath directory to list
 * @param {string|object} [options] optional options
 * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
 * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
 * @returns {string[]|Buffer[]|fs.Dirent[]}
 */
fs.readdirSync = (filepath, options) => {
  const file = getTiFileFromPathLikeValue(filepath);
  if (!file.exists()) {
    throw noSuchFile('scandir', filepath);
  }
  if (!file.isDirectory()) {
    throw notADirectory('scandir', filepath);
  }
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8',
    withFileTypes: false
  });
  const listing = file.getDirectoryListing();
  if (options.withFileTypes === true) {
    // TODO: if options.withFileTypes === true, return fs.Dirent objects
    oneTimeWarning('fs.readdir\'s options.withFileTypes is unsupported by Titanium and strings will be returned');
  } else if (options.encoding === 'buffer') {
    return listing.map((name) => Buffer.from(name));
  }
  return listing;
};

/**
 * @callback readFilePostOpenCallback
 * @param {Error} err - Error if one occurred
 * @param {Ti.Buffer} buffer
 */
/**
 * @param {integer} fileDescriptor file descriptor
 * @param {readFilePostOpenCallback} callback async callback
 */
function readFilePostOpen(fileDescriptor, callback) {
  callback = maybeCallback(callback);
  fs.fstat(fileDescriptor, (err, stats) => {
    if (err) {
      callback(err);
      return;
    }
    const fileSize = stats.size;

    // Create a Ti.Buffer to read into
    const buffer = Ti.createBuffer({
      length: fileSize
    });

    // Use Ti.Stream.readAll(sourceStream, buffer, callback) which spins off a separate thread to read in while loop!
    const sourceStream = streamForDescriptor(fileDescriptor);
    Ti.Stream.readAll(sourceStream, buffer, (readAllObj) => {
      if (!readAllObj.success) {
        callback(new Error(readAllObj.error));
        return;
      }
      callback(null, buffer);
    });
  });
}

/**
 * @callback readFileCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} data
 */
/**
 * Asynchronously read entire contents of file
 * @param {string|Buffer|URL|integer} path filename or file descriptor
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @param {readFileCallback} callback async callback
 */
fs.readFile = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      encoding: null,
      flag: 'r'
    };
  } else {
    options = mergeDefaultOptions(options, {
      encoding: null,
      flag: 'r'
    });
  }
  callback = maybeCallback(callback);
  const wasFileDescriptor = typeof path === 'number';
  let fileDescriptor = path; // may be overriden later
  /**
   * @param {Error} err possible Error
   * @param {Ti.Buffer} buffer Ti.Buffer instance
   */
  const handleBuffer = (err, buffer) => {
    if (err) {
      callback(err);
      return;
    }

    // fs.closeSync if it was not originally a file descriptor
    if (!wasFileDescriptor) {
      fs.closeSync(fileDescriptor);
    }

    // TODO: trim buffer if we didn't read full size?

    callback(null, encodeBuffer(options.encoding, buffer));
  };
  if (!wasFileDescriptor) {
    fs.open(path, options.flag, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }
      fileDescriptor = fd;
      readFilePostOpen(fd, handleBuffer);
    });
  } else {
    readFilePostOpen(path, handleBuffer);
  }
};

/**
 * Returns the contents of the path.
 * @param {string|Buffer|URL|integer} path path to file
 * @param {object|string} [options] options
 * @param {string} [options.encoding=null] encoding to use
 * @param {string} [options.flag='r'] file system flag
 * @returns {string|Buffer} string if encoding is specified, otherwise Buffer
 */
fs.readFileSync = (path, options) => {
  options = mergeDefaultOptions(options, {
    encoding: null,
    flag: 'r'
  });
  const wasFileDescriptor = typeof path === 'number';
  const fileDescriptor = wasFileDescriptor ? path : fs.openSync(path, options.flag); // use default mode

  const tiFileStream = streamForDescriptor(fileDescriptor);
  // Just use our own API that reads full stream in
  const buffer = Ti.Stream.readAll(tiFileStream);

  // fs.closeSync if it was not originally a file descriptor
  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }

  // TODO: trim buffer if we didn't read full size?

  return encodeBuffer(options.encoding, buffer);
};

// TODO: fs.readlink(path[, options], callback)
// TODO: fs.readlinkSync(path[, options])

/**
 * @callback realpathCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} resolvedPath the resolved path
 */
/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] optiosn object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @param {realpathCallback} callback async callback
 */
fs.realpath = (filepath, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8'
  });
  setTimeout(() => {
    // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
    const result = path.normalize(filepath);
    fs.exists(result, (resultExists) => {
      if (resultExists) {
        if (options.encoding === 'buffer') {
          return callback(null, Buffer.from(result));
        }
        return callback(null, result);
      }

      // this path doesn't exist, try each segment until we find first that doesn't
      const segments = result.split(path.sep); // FIXME: Drop last segment as we already know the full path doesn't exist?
      let partialFilePath = '';
      let index = 0;
      // handle typical case of empty first segment so we don't need to do an async setTimeout to get to first real case
      if (segments[index].length === 0) {
        index++;
      }
      setTimeout(tryPath, 1);
      function tryPath() {
        if (index >= segments.length) {
          // don't run past end of segments, throw error for resolved path
          return callback(noSuchFile(result));
        }

        // grab next segment
        const segment = segments[index++];
        if (segment.length === 0) {
          // if it's an empty segment...
          // try again at next index
          return setTimeout(tryPath, 1);
        }

        // normal case
        partialFilePath += path.sep + segment;
        // check if path up to this point exists...
        fs.exists(partialFilePath, (partialExists) => {
          if (!partialExists) {
            // nope, throw the Error
            return callback(noSuchFile('lstat', partialFilePath));
          }
          // try again at next depth of dir tree
          setTimeout(tryPath, 1);
        });
      }
    });
  }, 1);
};
fs.realpath.native = (path, options, callback) => {
  fs.realpath(path, options, callback);
};

/**
 * @param {string|Buffer|URL} filepath original filepath
 * @param {object} [options] options object
 * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
 * @returns {string|Buffer}
 */
fs.realpathSync = (filepath, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8'
  });
  // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
  const result = path.normalize(filepath);
  if (!fs.existsSync(result)) {
    // this path doesn't exist, try each segment until we find first that doesn't
    const segments = result.split(path.sep);
    let partialFilePath = '';
    for (const segment of segments) {
      if (segment.length === 0) {
        continue;
      }
      partialFilePath += path.sep + segment;
      if (!fs.existsSync(partialFilePath)) {
        throw noSuchFile('lstat', partialFilePath);
      }
    }
  }
  if (options.encoding === 'buffer') {
    return Buffer.from(result);
  }
  return result;
};
fs.realpathSync.native = (path, options) => {
  fs.realpathSync(path, options);
};

/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 * @param {errorCallback} callback async callback
 */
fs.rename = (oldPath, newPath, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.renameSync(oldPath, newPath);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};

/**
 * @param {string|Buffer|URL} oldPath source filepath
 * @param {string|Buffer|URL} newPath destination filepath
 */
fs.renameSync = (oldPath, newPath) => {
  const tiFile = getTiFileFromPathLikeValue(oldPath);
  // src doesn't actually exist?
  if (!tiFile.exists()) {
    const err = noSuchFile('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }
  const destFile = getTiFileFromPathLikeValue(newPath);
  if (destFile.isDirectory()) {
    // dest is a directory that already exists
    const err = illegalOperationOnADirectory('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }
  let tempPath;
  if (destFile.isFile()) {
    // destination file exists, we should overwrite
    // Our APIs will fail if we try, so first let's make a backup copy and delete the the original
    tempPath = path.join(fs.mkdtempSync(path.join(Ti.Filesystem.tempDirectory, 'rename-')), path.basename(newPath));
    destFile.move(tempPath);
  }
  let success = false;
  try {
    success = tiFile.move(newPath);
  } finally {
    if (tempPath) {
      // we temporarily copied the existing destination to back it up...
      if (success) {
        // move worked, so we can wipe it away whenever...
        fs.unlink(tempPath, (_err) => {});
      } else {
        // move it back, because we failed!
        const tmpFile = getTiFileFromPathLikeValue(tempPath);
        tmpFile.move(newPath);
      }
    }
  }
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */
fs.rmdir = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.rmdirSync(path);
    } catch (e) {
      callback(e);
      return;
    }
    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 */
fs.rmdirSync = (path) => {
  const tiFile = getTiFileFromPathLikeValue(path);
  if (!tiFile.deleteDirectory(false)) {
    // do not delete contents!
    // we failed to delete, but why?
    // does it exist?
    if (!tiFile.exists()) {
      throw noSuchFile('rmdir', path);
    }
    // is it a file?
    if (tiFile.isFile()) {
      throw notADirectory('rmdir', path);
    }
    // is it not empty?
    const subFiles = tiFile.getDirectoryListing();
    if (subFiles && subFiles.length > 0) {
      throw directoryNotEmpty('rmdir', path);
    }
  }
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {object} [options] options
 * @param {boolean} [options.bigint] whether stat values should be bigint
 * @param {statsCallback} callback async callback
 */
fs.stat = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(null, new fs.Stats(path));
  }, 1);
};
/**
 * @param {string|Buffer|URL|integer} path filepath or file descriptor
 * @param {object} [_options] options
 * @param {boolean} [_options.bigint] whether stat values should be bigint
 * @returns {fs.Stats}
 */
fs.statSync = (path, _options) => new fs.Stats(path);
fs.symlink = (target, path, type, callback) => asyncUnsupportedNoop('fs', 'symlink', callback);
fs.symlinkSync = unsupportedNoop('fs', 'symlinkSync');

/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 * @param {errorCallback} callback async callback
 */
fs.truncate = (path, len, callback) => {
  callback = maybeCallback(callback || len);
  if (typeof len !== 'number') {
    len = 0;
  }
  if (len <= 0) {
    fs.writeFile(path, '', callback); // empty the file
    return;
  }

  // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it
  fs.open(path, (err, fd) => {
    if (err) {
      return callback(err);
    }
    const buffer = Buffer.alloc(len);
    fs.read(fd, buffer, 0, len, null, (err, bytesRead, buffer) => {
      if (err) {
        fs.closeSync(fd);
        return callback(err);
      }
      fs.close(fd, (err) => {
        if (err) {
          return callback(err);
        }
        fs.writeFile(path, buffer, callback);
      });
    });
  });
};

/**
 * @param {string} path file path
 * @param {integer} [len=0] bytes to trim to
 */
fs.truncateSync = (path, len = 0) => {
  if (len <= 0) {
    // empty the file
    fs.writeFileSync(path, '');
    return;
  }

  // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it
  const fd = fs.openSync(path);
  const buffer = Buffer.alloc(len);
  fs.readSync(fd, buffer, 0, len, null);
  fs.closeSync(fd);
  fs.writeFileSync(path, buffer);
};

/**
 * @param {string|Buffer|URL} path file path
 * @param {errorCallback} callback async callback
 */
fs.unlink = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.unlinkSync(path);
    } catch (err) {
      callback(err);
      return;
    }
    callback();
  }, 1);
};
/**
 * @param {string|Buffer|URL} path file path
 * @returns {undefined}
 */
fs.unlinkSync = (path) => {
  const tiFile = getTiFileFromPathLikeValue(path);
  if (!tiFile.deleteFile()) {
    // we failed, but why?
    if (!tiFile.exists()) {
      throw noSuchFile('unlink', path);
    }
    if (tiFile.isDirectory()) {
      throw illegalOperationOnADirectory('unlink', path);
    }
  }
};
fs.unwatchFile = unsupportedNoop('fs', 'unwatchFile');
fs.utimes = (path, atime, mtime, callback) => asyncUnsupportedNoop('fs', 'utimes', callback);
fs.utimesSync = unsupportedNoop('fs', 'utimesSync');
fs.watch = unsupportedNoop('fs', 'watch');
fs.watchFile = unsupportedNoop('fs', 'watchFile');

/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string|null} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 * @param {errorCallback} callback async callback
 */
fs.writeFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w'
  });

  // Turn into file descriptor
  const wasFileDescriptor = typeof file === 'number';
  let fileDescriptor = file; // may be overriden later
  const finish = (err) => {
    if (err) {
      callback(err);
      return;
    }
    if (wasFileDescriptor) {
      callback();
      return;
    }

    // fs.close if it was not originally a file descriptor
    fs.close(fileDescriptor, callback);
  };
  if (!wasFileDescriptor) {
    fs.open(file, options.flag, options.mode, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }
      fileDescriptor = fd;
      fs.write(fileDescriptor, data, finish);
    });
  } else {
    fs.write(fileDescriptor, data, finish);
  }
};

/**
 * @param {string|Buffer|URL|integer} file file path or descriptor
 * @param {string|Buffer|TypedArray|DataView} data data to write
 * @param {object|string} [options] options, encoding if string
 * @param {string} [options.encoding='utf-8'] options
 * @param {object} [options.mode=0o666] options
 * @param {object} [options.flag='w'] options
 */
fs.writeFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w'
  });

  // Turn into file descriptor
  const wasFileDescriptor = typeof file === 'number';
  const fileDescriptor = wasFileDescriptor ? file : fs.openSync(file, options.flag, options.mode);

  // if data is a string, make it a buffer first
  if (!Buffer.isBuffer(data)) {
    data = Buffer.from('' + data, options.encoding); // force data to be a string, handles case where it's undefined and writes 'undefined' to file!
  }

  fs.writeSync(fileDescriptor, data);

  // close if user didn't give us file descriptor
  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }
};

/**
 * @callback writeTiFileStreamCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 */

/**
 * @param {Ti.Filesystem.FileStream} tiFileStream file stream
 * @param {Buffer} buffer buffer we're writing
 * @param {writeTiFileStreamCallback} callback async callback
 */
function writeTiFileStream(tiFileStream, buffer, callback) {
  callback = maybeCallback(callback);
  Ti.Stream.write(tiFileStream, buffer.toTiBuffer(), (writeObj) => {
    if (!writeObj.success) {
      callback(new Error(writeObj.error));
      return;
    }
    callback(null, writeObj.bytesProcessed);
  });
}

/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write: Buffer or string
 * @param {integer} [offset] offset within Buffer to write; OR offset from the beginning of the file where this data should be written (if string)
 * @param {string|integer} [length] length of bytes to write if Buffer; OR expected string encoding
 * @param {writeCallback|integer} [position] offset from the beginning of the file where this data should be written (if Buffer); OR async callback if string
 * @param {writeCallback} [callback] async callback (if Buffer)
 */
fs.write = (fd, buffer, offset, length, position, callback) => {
  const isBuffer = Buffer.isBuffer(buffer);
  if (isBuffer) {
    writeBuffer(fd, buffer, offset, length, position, callback);
  } else {
    writeString(fd, buffer, offset, length, position);
  }
};

/**
 * @param {integer} fd file descriptor
 * @param {string|Buffer} buffer contents to write
 * @param {integer} [offset] offset from the beginning of the file where this data should be written
 * @param {string|integer} [length]  expected string encoding
 * @param {integer} [position] position
 * @returns {integer} number of bytes written
 */
fs.writeSync = (fd, buffer, offset, length, position) => {
  const isBuffer = Buffer.isBuffer(buffer);
  if (isBuffer) {
    return writeBufferSync(fd, buffer, offset, length);
  }
  return writeStringSync(fd, buffer, offset, length);
};

// TODO: Add FileHandle class to match Node's wrapper for file descriptors. Re-purpose our own wrapper?
// TODO: Add the fs.promises API!

// TODO: Define fs.Dirent class, which can simply wrap a Ti.Filesystem.File (and is very similar to fs.Stats!)

// Helper functions
// --------------------------------------------------------

/**
 * Tracks the pairing of the number we use to represent the file externally, the filepath it's pointing at, and the stream pointing at it.
 */
class FileDescriptor {
  constructor(number, path, stream) {
    this.path = path;
    this.number = number;
    this.stream = stream;
  }
}

/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */
function pipe(srcStream, destStream, callback) {
  {
    // Android is probably better off with Ti.Stream.writeStream, less overhead back and forth the bridge
    // Though Android does support the Ti.Stream.pump/Ti.Stream.write pattern using both APIs async
    pipeViaWriteStream(srcStream, destStream, callback);
    return;
  }
}

/**
 * @param {Ti.IOStream} srcStream input stream we're reading from
 * @param {Ti.IOStream} destStream output stream we're writing to
 * @param {errorCallback} callback async callback
 */
function pipeViaWriteStream(srcStream, destStream, callback) {
  Ti.Stream.writeStream(srcStream, destStream, COPY_FILE_CHUNK_SIZE, (result) => {
    if (!result.success) {
      return callback(new Error(result.error));
    }

    // Android will only call this at the end or error, so we can safely assume we're done here.
    // iOS will call per loop iteration, see https://jira-archive.titaniumsdk.com/TIMOB-27320
    callback();
  });
}

/**
 * @param {string|Buffer|URL} path file path
 * @param {Ti.Filesystem.FileStream} fileStream file stream
 * @returns {integer} file descriptor
 */
function createFileDescriptor(path, fileStream) {
  const pointer = fileDescriptorCount++; // increment global counter
  const fd = new FileDescriptor(pointer, path, fileStream);
  fileDescriptors.set(pointer, fd); // use it to refer to this file stream as the "descriptor"
  return pointer;
}

/**
 * @param {integer} fd file descriptor
 * @returns {Ti.Filesystem.FileStream} matching stream
 */
function streamForDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.stream;
}

/**
 * @param {integer} fd file descriptor
 * @returns {string} matching stream
 */
function pathForFileDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.path;
}

/**
 * Used to merge the user-supplied options with the defaults for a function. Special cases a string to be encoding.
 * @param {*} options user-supplied options
 * @param {object} defaults defaults to use
 * @return {object}
 */
function mergeDefaultOptions(options, defaults) {
  if (options === null) {
    return defaults;
  }
  const optionsType = typeof options;
  switch (optionsType) {
    case 'undefined':
    case 'function':
      return defaults;
    case 'string':
      // Use copy of defaults but with encoding set to the 'options' value!
      const merged = Object.assign({}, defaults);
      merged.encoding = options;
      return merged;
    case 'object':
      return options;
    default:
      assertArgumentType(options, 'options', 'object');
      return null;
    // should never get reached
  }
}

/**
 * Enforces that we have a valid callback function. Throws TypeError if not.
 * @param {*} cb possible callback function
 * @returns {Function}
 * @throws {TypeError}
 */
function maybeCallback(cb) {
  if (typeof cb === 'function') {
    return cb;
  }
  const err = new TypeError(`Callback must be a function. Received ${cb}`);
  err.code = 'ERR_INVALID_CALLBACK';
  throw err;
}

/**
 * returns randomly generated characters of given length 1-16
 * @param {integer} length 1 - 16
 * @param {string} [_encoding='utf8'] encoding of the string generated
 * @returns {string}
 */
function randomCharacters(length, _encoding = 'utf8') {
  // FIXME: use the encoding specified!
  return (Math.random().toString(36) + '00000000000000000').slice(2, length + 2);
}
function makeError(code, message, errno, syscall, path) {
  const error = new Error(`${code}: ${message}, ${syscall} '${path}'`);
  error.errno = errno;
  error.syscall = syscall;
  error.code = code;
  error.path = path;
  return error;
}

/**
 * @param {string} encoding what we're encoding to
 * @param {Ti.Buffer} tiBuffer Ti.Buffer instance
 * @returns {Buffer} node-compatible Buffer instance
 */
function encodeBuffer(encoding, tiBuffer) {
  switch (encoding) {
    case 'buffer':
    case null:
    case undefined:
      // In this case we're always reading a file into a Ti.Buffer
      // Wrapping Ti.Buffer is super-slow and should really only be if we're going to write to it
      // Go the faster path by converting to ArrayBuffer and wrapping that
      // TODO: Explicitly release the blob after conversion?
      return Buffer.from(tiBuffer.toBlob().toArrayBuffer());
    default:
      // here' were converting to a string based on encoding. Internally our faster Buffer impl still delegates to Ti.Buffer in most cases
      // so I don't think there's much benefit from converting to ArrayBuffer first
      return Buffer.from(tiBuffer).toString(encoding);}

}

/**
 * @param {string|Buffer|URL} path file path
 * @return {Ti.Filesystem.File}
 */
function getTiFileFromPathLikeValue(path) {
  // This is a hack that is likely to work in most cases?
  // Basically assumes Buffer is holding a utf-8 string filename/path
  // Node just copies the bytes from the buffer as-is on the native side and adds a null terminator
  if (Buffer.isBuffer(path)) {
    path = path.toString(); // assumes utf-8 string
  }
  // FIXME: Handle URLs! We don't have an URL shim yet, so no way to handle those yet
  assertArgumentType(path, 'path', 'string');
  return Ti.Filesystem.getFile(path);
}

/**
 * @callback writeBufferCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {Buffer} buffer - original Buffer being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {writeBufferCallback} callback async callback
 */
function writeBuffer(fd, buffer, offset, length, position, callback) {
  callback = maybeCallback(callback || position || length || offset);
  if (typeof offset !== 'number') {
    offset = 0;
  }
  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }
  if (typeof position !== 'number') {
    position = null;
  }
  // ok now what?
  const tiFileStream = streamForDescriptor(fd);
  // Make use of the buffer slice that's specified by offset/length
  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  }
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }
    callback(null, bytesProcessed, buffer);
  });
}

/**
 * @param {integer} fd file descriptor
 * @param {Buffer} buffer contents to write
 * @param {integer} [offset] offset within Buffer to write
 * @param {integer} [length] length of bytes to write if Buffer
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @returns {integer} number of bytes written
 */
function writeBufferSync(fd, buffer, offset, length, position) {
  if (typeof offset !== 'number') {
    offset = 0;
  }
  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }
  // ok now what?
  const tiFileStream = streamForDescriptor(fd);
  // Make use of the buffer slice that's specified by offset/length
  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  }
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  return tiFileStream.write(buffer.toTiBuffer());
}

/**
 * @callback writeStringCallback
 * @param {Error} err - Error if one occurred
 * @param {integer} written - bytes written
 * @param {string} string - original string being written
 */

/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @param {writeStringCallback} [callback] async callback
 */
function writeString(fd, string, position, encoding, callback) {
  callback = maybeCallback(callback || encoding || position);
  // position could be: number, function (callback)
  if (typeof position !== 'number') {
    position = null;
  }
  // encoding could be: function (callback) or string
  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }
  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string
  const buffer = Buffer.from(string, encoding);
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }
    callback(null, bytesProcessed, string);
  });
}

/**
 * @param {integer} fd file descriptor
 * @param {string} string contents to write
 * @param {integer} [position] offset from the beginning of the file where this data should be written
 * @param {string} [encoding='utf8'] expected string encoding
 * @returns {integer} number of bytes written
 */
function writeStringSync(fd, string, position, encoding) {
  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }
  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string
  const buffer = Buffer.from(string, encoding);
  // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow
  return tiFileStream.write(buffer.toTiBuffer());
}

function Stream(_opts) {
  // FIXME: Can't call EventEmitter as a function!
  this._eventsToListeners = {};
  this._maxListeners = undefined;
  // EventEmitter.call(this, opts);
  // TODO: Provide more than an empty class?
}

Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
// Use util.inherits?

function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  }

  // TODO: readableState?

  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') {
      this._read = options.read;
    }
    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }
  }
  Stream.call(this);
}
util.inherits(Readable, Stream);
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};
Readable.prototype._read = function (_n) {
  throw new Error('method not implemented: _read()');
};
function Writable(options) {
  const isDuplex = this instanceof Duplex;
  if (!isDuplex && !(this instanceof Writable)) {
    return new Writable(options);
  }
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') {
      this._write = options.write;
    }
    if (typeof options.writev === 'function') {
      this._writev = options.writev;
    }
    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }
    if (typeof options.final === 'function') {
      this._final = options.final;
    }
  }
  Stream.call(this);
}
util.inherits(Writable, Stream);
function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }
  Readable.call(this, options);
  Writable.call(this, options);
  // TODO: Provide more than an empty class!
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }
    if (options.writable === false) {
      this.writable = false;
    }
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      // this.once('end', onend);
    }
  }
}

util.inherits(Duplex, Readable);
// Copy Writable methods to Duplex (basically the odd double-inheritance)
const writableMethods = Object.keys(Writable.prototype);
for (let i = 0; i < writableMethods.length; i++) {
  const method = writableMethods;
  if (!Duplex.prototype[method]) {
    Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }
  Duplex.call(this, options);
  // TODO: Provide more than an empty class!
  if (options) {
    if (typeof options.transform === 'function') {
      this._transform = options.transform;
    }
    if (typeof options.flush === 'function') {
      this._flush = options.flush;
    }
  } // When the writable side finishes, then flush out anything remaining.

  // this.on('prefinish', prefinish);
}

util.inherits(Transform, Duplex);
Stream.Stream = Stream; // legacy compat
Stream.Transform = Transform;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;

// Load all the node compatible core modules
register('path', path);
register('os', OS);
register('tty', tty);
register('util', util);
register('assert', assert);
register('events', EventEmitter);
register('buffer', BufferModule);
register('string_decoder', StringDecoder$1);
register('fs', fs);
register('stream', Stream);

// Register require('buffer').Buffer as global
global.Buffer = BufferModule.Buffer;

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * Description:
 * This script loads all JavaScript files ending with the name "*.bootstrap.js" and then executes them.
 * The main intention of this feature is to allow JavaScript files to kick-off functionality or
 * display UI to the end-user before the "app.js" gets loaded. This feature is the CommonJS
 * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.
 *
 * Use-Cases:
 * - Automatically kick-off analytics functionality on app startup.
 * - Ensure "Google Play Services" is installed/updated on app startup on Android.
 */

/**
 * Attempts to load all bootstraps from a "bootstrap.json" file created by the app build system.
 * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.
 * This JSON file, if provided, must be in the same directory as this script.
 * @returns {string[]}
 * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.
 * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.
 * Returns null if JSON file was not found.
 */
function fetchScriptsFromJson() {
  const JSON_FILE_NAME = 'bootstrap.json';
  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, `ti.internal/${JSON_FILE_NAME}`);
    if (jsonFile.exists()) {
      const settings = JSON.parse(jsonFile.read().text);
      if (Array.isArray(settings.scripts)) {
        return settings.scripts;
      }
      return [];
    }
  } catch (error) {
    Ti.API.error(`Failed to read "${JSON_FILE_NAME}". Reason: ${error.message}`);
  }
  return null;
}

/**
 * Recursively searches the "Resources" directory for all "*.bootstrap.js" files.
 * @returns {Array.<string>}
 * Returns an array of require() compatible strings for each bootstrap found in the search.
 * Returns an empty array if no bootstrap files were found.
 */
function fetchScriptsFromResourcesDirectory() {
  const resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);
  const resourceDirectoryPathLength = resourceDirectory.nativePath.length;
  const bootstrapScripts = [];
  function loadFrom(file) {
    if (file) {
      if (file.isDirectory()) {
        // This is a directory. Recursively look for bootstrap files under it.
        const fileNameArray = file.getDirectoryListing();
        if (fileNameArray) {
          for (let index = 0; index < fileNameArray.length; index++) {
            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));
          }
        }
      } else if (file.name.search(/.bootstrap.js$/) >= 0) {
        // This is a bootstrap file.
        // Convert its path to something loadable via require() and add it to the array.
        let bootstrapPath = file.nativePath;
        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);
        bootstrapScripts.push(bootstrapPath);
      }
    }
  }
  loadFrom(resourceDirectory);
  return bootstrapScripts;
}

/**
 * Non-blocking function which loads and executes all bootstrap scripts configured for the app.
 * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.
 */
function loadAsync(finished) {
  // Acquire an array of all bootstrap scripts included with the app.
  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.
  // - If JSON file not found (will return null), then search "Resources" directory for bootstrap files.
  let bootstrapScripts = fetchScriptsFromJson();
  if (!bootstrapScripts) {
    bootstrapScripts = fetchScriptsFromResourcesDirectory();
  }

  // Do not continue if no bootstraps were found.
  if (!bootstrapScripts || bootstrapScripts.length <= 0) {
    finished();
    return;
  }

  // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.
  bootstrapScripts.sort();

  // Loads all bootstrap scripts found.
  function loadBootstrapScripts(finished) {
    let bootstrapIndex = 0;
    function doLoad() {
      // Attempt to load all bootstrap scripts.
      while (bootstrapIndex < bootstrapScripts.length) {
        // Load the next bootstrap.
        const fileName = bootstrapScripts[bootstrapIndex];
        const bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require

        // Invoke the bootstrap's execute() method if it has one. (This is optional.)
        // We must wait for the given callback to be invoked before loading the next script.
        // Note: This is expected to be used to display UI to the end-user.
        if (bootstrap.execute) {
          bootstrap.execute(onBootstrapExecutionFinished);
          return;
        }

        // We're done with the current bootstrap. Time to load the next one.
        bootstrapIndex++;
      }

      // Invoke given callback to inform caller that all loading is done.
      finished();
    }
    function onBootstrapExecutionFinished() {
      // Last bootstrap has finished execution. Time to load the next one.
      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.
      bootstrapIndex++;
      setTimeout(() => doLoad(), 1);
    }
    doLoad();
  }

  // We've finished loading/executing all bootstrap scripts.
  // Inform caller by invoking the callback given to loadAsync().
  loadBootstrapScripts(finished);
}

/**
 * Titanium SDK
 * Copyright TiDev, Inc. 04/07/2022-Present. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 * This script is loaded on app startup on all platforms. It is used to do the following:
 * - Provide consistent startup behavior between platforms, such as logging Titanium version.
 * - Load Titanium's core JavaScript extensions shared by all platforms.
 * - Provide "*.bootstrap.js" script support. (Similar to native module onAppCreate()/load() support.)
 * - Load the app developer's main "app.js" script after doing all of the above.
 */

// Log the app name, app version, and Titanium version on startup.
Ti.API.info(`${Ti.App.name} ${Ti.App.version} (Powered by Titanium ${"12.5.1"}.${"8a4da6adba"})`);
loadAsync(function () {
  // We've finished loading/executing all bootstrap scripts.
  // We can now proceed to run the main "app.js" script.
  require('./app');

  // This event is to be fired after "app.js" execution. Reasons:
  // - Allow system to queue startup related events until "app.js" has had a chance to add listeners.
  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.
  Ti.App.fireEvent('started');
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLENBQUM7QUFDcGxCOztBQUVBLFNBQVNDLGNBQWNBLENBQUMzRSxHQUFHLEVBQUU7RUFDM0Is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QUUsRUFBRTtJQUNWQyxHQUFHLEVBQUUsQ0FBQztJQUNOQyxPQUFPLEVBQUUsRUFBRTtJQUNYQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxLQUFLLEVBQUUsRUFBRTtJQUNUQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxNQUFNLEVBQUUsRUFBRTtJQUNWQyxRQUFRLEVBQUUsRUFBRTtJQUNaQyxTQUFTLEVBQUUsRUFBRTtJQUNiQyxZQUFZLEVBQUUsRUFBRTtJQUNoQkMsUUFBUSxFQUFFLEVBQUU7SUFDWkMsU0FBUyxFQUFFLEVBQUU7SUFDYkMsV0FBVyxFQUFFLEVBQUU7SUFDZkMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsT0FBTyxFQUFFLEVBQUU7SUFDWEMsT0FBTyxFQUFFLEVBQUU7SUFDWEMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsTUFBTSxFQUFFLENBQUM7SUFDVEMsT0FBTyxFQUFFLENBQUM7SUFDVkMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsT0FBTyxFQUFFLEVBQUU7SUFDWEMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsV0FBVyxFQUFFLEVBQUU7SUFDZkMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsS0FBSyxFQUFFLEVBQUU7SUFDVEMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsUUFBUSxFQUFFLEVBQUU7SUFDWkMsT0FBTyxFQUFFLEVBQUU7SUFDWEMsU0FBUyxFQUFFLEVBQUU7SUFDYkMsUUFBUSxFQUFFLEVBQUU7SUFDWkMsT0FBTyxFQUFFLEVBQUU7SUFDWEMsTUFBTSxFQUFFLEVBQUU7SUFDVkMsS0FBSyxFQUFFLENBQUM7SUFDUkMsVUFBVSxFQUFFLEdBQUc7SUFDZkMsU0FBUyxFQUFFLEVBQUU7SUFDYkMsS0FBSyxFQUFFLENBQUM7SUFDUkMsS0FBSyxFQUFFLEVBQUU7SUFDVEMsTUFBTSxFQUFFLEdBQUc7SUFDWEMsZUFBZSxFQUFFLEVBQUU7SUFDbkJDLFVBQVUsRUFBRSxFQUFFO0lBQ2RDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLEtBQUssRUFBRSxFQUFFO0lBQ1RDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLEtBQUssRUFBRSxDQUFDO0lBQ1JDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLEtBQUssRUFBRSxHQUFHO0lBQ1ZDLFNBQVMsRUFBRSxFQUFFO0lBQ2JDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLFdBQVcsRUFBRSxFQUFFO0lBQ2ZDLEtBQUssRUFBRTtFQUNULENBQUM7RUFDREMsT0FBTyxFQUFFO0lBQ1BDLE1BQU0sRUFBRSxDQUFDO0lBQ1RDLE1BQU0sRUFBRSxDQUFDO0lBQ1RDLE9BQU8sRUFBRSxDQUFDO0lBQ1ZDLE1BQU0sRUFBRSxDQUFDO0lBQ1RDLE9BQU8sRUFBRSxDQUFDO0lBQ1ZDLE9BQU8sRUFBRSxDQUFDO0lBQ1ZDLE1BQU0sRUFBRSxDQUFDO0lBQ1RDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLE1BQU0sRUFBRSxDQUFDO0lBQ1RDLE9BQU8sRUFBRSxDQUFDO0lBQ1ZDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE1BQU0sRUFBRSxFQUFFO0lBQ1ZDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLFNBQVMsRUFBRSxFQUFFO0lBQ2JDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLFFBQVEsRUFBRSxFQUFFO0lBQ1pDLEtBQUssRUFBRSxFQUFFO0lBQ1RDLE9BQU8sRUFBRSxFQUFFO0lBQ1hDLE1BQU0sRUFBRTtFQUNWLENBQUM7RUFDREMsUUFBUSxFQUFFO0lBQ1JDLFlBQVksRUFBRSxFQUFFO0lBQ2hC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O0VBQ0FGLG9CQUFvQixDQUFDRCxRQUFRLENBQUM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0F4b0QsRUFBRSxDQUFDMnRCLEdBQUcsQ0FBQ25CLElBQUksQ0FBRSxHQUFFeHNCLEVBQUUsQ0FBQzR4QixHQUFHLENBQUMzc0IsSUFBSyxJQUFHakYsRUFBRSxDQUFDNHhCLEdBQUcsQ0FBQytRLE9BQVEseUJBQXdCLFFBQVMsSUFBRyxZQUFhLEdBQUUsQ0FBQztBQUNqRzRsQixTQUFTLENBQUMsWUFBWTtFQUNwQjtFQUNBO0VBQ0F6M0IsT0FBTyxDQUFDLE9BQU8sQ0FBQzs7RUFFaEI7RUFDQTtFQUNBO0VBQ0E5d0IsRUFBRSxDQUFDNHhCLEdBQUcsQ0FBQ2szQixTQUFTLENBQUMsU0FBUyxDQUFDO0FBQzdCLENBQUMsQ0FBQyIsIm5hbWVzIjpbImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidmFsdWUiLCJ3cml0YWJsZSIsIk9TX1ZFUlNJT05fTUFKT1IiLCJUaSIsIlBsYXRmb3JtIiwidmVyc2lvbk1ham9yIiwiT1NfVkVSU0lPTl9NSU5PUiIsInZlcnNpb25NaW5vciIsIk9TX1ZFUlNJT05fUEFUQ0giLCJ2ZXJzaW9uUGF0Y2giLCJrTm9kZU1vZHVsZXNSRSIsImN1c3RvbUluc3BlY3RTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJpc0J1ZmZlciIsImNvbG9yUmVnRXhwIiwicmVtb3ZlQ29sb3JzIiwic3RyIiwicmVwbGFjZSIsImlzRXJyb3IiLCJlIiwiaXNOYXRpdmVFcnJvciIsIkVycm9yIiwiZ2V0U3RydWN0dXJlZFN0YWNrIiwiU3RhY2tUcmFjZUVycm9yIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJlcnIiLCJ0cmFjZSIsInN0YWNrVHJhY2VMaW1pdCIsIkluZmluaXR5IiwiaXNJbnNpZGVOb2RlTW9kdWxlcyIsInVuZGVmaW5lZCIsInN0YWNrIiwic3RhY2tGcmFtZXMiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsImxpbmVJbmZvIiwibWF0Y2giLCJmaWxlbmFtZSIsInB1c2giLCJnZXRGaWxlTmFtZSIsIkFycmF5IiwiaXNBcnJheSIsImZyYW1lIiwidGVzdCIsImpvaW4kMSIsIm91dHB1dCIsInNlcGFyYXRvciIsImxlbmd0aCIsImxhc3RJbmRleCIsImkiLCJ1bmN1cnJ5VGhpcyIsImYiLCJjYWxsIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJBTExfUFJPUEVSVElFUyQyIiwiT05MWV9FTlVNRVJBQkxFJDIiLCJwcm9wZXJ0eUZpbHRlciIsIkFMTF9QUk9QRVJUSUVTIiwiT05MWV9FTlVNRVJBQkxFIiwiZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzIiwib2JqIiwiZmlsdGVyIiwicHJvcHMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleSIsImlzQWxsRGlnaXRzIiwicyIsImNvZGUiLCJjaGFyQ29kZUF0IiwiVHlwZWRBcnJheVByb3RvdHlwZSQxIiwiZ2V0UHJvdG90eXBlT2YiLCJVaW50OEFycmF5IiwicHJvdG90eXBlIiwiVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidG9TdHJpbmdUYWciLCJnZXQiLCJpc09iamVjdCIsImlzRnVuY3Rpb24iLCJjaGVja1Byb3RvdHlwZSIsIm5hbWUiLCJ0b1N0cmluZyIsImlzQW55QXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNBcnJheUJ1ZmZlclZpZXciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzQXN5bmNGdW5jdGlvbiIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc0Jvb2xlYW5PYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzU3ltYm9sT2JqZWN0IiwiaXNEYXRhVmlldyIsImlzRGF0ZSIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwiaXNHZW5lcmF0b3JPYmplY3QiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzTWFwIiwiaXNNYXBJdGVyYXRvciIsImNvbnN0cnVjdG9yIiwiaW5jbHVkZXMiLCJpc1Byb21pc2UiLCJpc1JlZ0V4cCIsImlzU2V0IiwiaXNTZXRJdGVyYXRvciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiaXNUeXBlZEFycmF5IiwiaXNCdWlsdEluVHlwZWRBcnJheSIsImlzVWludDhBcnJheSIsImlzVWludDhDbGFtcGVkQXJyYXkiLCJpc1VpbnQxNkFycmF5IiwiaXNVaW50MzJBcnJheSIsImlzV2Vha01hcCIsImlzV2Vha1NldCIsInR5cGVzIiwiZnJlZXplIiwiX19wcm90b19fIiwiZXJyb3IiLCJsYXp5RXJyb3IiLCJjb2RlcyIsIkVSUl9JTlRFUk5BTF9BU1NFUlRJT04iLCJhc3NlcnQkMSIsIm1lc3NhZ2UiLCJmYWlsIiwibWVzc2FnZXMiLCJNYXAiLCJTeXN0ZW1FcnJvciIsIkUiLCJzeW0iLCJ2YWwiLCJkZWYiLCJvdGhlckNsYXNzZXMiLCJzZXQiLCJtYWtlTm9kZUVycm9yV2l0aENvZGUiLCJmb3JFYWNoIiwiY2xhenoiLCJCYXNlIiwiTm9kZUVycm9yIiwiYXJncyIsImdldE1lc3NhZ2UiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJhZGRDb2RlVG9OYW1lIiwibXNnIiwiZXhwZWN0ZWRMZW5ndGgiLCJ1bnNoaWZ0IiwiZm9ybWF0JDEiLCJSYW5nZUVycm9yIiwic3VmZml4IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJkZXRlcm1pbmVyIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwib25lT2YiLCJ0eXBlIiwiVHlwZUVycm9yIiwibWF4U3RhY2tfRXJyb3JOYW1lIiwibWF4U3RhY2tfRXJyb3JNZXNzYWdlIiwiaXNTdGFja092ZXJmbG93RXJyb3IiLCJvdmVyZmxvd1N0YWNrIiwidGhpbmciLCJsZW4iLCJtYXAiLCJTdHJpbmciLCJzbGljZSIsImpvaW4iLCJGYXN0QnVmZmVyIiwic3RyaW5nVG9IZXhCeXRlcyIsImJ5dGVBcnJheSIsIm51bWVyaWNWYWx1ZSIsInBhcnNlSW50Iiwic3Vic3RyIiwiTnVtYmVyIiwiaXNOYU4iLCJhcnJheUluZGV4SGFuZGxlciIsInRhcmdldCIsInByb3BLZXkiLCJyZWNlaXZlciIsIm51bSIsImlzU2FmZUludGVnZXIiLCJnZXRBZGp1c3RlZEluZGV4IiwiUmVmbGVjdCIsInNldEFkanVzdGVkSW5kZXgiLCJoYXMiLCJfdGlCdWZmZXIiLCJTbG93QnVmZmVyIiwidGlCdWZmZXIiLCJzdGFydCIsImJ5dGVPZmZzZXQiLCJmcm9tVGlCdWZmZXIiLCJQcm94eSIsImZyb21TdHJpbmciLCJlbmNvZGluZyIsIkJ1ZmZlciIsImlzRW5jb2RpbmciLCJ0b0xvd2VyQ2FzZSIsImJsb2IiLCJVdGlscyIsImJhc2U2NGRlY29kZSIsImJsb2JTdHJlYW0iLCJTdHJlYW0iLCJjcmVhdGVTdHJlYW0iLCJzb3VyY2UiLCJtb2RlIiwiTU9ERV9SRUFEIiwiYnVmZmVyIiwicmVhZEFsbCIsImNsb3NlIiwiYnl0ZXMiLCJjcmVhdGVCdWZmZXIiLCJnZXRUaUNvZGVjQ2hhcnNldCIsImZyb20iLCJfc2xpY2UiLCJvZmZzZXQiLCJfZmlsbCIsImVuZCIsInZhbHVlVHlwZSIsImJ1ZlRvRmlsbFdpdGgiLCJmaWxsQnVmTGVuZ3RoIiwiZmlsbCIsImZpbGxDaGFyIiwiaW5kZXgiLCJzcmMiLCJudW1CeXRlcyIsInRvVGlCdWZmZXIiLCJjbG9uZSIsImJ1ZiIsIlRJX0NPREVDX01BUCIsIkNvZGVjIiwiQ0hBUlNFVF9VVEY4IiwiQ0hBUlNFVF9VVEYxNkxFIiwiQ0hBUlNFVF9JU09fTEFUSU5fMSIsIkNIQVJTRVRfQVNDSUkiLCJBTExfUFJPUEVSVElFUyQxIiwiT05MWV9FTlVNRVJBQkxFJDEiLCJWQUxJRF9FTkNPRElOR1MiLCJkb3VibGVBcnJheSIsIkZsb2F0NjRBcnJheSIsInVpbnQ4RG91YmxlQXJyYXkiLCJmbG9hdEFycmF5IiwiRmxvYXQzMkFycmF5IiwidWludDhGbG9hdEFycmF5IiwiQnVmZmVyJDEiLCJwb29sU2l6ZSIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhcGlOYW1lIiwic2hvd0ZsYWdnZWREZXByZWNhdGlvbiIsImFsbG9jIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbUFycmF5IiwiZnJvbUJ1ZmZlciIsIm1heExlbmd0aCIsImJ5dGVMZW5ndGgiLCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMiLCJ0b0FycmF5QnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJjb3B5Iiwic2V0UHJvdG90eXBlT2YiLCJjb21wYXJlIiwidGFyZ2V0U3RhcnQiLCJ0YXJnZXRFbmQiLCJzb3VyY2VTdGFydCIsInNvdXJjZUVuZCIsImJ1ZjEiLCJzb3VyY2VMZW5ndGgiLCJkZXN0IiwiZGVzdExlbmd0aCIsIk1hdGgiLCJtaW4iLCJ0YXJnZXRWYWx1ZSIsInNvdXJjZVZhbHVlIiwicmVtYWluaW5nIiwic291cmNlTGVuIiwiZW50cmllcyIsIm5leHRJbmRleCIsImVudHJ5SXRlcmF0b3IiLCJuZXh0IiwicmVzdWx0IiwiZG9uZSIsIml0ZXJhdG9yIiwiZXF1YWxzIiwib3RoZXJCdWZmZXIiLCJvZmZzZXRUeXBlIiwiVHlwZWRBcnJheVByb3RvdHlwZSIsIlR5cGVkQXJyYXlQcm90b19ieXRlTGVuZ3RoIiwiVHlwZWRBcnJheUZpbGwiLCJieXRlTGVuIiwiZmlsbExlbmd0aCIsImluZGV4T2YiLCJtYXRjaExlbmd0aCIsImN1cnJlbnRJbmRleCIsInRoaXNMZW5ndGgiLCJmaXJzdE1hdGNoIiwiZmlyc3RCeXRlTWF0Y2giLCJ4IiwibXlJdGVyYXRvciIsInJlYWREb3VibGVCRSIsImNoZWNrT2Zmc2V0IiwicmVhZERvdWJsZUxFIiwicmVhZEZsb2F0QkUiLCJyZWFkRmxvYXRMRSIsInJlYWRJbnQ4IiwidW5zaWduZWRWYWx1ZSIsInJlYWRVSW50OCIsInVuc2lnbmVkVG9TaWduZWQiLCJyZWFkSW50MTZCRSIsInJlYWRVSW50MTZCRSIsInJlYWRJbnQxNkxFIiwicmVhZFVJbnQxNkxFIiwicmVhZEludDMyQkUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50MzJMRSIsInJlYWRVSW50MzJMRSIsInJlYWRJbnRCRSIsInJlYWRVSW50QkUiLCJyZWFkSW50TEUiLCJyZWFkVUludExFIiwibXVsdGlwbGllciIsInN1YmFycmF5Iiwic3dhcDE2IiwiZmlyc3QiLCJzZWNvbmQiLCJzd2FwMzIiLCJ0aGlyZCIsImZvdXJ0aCIsInN3YXA2NCIsImZpZnRoIiwic2l4dGgiLCJzZXZlbnRoIiwiZWlnaHRoIiwidG9KU09OIiwiZGF0YSIsImJhc2U2NGVuY29kZSIsInRvQmxvYiIsImhleFNsaWNlIiwibGF0aW4xU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXNjaWkiLCJ1Y3MyU2xpY2UiLCJoZXhTdHIiLCJoZXgiLCJvdXQiLCJieXRlMSIsImJ5dGUyIiwiY29kZV91bml0IiwiZnJvbUNvZGVQb2ludCIsImNvcHlCdWZmZXIiLCJzcmNMZW5ndGgiLCJkZXN0SW5kZXgiLCJ2YWx1ZXMiLCJ3cml0ZSIsInN0cmluZyIsIndyaXRlRG91YmxlQkUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVGbG9hdExFIiwid3JpdGVJbnQ4IiwiY2hlY2tWYWx1ZSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MzJCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50QkUiLCJtaW5NYXhCYXNlIiwicG93IiwiYnl0ZVZhbHVlIiwid3JpdGVJbnRMRSIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnRMRSIsImFsbG9jVW5zYWZlU2xvdyIsInV0ZjhCeXRlTGVuZ3RoIiwiY2hhckF0IiwiZmxvb3IiLCJidWYyIiwiY29uY2F0IiwibGlzdCIsInRvdGFsTGVuZ3RoIiwicG9zaXRpb24iLCJJTlNQRUNUX01BWF9CWVRFUyIsInJlY3Vyc2VUaW1lcyIsImN0eCIsIm1heCIsImFjdHVhbE1heCIsInRyaW0iLCJleHRyYXMiLCJzaG93SGlkZGVuIiwicmVkdWNlIiwiY3JlYXRlIiwiaW5zcGVjdCIsImJyZWFrTGVuZ3RoIiwiY29tcGFjdCIsIkFycmF5QnVmZmVySXNWaWV3IiwiQnVmZmVyTW9kdWxlIiwidHJhbnNjb2RlIiwiX3NvdXJjZSIsIl9mcm9tRW5jb2RpbmciLCJfdG9FbmNvZGluZyIsImtNYXhMZW5ndGgiLCJrU3RyaW5nTWF4TGVuZ3RoIiwiY29uc3RhbnRzIiwiTUFYX0xFTkdUSCIsIk1BWF9TVFJJTkdfTEVOR1RIIiwic2luZ2xlQnl0ZSIsImJpdExlbmd0aCIsIm1heFBvc2l0aXZlVmFsdWUiLCJtYXhVbnNpZ25lZFZhbHVlIiwicmVsZWFzZSIsImVuZE9mZnNldCIsImJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCIsIm5vZGVNb2R1bGVzQ2hlY2tDb3VudGVyIiwiYnVmZmVyV2FybmluZyIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsIkJvb2xlYW5Qcm90b3R5cGUiLCJCb29sZWFuIiwiRGF0ZVByb3RvdHlwZSIsIkRhdGUiLCJFcnJvclByb3RvdHlwZSIsIk51bWJlclByb3RvdHlwZSIsIk1hcFByb3RvdHlwZSIsIlJlZ0V4cFByb3RvdHlwZSIsIlJlZ0V4cCIsIlN0cmluZ1Byb3RvdHlwZSIsIlNldFByb3RvdHlwZSIsIlNldCIsIlN5bWJvbFByb3RvdHlwZSIsImlzSW9zIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiYnVpbHRJbk9iamVjdHMiLCJpbnNwZWN0RGVmYXVsdE9wdGlvbnMiLCJzZWFsIiwiZGVwdGgiLCJjb2xvcnMiLCJjdXN0b21JbnNwZWN0Iiwic2hvd1Byb3h5IiwibWF4QXJyYXlMZW5ndGgiLCJzb3J0ZWQiLCJnZXR0ZXJzIiwia09iamVjdFR5cGUiLCJrQXJyYXlUeXBlIiwia0FycmF5RXh0cmFzVHlwZSIsInN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cCIsInN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyIiwic3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlIiwic3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGUiLCJrZXlTdHJSZWdFeHAiLCJudW1iZXJSZWdFeHAiLCJub2RlTW9kdWxlc1JlZ0V4cCIsImtNaW5MaW5lTGVuZ3RoIiwia1dlYWsiLCJrSXRlcmF0b3IiLCJrTWFwRW50cmllcyIsIm1ldGEiLCJnZXRVc2VyT3B0aW9ucyIsInN0eWxpemUiLCJ1c2VyT3B0aW9ucyIsIm9wdHMiLCJidWRnZXQiLCJpbmRlbnRhdGlvbkx2bCIsInNlZW4iLCJjdXJyZW50RGVwdGgiLCJzdHlsaXplTm9Db2xvciIsIm9wdEtleXMiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJjdXN0b20iLCJvcHRpb25zIiwiYXNzaWduIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImludmVyc2UiLCJ3aGl0ZSIsImdyZXkiLCJibGFjayIsImJsdWUiLCJjeWFuIiwiZ3JlZW4iLCJtYWdlbnRhIiwicmVkIiwieWVsbG93Iiwic3R5bGVzIiwic3BlY2lhbCIsIm51bWJlciIsImJpZ2ludCIsImJvb2xlYW4iLCJudWxsIiwic3ltYm9sIiwiZGF0ZSIsInJlZ2V4cCIsIm1vZHVsZSIsImFkZFF1b3RlcyIsInF1b3RlcyIsImVzY2FwZUZuIiwic3RyRXNjYXBlIiwiZXNjYXBlVGVzdCIsImVzY2FwZVJlcGxhY2UiLCJzaW5nbGVRdW90ZSIsImxhc3QiLCJwb2ludCIsInN0eWxlVHlwZSIsInN0eWxlIiwiY29sb3IiLCJnZXRFbXB0eUZvcm1hdEFycmF5IiwiZ2V0Q29uc3RydWN0b3JOYW1lIiwiX2N0eCIsImZpcnN0UHJvdG8iLCJkZXNjcmlwdG9yIiwiZ2V0UHJlZml4IiwidGFnIiwiZmFsbGJhY2siLCJnZXRLZXlzIiwic3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldEN0eFN0eWxlIiwiZmluZFR5cGVkQ29uc3RydWN0b3IiLCJjaGVjayIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwibGF6eU51bGxQcm90b3R5cGVDYWNoZSIsImNsYXp6V2l0aE51bGxQcm90b3R5cGUiLCJjYWNoZWRDbGFzcyIsIk51bGxQcm90b3R5cGUiLCJub1Byb3RvdHlwZUl0ZXJhdG9yIiwibmV3VmFsIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImZvcm1hdFJhdyIsInR5cGVkQXJyYXkiLCJmb3JtYXRQcmltaXRpdmUiLCJjb250ZXh0IiwibWF5YmVDdXN0b20iLCJyZXQiLCJyZXBlYXQiLCJjaXJjdWxhciIsInNpemUiLCJiYXNlIiwiZm9ybWF0dGVyIiwiYnJhY2VzIiwibm9JdGVyYXRvciIsImV4dHJhc1R5cGUiLCJwcmVmaXgiLCJmb3JtYXRBcnJheSIsImZvcm1hdFNldCIsImZvcm1hdE1hcCIsImZvcm1hdFR5cGVkQXJyYXkiLCJnZXRJdGVyYXRvckJyYWNlcyIsImZvcm1hdEl0ZXJhdG9yIiwiZ2V0RnVuY3Rpb25CYXNlIiwicmVnRXhwIiwiZ2V0VGltZSIsInRvSVNPU3RyaW5nIiwiZm9ybWF0RXJyb3IiLCJuYXRpdmVFcnJvclByb3BzIiwiZXZlcnkiLCJhcnJheVR5cGUiLCJmb3JtYXRBcnJheUJ1ZmZlciIsImZvcm1hdE51bWJlciIsImZvcm1hdFByb21pc2UiLCJmb3JtYXRXZWFrU2V0IiwiZm9ybWF0V2Vha0NvbGxlY3Rpb24iLCJmb3JtYXRXZWFrTWFwIiwiZ2V0Qm94ZWRCYXNlIiwic3BlY2lhbEl0ZXJhdG9yIiwiY29uc3RydWN0b3JOYW1lIiwiZm9ybWF0UHJvcGVydHkiLCJoYW5kbGVNYXhDYWxsU3RhY2tTaXplIiwicmVmZXJlbmNlIiwicG9wIiwiY29tcGFyYXRvciIsInNvcnQiLCJzcGxpY2UiLCJyZXMiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsIm5ld0xlbmd0aCIsImZuIiwidmFsdWVPZiIsInN0YWNrTGluZSIsImF0U3ltYm9sSW5kZXgiLCJzb3VyY2VQYXR0ZXJuIiwic3ltYm9sTmFtZSIsInNvdXJjZU1hdGNoIiwiZmlsZVBhdGgiLCJsaW5lTnVtYmVyIiwiY29sdW1uIiwiRmlsZXN5c3RlbSIsInJlc291cmNlc0RpcmVjdG9yeSIsInBvcyIsInN0YWNrU3RhcnQiLCJuZXdTdGFjayIsIm5vZGVNb2R1bGUiLCJleGVjIiwiaW5kZW50YXRpb24iLCJfdmFsdWUiLCJfcmVjdXJzZVRpbWVzIiwiZXh0cmEiLCJkZXNjIiwiZGlmZiIsImxhYmVsIiwic3AiLCJ0bXAiLCJwcmltaXRpdmUiLCJncm91cEFycmF5RWxlbWVudHMiLCJvdXRwdXRMZW5ndGgiLCJzZXBhcmF0b3JTcGFjZSIsImRhdGFMZW4iLCJhcHByb3hDaGFySGVpZ2h0cyIsImF2ZXJhZ2VCaWFzIiwic3FydCIsImJpYXNlZE1heCIsImNvbHVtbnMiLCJyb3VuZCIsIm1heExpbmVMZW5ndGgiLCJsaW5lTWF4TGVuZ3RoIiwiaiIsIm9yZGVyIiwicGFkZGluZyIsInBhZFN0YXJ0IiwiaXMiLCJmb3JtYXRCaWdJbnQiLCJmb3JtYXRTcGVjaWFsQXJyYXkiLCJlbXB0eUl0ZW1zIiwiZW5kaW5nIiwidmFsTGVuIiwiZWxlbWVudEZvcm1hdHRlciIsInYiLCJrIiwiZm9ybWF0U2V0SXRlcklubmVyIiwic3RhdGUiLCJmb3JtYXRNYXBJdGVySW5uZXIiLCJfa2V5cyIsImlzS2V5VmFsdWUiLCJjdXJyZW50RW50cnkiLCJpc0JlbG93QnJlYWtMZW5ndGgiLCJsbiIsImZvcm1hdFdpdGhPcHRpb25zIiwiZmlyc3RFcnJvckxpbmUiLCJDSVJDVUxBUl9FUlJPUl9NRVNTQUdFIiwidHJ5U3RyaW5naWZ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImEiLCJpbnNwZWN0T3B0aW9ucyIsInRlbXBTdHIiLCJsYXN0UG9zIiwibmV4dENoYXIiLCJ0ZW1wQXJnIiwiY29uc3RyIiwidGVtcE51bSIsInRlbXBJbnRlZ2VyIiwidGVtcEZsb2F0IiwicGFyc2VGbG9hdCIsIm5vb3AkMSIsImxvZ1RpbWUiLCJsb2dEYXRhIiwic3RhcnRUaW1lIiwiX3RpbWVzIiwiZHVyYXRpb24iLCJub3ciLCJsb2ciLCJrQ29sb3JJbnNwZWN0T3B0aW9ucyIsImtOb0NvbG9ySW5zcGVjdE9wdGlvbnMiLCJ0YWJsZVdhcm5lZCIsImNyZWF0ZVdyaXRlRXJyb3JIYW5kbGVyIiwic3RyZWFtIiwiX3dyaXRhYmxlU3RhdGUiLCJlcnJvckVtaXR0ZWQiLCJsaXN0ZW5lckNvdW50Iiwib25jZSIsIkNvbnNvbGUiLCJzdGRlcnIiLCJpZ25vcmVFcnJvcnMiLCJfYXBpTW9kdWxlIiwic3Rkb3V0IiwiX3N0ZG91dCIsIl9zdGRlcnIiLCJfaWdub3JlRXJyb3JzIiwiX3N0ZG91dEVycm9ySGFuZGxlciIsIl9zdGRlcnJFcnJvckhhbmRsZXIiLCJfY29sb3JNb2RlIiwiY29sb3JNb2RlIiwiX2luc3BlY3RPcHRpb25zIiwiX2NvdW50cyIsIl9ncm91cEluZGVudCIsIl93cml0ZVRvQ29uc29sZSIsImxldmVsIiwidXNlU3RkRXJyIiwiZXJyb3JIYW5kbGVyIiwicmVtb3ZlTGlzdGVuZXIiLCJpbmZvIiwid2FybiIsImRlYnVnIiwiY2xlYXIiLCJncm91cCIsImdyb3VwRW5kIiwiZGlyIiwiYXNzZXJ0IiwiY291bnQiLCJjb3VudFJlc2V0IiwiZGVsZXRlIiwidGltZSIsInRpbWVFbmQiLCJ3YXJuZWQiLCJ0aW1lTG9nIiwidGFibGUiLCJkaXJ4bWwiLCJncm91cENvbGxhcHNlZCIsImdsb2JhbENvbnNvbGUiLCJBUEkiLCJjb25zb2xlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwicHJvcGVydGllcyIsIkludGwiLCJEYXRlVGltZUZvcm1hdCIsIl9tYWtlVGlDcmVhdGlvblByb3BlcnRpZXNGcm9tIiwib2xkT3B0aW9ucyIsImRhdGVTdHlsZSIsIm1vbnRoIiwiZGF5IiwieWVhciIsImRlZmF1bHRPcHRpb25zIiwibG9jYWxlIiwiZm9ybWF0IiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwidGltZVN0eWxlIiwiaG91ciIsIm1pbnV0ZSIsInRvTG9jYWxlU3RyaW5nIiwiaGFzT3B0aW9uIiwid2Vla2RheSIsIm1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20iLCJzdXBwb3J0ZWRGb3JtYXRMb2NhbGVzRnVuY3Rpb24iLCJzdXBwb3J0ZWRMb2NhbGVzIiwiVGlDb2xsYXRvciIsIkxvY2FsZSIsImdldFN1cHBvcnRlZENvbGxhdG9yTG9jYWxlcyIsImNvbGxhdG9yIiwiQ29sbGF0b3IiLCJiaW5kIiwic3VwcG9ydGVkTG9jYWxlc09mIiwiVGlEYXRlVGltZUZvcm1hdCIsImdldFN1cHBvcnRlZERhdGVUaW1lRm9ybWF0TG9jYWxlcyIsIlRpTnVtYmVyRm9ybWF0IiwiZ2V0U3VwcG9ydGVkTnVtYmVyRm9ybWF0TG9jYWxlcyIsIk51bWJlckZvcm1hdCIsImdldENhbm9uaWNhbExvY2FsZXMiLCJsb2NhbGVDb21wYXJlIiwiY29tcGFyZVN0cmluZyIsImxvY2FsZXMiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsIm1ha2VMb3dlckNhc2UiLCJ0b0xvY2FsZVVwcGVyQ2FzZSIsIm1ha2VVcHBlckNhc2UiLCJiaW5kaW5ncyIsInJlZGlyZWN0cyIsImlzSGlqYWNrYWJsZU1vZHVsZUlkIiwicGF0aCIsImZpcnN0Q2hhciIsIm9yaWdpbmFsUmVxdWlyZSIsInJlcXVpcmUiLCJtYWluIiwibW9kdWxlSWQiLCJvcmlnaW5hbE1vZHVsZVJlcXVpcmUiLCJNb2R1bGUiLCJyZWdpc3RlciIsImJpbmRpbmciLCJyZWRpcmVjdCIsImZpbGVwYXRoIiwiVGl0YW5pdW0iLCJBY3Rpdml0eSIsImtleUNvdW50Iiwic2VyaWFsaXplZCIsIlByb3BlcnRpZXMiLCJBcHAiLCJudWxsT3JEZWZhdWx0VmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJwcm9wZXJ0eUdldHRlciIsImRlbGVnYXRlIiwiaGFzUHJvcGVydHkiLCJnZXR0ZXIiLCJnZXRMaXN0IiwiZ2V0T2JqZWN0IiwicGFyc2UiLCJnZXRTdHJpbmciLCJzZXRMaXN0Iiwic2V0T2JqZWN0Iiwic2V0U3RyaW5nIiwiQmxvYlByb3RvdHlwZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwid3JhcHBlZEdldFN0cmluZyIsImRlZmF1bHRWYWx1ZVR5cGUiLCJMIiwiUGVyc2lzdGVudEhhbmRsZSIsIm9iamVjdCIsImNlbGwiLCJsYXN0SWQiLCJvYmplY3RzIiwiZGlzcG9zZSIsIkhUVFBDbGllbnQiLCJOZXR3b3JrIiwiX3NlbmQiLCJzZW5kIiwiaGFuZGxlIiwib24iLCJrcm9sbCIsIkRCRyIsImlQaG9uZUNvbnN0YW50IiwiVUkiLCJpUGhvbmUiLCJBY3Rpdml0eUluZGljYXRvclN0eWxlIiwiQklHIiwiREFSSyIsIkFuaW1hdGlvblN0eWxlIiwiRkxJUF9GUk9NX0xFRlQiLCJQcm9ncmVzc0JhclN0eWxlIiwiU0lNUExFIiwiU3lzdGVtQnV0dG9uIiwiRkxFWElCTEVfU1BBQ0UiLCJESVNDTE9TVVJFIiwiU3lzdGVtQnV0dG9uU3R5bGUiLCJCQVIiLCJUYWJsZVZpZXdDZWxsU2VsZWN0aW9uU3R5bGUiLCJOT05FIiwiVGFibGVWaWV3U2VwYXJhdG9yU3R5bGUiLCJSb3dBbmltYXRpb25TdHlsZSIsIlRhYmxlVmlld1Njcm9sbFBvc2l0aW9uIiwiTUlERExFIiwiVGFibGVWaWV3U3R5bGUiLCJHUk9VUEVEIiwiTGlzdFZpZXciLCJkZWZhdWx0VGVtcGxhdGUiLCJoZWlnaHQiLCJjaGlsZFRlbXBsYXRlcyIsImJpbmRJZCIsImxlZnQiLCJ3aWR0aCIsInJpZ2h0IiwiY3JlYXRlTGlzdFZpZXciLCJ0ZW1wbGF0ZXMiLCJMSVNUX0lURU1fVEVNUExBVEVfREVGQVVMVCIsImN1cnJlbnRUZW1wbGF0ZSIsInByb2Nlc3NUZW1wbGF0ZSIsInByb2Nlc3NDaGlsZFRlbXBsYXRlcyIsImNlbGxQcm94eSIsImNyZWF0ZUxpc3RJdGVtIiwiZXZlbnRzIiwidGlQcm94eSIsImFkZEV2ZW50TGlzdGVuZXJzIiwiY2hpbGRQcm9wZXJ0aWVzIiwiY2hpbGQiLCJwcm94eVR5cGUiLCJjcmVhdGlvblByb3BlcnRpZXMiLCJjcmVhdGlvbkZ1bmN0aW9uIiwibG9va3VwIiwiY2hpbGRQcm94eSIsInByb3h5IiwiZXZlbnROYW1lIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxvb2t1cFByb3h5Q29uc3RydWN0b3IiLCJuYW1lc3BhY2UiLCJuYW1lc3BhY2VJbmRleCIsImxhc3RJbmRleE9mIiwicHJveHlOYW1lIiwicGFyZW50TmFtZXNwYWNlIiwic3Vic3RyaW5nIiwic2VnbWVudHMiLCJwYXJlbnRQcm94eSIsIm1ldGhvZCIsIndpZGdldCIsInBhcmFtZXRlcnMiLCJnZXRWaWV3IiwiTmF2aWdhdGlvbldpbmRvdyIsIkhFWF8zX1JFR0VYIiwiSEVYXzRfUkVHRVgiLCJIRVhfNl9SRUdFWCIsIkhFWF84X1JFR0VYIiwicGFkZGVkSGV4IiwiaW50ZWdlciIsIkNvbG9yIiwiciIsImciLCJiIiwiYWxwaGEiLCJpc09wYXF1ZSIsImFscGhhSGV4IiwiX3RvUkdCSGV4U3RyaW5nIiwidG9SR0JBSGV4U3RyaW5nIiwidG9BUkdCSGV4U3RyaW5nIiwidG9IZXgiLCJ0b1JHQkFTdHJpbmciLCJ0b0ZpeGVkIiwiZnJvbUhleDZTdHJpbmciLCJzdGFydEluZGV4IiwiZnJvbUhleDhTdHJpbmciLCJmcm9tU2VtYW50aWNDb2xvcnNFbnRyeSIsImVudHJ5IiwiaGFkQWxwaGEiLCJtIiwidXNlckludGVyZmFjZVN0eWxlIiwiVVNFUl9JTlRFUkZBQ0VfU1RZTEVfREFSSyIsIlNFTUFOVElDX0NPTE9SX1RZUEVfREFSSyIsIlNFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQiLCJjb2xvcnNldCIsImZldGNoU2VtYW50aWNDb2xvciIsImNvbG9yTmFtZSIsImNvbG9yc2V0RmlsZU5hbWUiLCJjb2xvcnNldEZpbGUiLCJnZXRGaWxlIiwiZXhpc3RzIiwiY29sb3JBcnJheSIsImNvbG9yVHlwZSIsImNvbG9yT2JqIiwiQW5kcm9pZCIsIlIiLCJUYWIiLCJjcmVhdGVUYWIiLCJ0YWIiLCJfd2luZG93Iiwib3BlbiIsInRhYk9wZW4iLCJnZXRXaW5kb3ciLCJzZXRXaW5kb3ciLCJfc2V0V2luZG93IiwiVGFiR3JvdXAiLCJWaWV3IiwiX2FkZCIsImFkZCIsIlRpV2luZG93IiwiX2NoaWxkcmVuIiwiX3JlbW92ZSIsInJlbW92ZSIsImNoaWxkcmVuIiwiY2hpbGRJbmRleCIsIlRpVmlldyIsImNyZWF0ZVdlYlZpZXciLCJjcmVhdGVXZWJWaWV3V3JhcHBlciIsIndlYlZpZXciLCJvbkNyZWF0ZVdpbmRvdyIsImlzVXNlckdlc3R1cmUiLCJ3aW4iLCJjcmVhdGVXaW5kb3ciLCJmdWxsc2NyZWVuIiwibmV3V2ViVmlldyIsIlRBRyIsIlNjcmlwdCIsIldpbmRvdyIsIl9jYWNoZWRBY3Rpdml0eVByb3h5IiwiYWN0aXZpdHlQcm94eUdldHRlciIsImFjdGl2aXR5UHJveHkiLCJfZ2V0V2luZG93QWN0aXZpdHlQcm94eSIsImdldEFjdGl2aXR5IiwiX29wZW4iLCJfY2xvc2VGcm9tQWN0aXZpdHlGb3JjZWRUb0Rlc3Ryb3kiLCJfdXJsQ29udGV4dCIsImRpc3Bvc2VDb250ZXh0IiwicG9zdFdpbmRvd0NyZWF0ZWQiLCJfaW50ZXJuYWxBY3Rpdml0eSIsImV4dGVuZCIsIl9hZGRMaXN0ZW5lciIsImVtaXR0ZXIiLCJsaXN0ZW5lciIsInByZXBlbmQiLCJfZXZlbnRzVG9MaXN0ZW5lcnMiLCJuZXdMaXN0ZW5lciIsImVtaXQiLCJldmVudExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsInciLCJvbmNlV3JhcCIsIndyYXBwZXIiLCJ3cmFwcGVkRnVuYyIsIndyYXBwZXJUaGlzIiwiYm91bmQiLCJFdmVudEVtaXR0ZXIiLCJfbWF4TGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwiZm91bmRJbmRleCIsInVud3JhcHBlZExpc3RlbmVyIiwib2ZmIiwiZXZlbnROYW1lcyIsImxpc3RlbmVycyIsInJhdyIsImwiLCJyYXdMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwibiIsInJlbW92ZUFsbExpc3RlbmVycyIsIm5hbWVzIiwiYXNzZXJ0QXJndW1lbnRUeXBlIiwidHlwZW5hbWUiLCJzdGFuZGFyZGl6ZUFyY2giLCJvcmlnaW5hbCIsInByb2Nlc3MkMSIsImFib3J0IiwiYXJjaCIsImFyY2hpdGVjdHVyZSIsImFyZ3YiLCJjaGFubmVsIiwiY2hkaXIiLCJjb25maWciLCJjb25uZWN0ZWQiLCJjcHVVc2FnZSIsInVzZXIiLCJzeXN0ZW0iLCJjd2QiLCJfX2Rpcm5hbWUiLCJhc3NldHMiLCJqc29uIiwicmVhZEFzc2V0IiwiZGVwbG95RGF0YSIsImRlYnVnZ2VyUG9ydCIsImRpc2Nvbm5lY3QiLCJkbG9wZW4iLCJ3YXJuaW5nIiwiY3RvciIsImRldGFpbCIsImlzRGVwcmVjYXRpb24iLCJub0RlcHJlY2F0aW9uIiwidGhyb3dEZXByZWNhdGlvbiIsImxvYWRFbnZKc29uIiwianNvbkZpbGUiLCJyZWFkIiwidGV4dCIsImVudiIsImV4ZWNBcmd2IiwiZXhlY1BhdGgiLCJleGl0IiwiZXhpdENvZGUiLCJwaWQiLCJwbGF0Zm9ybSIsInBwaWQiLCJpc1RUWSIsImNodW5rIiwiY2FsbGJhY2siLCJ0aXRsZSIsInRyYWNlRGVwcmVjYXRpb24iLCJ1bWFzayIsInVwdGltZSIsImRpZmZNcyIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm1vZHVsZXMiLCJ2OCIsImpzYyIsIldBUk5JTkdfUFJFRklYIiwidW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayIsImhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrIiwic2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2siLCJldmVudCIsImJhY2t0cmFjZSIsImZpbGVOYW1lIiwic291cmNlTmFtZSIsImNvbHVtbk51bWJlciIsImxpbmVPZmZzZXQiLCJDYWxsYmFja1dpdGhBcmdzIiwiZnVuYyIsInJ1biIsImZ1biIsInRpY2tRdWV1ZSIsImltbWVkaWF0ZVF1ZXVlIiwiZHJhaW5pbmdUaWNrUXVldWUiLCJkcmFpblF1ZXVlc1RpbWVvdXQiLCJkcmFpblRpY2tRdWV1ZSIsInRpY2siLCJzaGlmdCIsImRyYWluUXVldWVzIiwiaW1tZWRpYXRlc1JlbWFpbmluZyIsInByb2Nlc3NJbW1lZGlhdGVRdWV1ZSIsInNldFRpbWVvdXQiLCJpbW1lZGlhdGVEZWFkbGluZSIsImltbWVkaWF0ZSIsIm5leHRUaWNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJGT1JXQVJEX1NMQVNIIiwiQkFDS1dBUkRfU0xBU0giLCJpc1dpbmRvd3NEZXZpY2VOYW1lIiwiY2hhckNvZGUiLCJpc0Fic29sdXRlIiwiaXNQb3NpeCIsInRoaXJkQ2hhciIsImRpcm5hbWUiLCJmcm9tSW5kZXgiLCJoYWRUcmFpbGluZyIsImV4dG5hbWUiLCJlbmRJbmRleCIsImxhc3RJbmRleFdpbjMyU2VwYXJhdG9yIiwiY2hhciIsImJhc2VuYW1lIiwiZXh0IiwibGFzdENoYXJDb2RlIiwibm9ybWFsaXplIiwiaXNXaW5kb3dzIiwiaGFkTGVhZGluZyIsImlzVU5DIiwicGFydHMiLCJzZWdtZW50Iiwibm9ybWFsaXplZCIsImFzc2VydFNlZ21lbnQiLCJwYXRocyIsInJlc29sdmVkIiwiaGl0Um9vdCIsInJlbGF0aXZlIiwidG8iLCJ1cENvdW50IiwicmVtYWluaW5nUGF0aCIsInJvb3QiLCJiYXNlTGVuZ3RoIiwidG9TdWJ0cmFjdCIsImZpcnN0Q2hhckNvZGUiLCJ0aGlyZENoYXJDb2RlIiwicGF0aE9iamVjdCIsInRvTmFtZXNwYWNlZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJXaW4zMlBhdGgiLCJzZXAiLCJkZWxpbWl0ZXIiLCJQb3NpeFBhdGgiLCJ3aW4zMiIsInBvc2l4IiwiUG9zaXhDb25zdGFudHMiLCJVVl9VRFBfUkVVU0VBRERSIiwiZXJybm8iLCJFMkJJRyIsIkVBQ0NFUyIsIkVBRERSSU5VU0UiLCJFQUREUk5PVEFWQUlMIiwiRUFGTk9TVVBQT1JUIiwiRUFHQUlOIiwiRUFMUkVBRFkiLCJFQkFERiIsIkVCQURNU0ciLCJFQlVTWSIsIkVDQU5DRUxFRCIsIkVDSElMRCIsIkVDT05OQUJPUlRFRCIsIkVDT05OUkVGVVNFRCIsIkVDT05OUkVTRVQiLCJFREVBRExLIiwiRURFU1RBRERSUkVRIiwiRURPTSIsIkVEUVVPVCIsIkVFWElTVCIsIkVGQVVMVCIsIkVGQklHIiwiRUhPU1RVTlJFQUNIIiwiRUlEUk0iLCJFSUxTRVEiLCJFSU5QUk9HUkVTUyIsIkVJTlRSIiwiRUlOVkFMIiwiRUlPIiwiRUlTQ09OTiIsIkVJU0RJUiIsIkVMT09QIiwiRU1GSUxFIiwiRU1MSU5LIiwiRU1TR1NJWkUiLCJFTVVMVElIT1AiLCJFTkFNRVRPT0xPTkciLCJFTkVURE9XTiIsIkVORVRSRVNFVCIsIkVORVRVTlJFQUNIIiwiRU5GSUxFIiwiRU5PQlVGUyIsIkVOT0RBVEEiLCJFTk9ERVYiLCJFTk9FTlQiLCJFTk9FWEVDIiwiRU5PTENLIiwiRU5PTElOSyIsIkVOT01FTSIsIkVOT01TRyIsIkVOT1BST1RPT1BUIiwiRU5PU1BDIiwiRU5PU1IiLCJFTk9TVFIiLCJFTk9TWVMiLCJFTk9UQ09OTiIsIkVOT1RESVIiLCJFTk9URU1QVFkiLCJFTk9UU09DSyIsIkVOT1RTVVAiLCJFTk9UVFkiLCJFTlhJTyIsIkVPUE5PVFNVUFAiLCJFT1ZFUkZMT1ciLCJFUEVSTSIsIkVQSVBFIiwiRVBST1RPIiwiRVBST1RPTk9TVVBQT1JUIiwiRVBST1RPVFlQRSIsIkVSQU5HRSIsIkVST0ZTIiwiRVNQSVBFIiwiRVNSQ0giLCJFU1RBTEUiLCJFVElNRSIsIkVUSU1FRE9VVCIsIkVUWFRCU1kiLCJFV09VTERCTE9DSyIsIkVYREVWIiwic2lnbmFscyIsIlNJR0hVUCIsIlNJR0lOVCIsIlNJR1FVSVQiLCJTSUdJTEwiLCJTSUdUUkFQIiwiU0lHQUJSVCIsIlNJR0lPVCIsIlNJR0JVUyIsIlNJR0ZQRSIsIlNJR0tJTEwiLCJTSUdVU1IxIiwiU0lHU0VHViIsIlNJR1VTUjIiLCJTSUdQSVBFIiwiU0lHQUxSTSIsIlNJR1RFUk0iLCJTSUdDSExEIiwiU0lHQ09OVCIsIlNJR1NUT1AiLCJTSUdUU1RQIiwiU0lHVFRJTiIsIlNJR1RUT1UiLCJTSUdVUkciLCJTSUdYQ1BVIiwiU0lHWEZTWiIsIlNJR1ZUQUxSTSIsIlNJR1BST0YiLCJTSUdXSU5DSCIsIlNJR0lPIiwiU0lHSU5GTyIsIlNJR1NZUyIsInByaW9yaXR5IiwiUFJJT1JJVFlfTE9XIiwiUFJJT1JJVFlfQkVMT1dfTk9STUFMIiwiUFJJT1JJVFlfTk9STUFMIiwiUFJJT1JJVFlfQUJPVkVfTk9STUFMIiwiUFJJT1JJVFlfSElHSCIsIlBSSU9SSVRZX0hJR0hFU1QiLCJPUyIsIkVPTCIsImNwdXMiLCJwcm9jZXNzb3JDb3VudCIsImFycmF5IiwibW9kZWwiLCJzcGVlZCIsInRpbWVzIiwibmljZSIsInN5cyIsImlkbGUiLCJpcnEiLCJlbmRpYW5uZXNzIiwiZ2V0TmF0aXZlQnl0ZU9yZGVyIiwiTElUVExFX0VORElBTiIsImZyZWVtZW0iLCJhdmFpbGFibGVNZW1vcnkiLCJnZXRQcmlvcml0eSIsImhvbWVkaXIiLCJhcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnkiLCJob3N0bmFtZSIsImFkZHJlc3MiLCJsb2FkYXZnIiwibmV0d29ya0ludGVyZmFjZXMiLCJzZXRQcmlvcml0eSIsInRtcGRpciIsInRlbXBEaXJlY3RvcnkiLCJ0b3RhbG1lbSIsInRvdGFsTWVtb3J5IiwidXNlckluZm8iLCJ1aWQiLCJnaWQiLCJ1c2VybmFtZSIsInNoZWxsIiwidHR5IiwiaXNhdHR5IiwiUmVhZFN0cmVhbSIsIldyaXRlU3RyZWFtIiwiTU9OVEhTIiwidXRpbCIsImlzQm9vbGVhbiIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc1ByaW1pdGl2ZSIsImlzU3RyaW5nIiwiaXNTeW1ib2wiLCJpc1VuZGVmaW5lZCIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJwcmludCIsInB1dHMiLCJpbmhlcml0cyIsInN1cGVyQ29uc3RydWN0b3IiLCJwcm9taXNpZnkiLCJ3cmFwcGVkIiwiY2FsbGJhY2tpZnkiLCJwcm9taXNlIiwidGhlbiIsImNhdGNoIiwid3JhcHBlZEVycm9yIiwicmVhc29uIiwiZGVwcmVjYXRlIiwibm9vcCIsImRlYnVnbG9nIiwiREVGQVVMVF9NRVNTQUdFUyIsImRlZXBTdHJpY3RFcXVhbCIsInN0cmljdEVxdWFsIiwiZGVlcEVxdWFsIiwiZXF1YWwiLCJub3REZWVwU3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsIm5vdERlZXBFcXVhbCIsIm5vdEVxdWFsIiwiQ09NUEFSRV9UWVBFIiwiU1RSSUNUTkVTUyIsIlN0cmljdCIsIkxvb3NlIiwiQXNzZXJ0aW9uRXJyb3IiLCJvcGVyYXRvciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJvayIsInRocm93RXJyb3IiLCJjb21wYXJlTWFwcyIsInN0cmljdG5lc3MiLCJyZWZlcmVuY2VzIiwibG9vc2VDaGVja3MiLCJleHBlY3RlZEtleSIsImV4cGVjdGVkVmFsdWUiLCJmb3VuZCIsImNvbXBhcmVTZXRzIiwiYWN0dWFsVGFnIiwiZXhwZWN0ZWRUYWciLCJhY3R1YWxQcm90b3R5cGUiLCJleHBlY3RlZFByb3RvdHlwZSIsImNvbXBhcmlzb24iLCJmbGFncyIsImFjdHVhbEtleXMiLCJleHBlY3RlZEtleXMiLCJhY3R1YWxTeW1ib2xzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiYWN0dWFsSXNFbnVtZXJhYmxlIiwiZXhwZWN0ZWRJc0VudW1lcmFibGUiLCJtZW1vaXplZEFjdHVhbCIsIm1lbW9pemVkRXhwZWN0ZWQiLCJOT19FWENFUFRJT04iLCJleGVjdXRlIiwiaXNQcm9taXNlTGlrZSIsImV4ZWN1dGVQcm9taXNlIiwiZm5UeXBlIiwidGhyb3dzIiwiY2hlY2tFcnJvciIsInJlamVjdHMiLCJhc3luY0ZuIiwiZG9lc05vdFRocm93IiwiZG9lc05vdFJlamVjdCIsImlzUHJvdG90eXBlT2YiLCJpZkVycm9yIiwic3RyaWN0IiwiU3RyaW5nRGVjb2RlciIsIl9pbXBsIiwiVXRmOFN0cmluZ0RlY29kZXIiLCJVdGYxNlN0cmluZ0RlY29kZXIiLCJCYXNlNjRTdHJpbmdEZWNvZGVyIiwiU3RyaW5nRGVjb2RlckltcGwiLCJieXRlQ291bnQiLCJjaGFyTGVuZ3RoIiwiTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwiLCJieXRlc1BlckNoYXIiLCJpbmNvbXBsZXRlIiwiX2NoZWNrSW5jb21wbGV0ZUJ5dGVzIiwiX2J1ZmZlciIsIl9pbmNvbXBsZXRlRW5kIiwiX2luY29tcGxldGVCdWZmZXJFbXB0aWVkIiwiYnl0ZXNDb3BpZWQiLCJpbmNvbXBsZXRlQ2hhckRhdGEiLCJieXRlc05lZWRlZCIsImluY29tcGxldGVDaGFySW5kZXgiLCJieXRlc1RvQ29weSIsImNoZWNrQ2hhckxlbmd0aEZvclVURjgiLCJtb2R1bG8iLCJieXRlIiwiU3RyaW5nRGVjb2RlciQxIiwicHJpbnRlZFdhcm5pbmdzIiwib25lVGltZVdhcm5pbmciLCJ1bnN1cHBvcnRlZE5vb3AiLCJtb2R1bGVOYW1lIiwiZnFuIiwiYXN5bmNVbnN1cHBvcnRlZE5vb3AiLCJtYXliZUNhbGxiYWNrIiwiQ09QWV9GSUxFX0NIVU5LX1NJWkUiLCJmaWxlRGVzY3JpcHRvcnMiLCJmaWxlRGVzY3JpcHRvckNvdW50IiwiRkxBR1NfVE9fVElfTU9ERSIsIk1PREVfQVBQRU5EIiwiTU9ERV9XUklURSIsInBlcm1pc3Npb25EZW5pZWQiLCJzeXNjYWxsIiwibWFrZUVycm9yIiwibm9TdWNoRmlsZSIsImZpbGVBbHJlYWR5RXhpc3RzIiwibm90QURpcmVjdG9yeSIsImRpcmVjdG9yeU5vdEVtcHR5IiwiaWxsZWdhbE9wZXJhdGlvbk9uQURpcmVjdG9yeSIsImZzIiwiT19SRE9OTFkiLCJPX1dST05MWSIsIk9fUkRXUiIsIlNfSUZNVCIsIlNfSUZSRUciLCJTX0lGRElSIiwiU19JRkNIUiIsIlNfSUZCTEsiLCJTX0lGSUZPIiwiU19JRkxOSyIsIlNfSUZTT0NLIiwiT19DUkVBVCIsIk9fRVhDTCIsIk9fTk9DVFRZIiwiT19UUlVOQyIsIk9fQVBQRU5EIiwiT19ESVJFQ1RPUlkiLCJPX05PRk9MTE9XIiwiT19TWU5DIiwiT19EU1lOQyIsIk9fU1lNTElOSyIsIk9fTk9OQkxPQ0siLCJTX0lSV1hVIiwiU19JUlVTUiIsIlNfSVdVU1IiLCJTX0lYVVNSIiwiU19JUldYRyIsIlNfSVJHUlAiLCJTX0lXR1JQIiwiU19JWEdSUCIsIlNfSVJXWE8iLCJTX0lST1RIIiwiU19JV09USCIsIlNfSVhPVEgiLCJGX09LIiwiUl9PSyIsIldfT0siLCJYX09LIiwiVVZfRlNfQ09QWUZJTEVfRVhDTCIsIkNPUFlGSUxFX0VYQ0wiLCJTdGF0cyIsIl9maWxlIiwiZGV2IiwiaW5vIiwibmxpbmsiLCJyZGV2IiwiYmxrc2l6ZSIsImJsb2NrcyIsImF0aW1lTXMiLCJtdGltZU1zIiwiY3RpbWVNcyIsImJpcnRodGltZU1zIiwiYXRpbWUiLCJtdGltZSIsImN0aW1lIiwiYmlydGh0aW1lIiwiZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUiLCJjcmVhdGVkQXQiLCJtb2RpZmllZEF0IiwiY2VpbCIsImlzRmlsZSIsImlzRGlyZWN0b3J5IiwiaXNCbG9ja0RldmljZSIsImlzQ2hhcmFjdGVyRGV2aWNlIiwiaXNTeW1ib2xpY0xpbmsiLCJzeW1ib2xpY0xpbmsiLCJpc0ZJRk8iLCJpc1NvY2tldCIsImFjY2VzcyIsImFjY2Vzc1N5bmMiLCJmaWxlSGFuZGxlIiwiZXhlY3V0YWJsZSIsImFwcGVuZEZpbGUiLCJmaWxlIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImZsYWciLCJ3cml0ZUZpbGUiLCJhcHBlbmRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJjaG1vZCIsImNobW9kU3luYyIsImNob3duIiwiY2hvd25TeW5jIiwiZmQiLCJjbG9zZVN5bmMiLCJzdHJlYW1Gb3JEZXNjcmlwdG9yIiwiY29weUZpbGUiLCJzcmNGaWxlIiwic3JjU3RyZWFtIiwiZGVzdEZpbGUiLCJkZXN0U3RyZWFtIiwicGlwZSIsImNvcHlGaWxlU3luYyIsImV4aXN0c1N5bmMiLCJmY2htb2QiLCJmY2htb2RTeW5jIiwiZmNob3duIiwiZmNob3duU3luYyIsImZkYXRhc3luYyIsImZkYXRhc3luY1N5bmMiLCJmc3RhdCIsInN0YXRzIiwiZnN0YXRTeW5jIiwiX29wdGlvbnMiLCJwYXRoRm9yRmlsZURlc2NyaXB0b3IiLCJzdGF0U3luYyIsImxzdGF0Iiwic3RhdCIsImxzdGF0U3luYyIsIm1rZGlyIiwicmVjdXJzaXZlIiwibWtkaXJTeW5jIiwidGlGaWxlIiwiY3JlYXRlRGlyZWN0b3J5IiwibWtkdGVtcCIsInRyeU1rZHRlbXAiLCJnZW5lcmF0ZWQiLCJyYW5kb21DaGFyYWN0ZXJzIiwibWtkdGVtcFN5bmMiLCJyZXRyeUNvdW50IiwiTUFYX1JFVFJJRVMiLCJmaWxlRGVzY3JpcHRvciIsIm9wZW5TeW5jIiwiX21vZGUiLCJjcmVhdGVGaWxlIiwicGFyZW50IiwidGlNb2RlIiwiY3JlYXRlRmlsZURlc2NyaXB0b3IiLCJ0aUZpbGVTdHJlYW0iLCJyZWFkT2JqIiwic3VjY2VzcyIsImJ5dGVzUHJvY2Vzc2VkIiwicmVhZFN5bmMiLCJfcG9zaXRpb24iLCJmaWxlU3RyZWFtIiwicmVhZGRpciIsInJlYWRkaXJTeW5jIiwid2l0aEZpbGVUeXBlcyIsImxpc3RpbmciLCJnZXREaXJlY3RvcnlMaXN0aW5nIiwicmVhZEZpbGVQb3N0T3BlbiIsImZpbGVTaXplIiwic291cmNlU3RyZWFtIiwicmVhZEFsbE9iaiIsInJlYWRGaWxlIiwid2FzRmlsZURlc2NyaXB0b3IiLCJoYW5kbGVCdWZmZXIiLCJlbmNvZGVCdWZmZXIiLCJyZWFkRmlsZVN5bmMiLCJyZWFscGF0aCIsInJlc3VsdEV4aXN0cyIsInBhcnRpYWxGaWxlUGF0aCIsInRyeVBhdGgiLCJwYXJ0aWFsRXhpc3RzIiwibmF0aXZlIiwicmVhbHBhdGhTeW5jIiwicmVuYW1lIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJyZW5hbWVTeW5jIiwidGVtcFBhdGgiLCJtb3ZlIiwidW5saW5rIiwiX2VyciIsInRtcEZpbGUiLCJybWRpciIsInJtZGlyU3luYyIsImRlbGV0ZURpcmVjdG9yeSIsInN1YkZpbGVzIiwic3ltbGluayIsInN5bWxpbmtTeW5jIiwidHJ1bmNhdGUiLCJieXRlc1JlYWQiLCJ0cnVuY2F0ZVN5bmMiLCJ1bmxpbmtTeW5jIiwiZGVsZXRlRmlsZSIsInVud2F0Y2hGaWxlIiwidXRpbWVzIiwidXRpbWVzU3luYyIsIndhdGNoIiwid2F0Y2hGaWxlIiwiZmluaXNoIiwid3JpdGVTeW5jIiwid3JpdGVUaUZpbGVTdHJlYW0iLCJ3cml0ZU9iaiIsIndyaXRlQnVmZmVyIiwid3JpdGVTdHJpbmciLCJ3cml0ZUJ1ZmZlclN5bmMiLCJ3cml0ZVN0cmluZ1N5bmMiLCJGaWxlRGVzY3JpcHRvciIsInBpcGVWaWFXcml0ZVN0cmVhbSIsIndyaXRlU3RyZWFtIiwicG9pbnRlciIsImRlZmF1bHRzIiwib3B0aW9uc1R5cGUiLCJtZXJnZWQiLCJjYiIsIl9lbmNvZGluZyIsInJhbmRvbSIsIl9vcHRzIiwiUmVhZGFibGUiLCJyZWFkYWJsZSIsIl9yZWFkIiwiZGVzdHJveSIsIl9kZXN0cm95IiwiX24iLCJXcml0YWJsZSIsImlzRHVwbGV4IiwiRHVwbGV4IiwiX3dyaXRlIiwid3JpdGV2IiwiX3dyaXRldiIsImZpbmFsIiwiX2ZpbmFsIiwiYWxsb3dIYWxmT3BlbiIsIndyaXRhYmxlTWV0aG9kcyIsIlRyYW5zZm9ybSIsInRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJmbHVzaCIsIl9mbHVzaCIsImZldGNoU2NyaXB0c0Zyb21Kc29uIiwiSlNPTl9GSUxFX05BTUUiLCJzZXR0aW5ncyIsInNjcmlwdHMiLCJmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5IiwicmVzb3VyY2VEaXJlY3RvcnkiLCJyZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGgiLCJuYXRpdmVQYXRoIiwiYm9vdHN0cmFwU2NyaXB0cyIsImxvYWRGcm9tIiwiZmlsZU5hbWVBcnJheSIsInNlYXJjaCIsImJvb3RzdHJhcFBhdGgiLCJsb2FkQXN5bmMiLCJmaW5pc2hlZCIsImxvYWRCb290c3RyYXBTY3JpcHRzIiwiYm9vdHN0cmFwSW5kZXgiLCJkb0xvYWQiLCJib290c3RyYXAiLCJvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkIiwiZmlyZUV2ZW50Il0sInNvdXJjZVJvb3QiOiIvVXNlcnMva3VyeXNoY2h1ay9MaWJyYXJ5L0FwcGxpY2F0aW9uIFN1cHBvcnQvVGl0YW5pdW0vbW9iaWxlc2RrL29zeC8xMi41LjEuR0EvY29tbW9uL1Jlc291cmNlcy9hbmRyb2lkIiwic291cmNlcyI6WyJ0aS5tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBxdW90ZS1wcm9wcyAqL1xuLyogZ2xvYmFscyBPU19BTkRST0lELCBPU19JT1MgKi9cblxuLy8gQWRkIGdsb2JhbCBjb25zdGFudHMuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb21tb25qc0dsb2JhbCwge1xuICAnT1NfQU5EUk9JRCc6IHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgJ09TX0lPUyc6IHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIE9TX1ZFUlNJT05fTUFKT1I6IHtcbiAgICB2YWx1ZTogVGkuUGxhdGZvcm0udmVyc2lvbk1ham9yLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPU19WRVJTSU9OX01JTk9SOiB7XG4gICAgdmFsdWU6IFRpLlBsYXRmb3JtLnZlcnNpb25NaW5vcixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgT1NfVkVSU0lPTl9QQVRDSDoge1xuICAgIHZhbHVlOiBUaS5QbGF0Zm9ybS52ZXJzaW9uUGF0Y2gsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH1cbn0pO1xuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb25zdCBrTm9kZU1vZHVsZXNSRSA9IC9eKC4qKVtcXFxcL11ub2RlX21vZHVsZXNbXFxcXC9dLztcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpO1xuY29uc3QgaXNCdWZmZXIgPSBTeW1ib2wuZm9yKCd0aXRhbml1bS5idWZmZXIuaXNCdWZmZXInKTtcbmNvbnN0IGNvbG9yUmVnRXhwID0gL1xcdTAwMWJcXFtcXGRcXGQ/bS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuZnVuY3Rpb24gcmVtb3ZlQ29sb3JzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY29sb3JSZWdFeHAsICcnKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICAvLyBBbiBlcnJvciBjb3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB3aGlsZSBub3QgYmVpbmcgYSBuYXRpdmUgZXJyb3JcbiAgLy8gb3IgY291bGQgYmUgZnJvbSBhIGRpZmZlcmVudCByZWFsbSBhbmQgbm90IGJlIGluc3RhbmNlIG9mIEVycm9yIGJ1dCBzdGlsbFxuICAvLyBiZSBhIG5hdGl2ZSBlcnJvci5cbiAgcmV0dXJuIGlzTmF0aXZlRXJyb3IoZSkgfHwgZSBpbnN0YW5jZW9mIEVycm9yO1xufVxubGV0IGdldFN0cnVjdHVyZWRTdGFjaztcbmNsYXNzIFN0YWNrVHJhY2VFcnJvciBleHRlbmRzIEVycm9yIHt9XG5TdGFja1RyYWNlRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoZXJyLCB0cmFjZSkgPT4gdHJhY2U7XG5TdGFja1RyYWNlRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gSW5maW5pdHk7XG5mdW5jdGlvbiBpc0luc2lkZU5vZGVNb2R1bGVzKCkge1xuICBpZiAoZ2V0U3RydWN0dXJlZFN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICBnZXRTdHJ1Y3R1cmVkU3RhY2sgPSAoKSA9PiBuZXcgU3RhY2tUcmFjZUVycm9yKCkuc3RhY2s7XG4gIH1cbiAgbGV0IHN0YWNrID0gZ2V0U3RydWN0dXJlZFN0YWNrKCk7XG5cbiAgLy8gc3RhY2sgaXMgb25seSBhbiBhcnJheSBvbiB2OCwgdHJ5IHRvIGNvbnZlcnQgbWFudWFsbHkgaWYgc3RyaW5nXG4gIGlmICh0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc3RhY2tGcmFtZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KC9cXG4vKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IGxpbmVJbmZvID0gbGluZS5tYXRjaCgvKC4qKUAoLiopOihcXGQrKTooXFxkKykvKTtcbiAgICAgIGlmIChsaW5lSW5mbykge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGxpbmVJbmZvWzJdLnJlcGxhY2UoJ2ZpbGU6Ly8nLCAnJyk7XG4gICAgICAgIHN0YWNrRnJhbWVzLnB1c2goe1xuICAgICAgICAgIGdldEZpbGVOYW1lOiAoKSA9PiBmaWxlbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sgPSBzdGFja0ZyYW1lcztcbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgc3RhY2sgZnJhbWVzIGFuZCBsb29rIGZvciB0aGUgZmlyc3Qgb25lIG5vdCBjb21pbmdcbiAgLy8gZnJvbSBpbnNpZGUgTm9kZS5qcyBpdHNlbGY6XG4gIGlmIChBcnJheS5pc0FycmF5KHN0YWNrKSkge1xuICAgIGZvciAoY29uc3QgZnJhbWUgb2Ygc3RhY2spIHtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gZnJhbWUuZ2V0RmlsZU5hbWUoKTtcbiAgICAgIC8vIElmIGEgZmlsZW5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCAvIG9yIGNvbnRhaW4gXFwsXG4gICAgICAvLyBpdCdzIGxpa2VseSBmcm9tIE5vZGUuanMgY29yZS5cbiAgICAgIGlmICghL15cXC98XFxcXC8udGVzdChmaWxlbmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4ga05vZGVNb2R1bGVzUkUudGVzdChmaWxlbmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGpvaW4kMShvdXRwdXQsIHNlcGFyYXRvcikge1xuICBsZXQgc3RyID0gJyc7XG4gIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gb3V0cHV0Lmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgLy8gSXQgaXMgZmFzdGVyIG5vdCB0byB1c2UgYSB0ZW1wbGF0ZSBzdHJpbmcgaGVyZVxuICAgICAgc3RyICs9IG91dHB1dFtpXTtcbiAgICAgIHN0ciArPSBzZXBhcmF0b3I7XG4gICAgfVxuICAgIHN0ciArPSBvdXRwdXRbbGFzdEluZGV4XTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmLmNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmNvbnN0IEFMTF9QUk9QRVJUSUVTJDIgPSAwO1xuY29uc3QgT05MWV9FTlVNRVJBQkxFJDIgPSAyO1xuY29uc3QgcHJvcGVydHlGaWx0ZXIgPSB7XG4gIEFMTF9QUk9QRVJUSUVTOiBBTExfUFJPUEVSVElFUyQyLFxuICBPTkxZX0VOVU1FUkFCTEU6IE9OTFlfRU5VTUVSQUJMRSQyXG59O1xuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKG9iaiwgZmlsdGVyKSB7XG4gIGNvbnN0IHByb3BzID0gW107XG4gIGNvbnN0IGtleXMgPSBmaWx0ZXIgPT09IE9OTFlfRU5VTUVSQUJMRSQyID8gT2JqZWN0LmtleXMob2JqKSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFpc0FsbERpZ2l0cyhrZXkpKSB7XG4gICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGlzQWxsRGlnaXRzKHMpIHtcbiAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSk7XG5jb25zdCBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcgPSB1bmN1cnJ5VGhpcyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFR5cGVkQXJyYXlQcm90b3R5cGUkMSwgU3ltYm9sLnRvU3RyaW5nVGFnKS5nZXQpO1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgbmFtZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gYFtvYmplY3QgJHtuYW1lfV1gO1xufVxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0FyZ3VtZW50c09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXJndW1lbnRzJyk7XG59XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdBcnJheUJ1ZmZlcicpO1xufVxuXG4vLyBDYWNoZWQgdG8gbWFrZSBzdXJlIG5vIHVzZXJsYW5kIGNvZGUgY2FuIHRhbXBlciB3aXRoIGl0LlxuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXN5bmNGdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdCb29sZWFuJyk7XG59XG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc051bWJlck9iamVjdCh2YWx1ZSkgfHwgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8IGlzQm9vbGVhbk9iamVjdCh2YWx1ZSlcbiAgLy8gfHwgaXNCaWdJbnRPYmplY3QodmFsdWUpXG4gIHx8IGlzU3ltYm9sT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0RhdGFWaWV3Jyk7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0RhdGUnKTtcbn1cblxuLy8gQHRvZG8gaXNFeHRlcm5hbFxuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0dlbmVyYXRvckZ1bmN0aW9uJyk7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnR2VuZXJhdG9yJyk7XG59XG5mdW5jdGlvbiBpc0ludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0ludDhBcnJheSc7XG59XG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzSW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0ludDMyQXJyYXknO1xufVxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ01hcCcpO1xufVxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTWFwIEl0ZXJhdG9yJztcbn1cblxuLy8gQHRvZG8gaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcblxuZnVuY3Rpb24gaXNOYXRpdmVFcnJvcih2YWx1ZSkge1xuICAvLyBpZiBub3QgYW4gaW5zdGFuY2Ugb2YgYW4gRXJyb3IsIGRlZmluaXRlbHkgbm90IGEgbmF0aXZlIGVycm9yXG4gIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdmFsdWUgfHwgIXZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBbJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdSYW5nZUVycm9yJywgJ1JlZmVyZW5jZUVycm9yJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvciddLmluY2x1ZGVzKHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ051bWJlcicpO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdQcm9taXNlJyk7XG59XG5cbi8vIEB0b2RvIGlzUHJveHlcblxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1JlZ0V4cCcpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1NldCcpO1xufVxuZnVuY3Rpb24gaXNTZXRJdGVyYXRvcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICByZXR1cm4gcHJvdG90eXBlICYmIHByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnU2V0IEl0ZXJhdG9yJztcbn1cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKCFnbG9iYWwuU2hhcmVkQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1NoYXJlZEFycmF5QnVmZmVyJyk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3RyaW5nJyk7XG59XG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3ltYm9sJyk7XG59XG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgY29uc3QgaXNCdWlsdEluVHlwZWRBcnJheSA9IFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgIT09IHVuZGVmaW5lZDtcbiAgaWYgKGlzQnVpbHRJblR5cGVkQXJyYXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWVbaXNCdWZmZXJdID09PSB0cnVlO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5mdW5jdGlvbiBpc1VpbnQ4Q2xhbXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDhDbGFtcGVkQXJyYXknO1xufVxuZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQxNkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzVWludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdVaW50MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1dlYWtNYXAnKTtcbn1cbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnV2Vha1NldCcpO1xufVxuXG4vLyBAdG9kbyBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGVcblxudmFyIHR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGlzQW55QXJyYXlCdWZmZXI6IGlzQW55QXJyYXlCdWZmZXIsXG5cdGlzQXJndW1lbnRzT2JqZWN0OiBpc0FyZ3VtZW50c09iamVjdCxcblx0aXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcblx0aXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuXHRpc0FzeW5jRnVuY3Rpb246IGlzQXN5bmNGdW5jdGlvbixcblx0aXNCaWdJbnQ2NEFycmF5OiBpc0JpZ0ludDY0QXJyYXksXG5cdGlzQmlnVWludDY0QXJyYXk6IGlzQmlnVWludDY0QXJyYXksXG5cdGlzQm9vbGVhbk9iamVjdDogaXNCb29sZWFuT2JqZWN0LFxuXHRpc0JveGVkUHJpbWl0aXZlOiBpc0JveGVkUHJpbWl0aXZlLFxuXHRpc0RhdGFWaWV3OiBpc0RhdGFWaWV3LFxuXHRpc0RhdGU6IGlzRGF0ZSxcblx0aXNGbG9hdDMyQXJyYXk6IGlzRmxvYXQzMkFycmF5LFxuXHRpc0Zsb2F0NjRBcnJheTogaXNGbG9hdDY0QXJyYXksXG5cdGlzR2VuZXJhdG9yRnVuY3Rpb246IGlzR2VuZXJhdG9yRnVuY3Rpb24sXG5cdGlzR2VuZXJhdG9yT2JqZWN0OiBpc0dlbmVyYXRvck9iamVjdCxcblx0aXNJbnQ4QXJyYXk6IGlzSW50OEFycmF5LFxuXHRpc0ludDE2QXJyYXk6IGlzSW50MTZBcnJheSxcblx0aXNJbnQzMkFycmF5OiBpc0ludDMyQXJyYXksXG5cdGlzTWFwOiBpc01hcCxcblx0aXNNYXBJdGVyYXRvcjogaXNNYXBJdGVyYXRvcixcblx0aXNOYXRpdmVFcnJvcjogaXNOYXRpdmVFcnJvcixcblx0aXNOdW1iZXJPYmplY3Q6IGlzTnVtYmVyT2JqZWN0LFxuXHRpc1Byb21pc2U6IGlzUHJvbWlzZSxcblx0aXNSZWdFeHA6IGlzUmVnRXhwLFxuXHRpc1NldDogaXNTZXQsXG5cdGlzU2V0SXRlcmF0b3I6IGlzU2V0SXRlcmF0b3IsXG5cdGlzU2hhcmVkQXJyYXlCdWZmZXI6IGlzU2hhcmVkQXJyYXlCdWZmZXIsXG5cdGlzU3RyaW5nT2JqZWN0OiBpc1N0cmluZ09iamVjdCxcblx0aXNTeW1ib2xPYmplY3Q6IGlzU3ltYm9sT2JqZWN0LFxuXHRpc1R5cGVkQXJyYXk6IGlzVHlwZWRBcnJheSxcblx0aXNVaW50OEFycmF5OiBpc1VpbnQ4QXJyYXksXG5cdGlzVWludDhDbGFtcGVkQXJyYXk6IGlzVWludDhDbGFtcGVkQXJyYXksXG5cdGlzVWludDE2QXJyYXk6IGlzVWludDE2QXJyYXksXG5cdGlzVWludDMyQXJyYXk6IGlzVWludDMyQXJyYXksXG5cdGlzV2Vha01hcDogaXNXZWFrTWFwLFxuXHRpc1dlYWtTZXQ6IGlzV2Vha1NldFxufSk7XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmxldCBlcnJvcjtcbmZ1bmN0aW9uIGxhenlFcnJvcigpIHtcbiAgaWYgKCFlcnJvcikge1xuICAgIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gICAgLy8gZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLmNvZGVzLkVSUl9JTlRFUk5BTF9BU1NFUlRJT047XG4gICAgZXJyb3IgPSBjb2Rlcy5FUlJfSU5URVJOQUxfQVNTRVJUSU9OO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIGFzc2VydCQxKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBjb25zdCBFUlJfSU5URVJOQUxfQVNTRVJUSU9OID0gbGF6eUVycm9yKCk7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlRFUk5BTF9BU1NFUlRJT04obWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICBjb25zdCBFUlJfSU5URVJOQUxfQVNTRVJUSU9OID0gbGF6eUVycm9yKCk7XG4gIHRocm93IG5ldyBFUlJfSU5URVJOQUxfQVNTRVJUSU9OKG1lc3NhZ2UpO1xufVxuYXNzZXJ0JDEuZmFpbCA9IGZhaWw7XG5cbi8vIENvcHlyaWdodCBOb2RlLmpzIGNvbnRyaWJ1dG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvbnN0IG1lc3NhZ2VzID0gbmV3IE1hcCgpO1xuY29uc3QgY29kZXMgPSB7fTtcblxuLy8gQHRvZG8gaW1wbGVtZW50IHRoaXMgb25jZSBuZWVkZWRcbmNsYXNzIFN5c3RlbUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgdGhlIGVycm9yIGNvZGVzLlxuZnVuY3Rpb24gRShzeW0sIHZhbCwgZGVmLCAuLi5vdGhlckNsYXNzZXMpIHtcbiAgLy8gU3BlY2lhbCBjYXNlIGZvciBTeXN0ZW1FcnJvciB0aGF0IGZvcm1hdHMgdGhlIGVycm9yIG1lc3NhZ2UgZGlmZmVyZW50bHlcbiAgLy8gVGhlIFN5c3RlbUVycm9ycyBvbmx5IGhhdmUgU3lzdGVtRXJyb3IgYXMgdGhlaXIgYmFzZSBjbGFzc2VzLlxuICBtZXNzYWdlcy5zZXQoc3ltLCB2YWwpO1xuICBpZiAoZGVmID09PSBTeXN0ZW1FcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBjb21wYXRpYmxlIFN5c3RlbUVycm9yIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH0gZWxzZSB7XG4gICAgZGVmID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGRlZiwgc3ltKTtcbiAgfVxuICBpZiAob3RoZXJDbGFzc2VzLmxlbmd0aCAhPT0gMCkge1xuICAgIG90aGVyQ2xhc3Nlcy5mb3JFYWNoKGNsYXp6ID0+IHtcbiAgICAgIGRlZltjbGF6ei5uYW1lXSA9IG1ha2VOb2RlRXJyb3JXaXRoQ29kZShjbGF6eiwgc3ltKTtcbiAgICB9KTtcbiAgfVxuICBjb2Rlc1tzeW1dID0gZGVmO1xufVxuZnVuY3Rpb24gbWFrZU5vZGVFcnJvcldpdGhDb2RlKEJhc2UsIGtleSkge1xuICByZXR1cm4gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlKGtleSwgYXJncywgdGhpcyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBhZGRDb2RlVG9OYW1lKHRoaXMsIHN1cGVyLm5hbWUsIGtleSk7XG4gICAgfVxuICAgIGdldCBjb2RlKCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgc2V0IGNvZGUodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2tleX1dOiAke3RoaXMubWVzc2FnZX1gO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoa2V5LCBhcmdzLCBzZWxmKSB7XG4gIGNvbnN0IG1zZyA9IG1lc3NhZ2VzLmdldChrZXkpO1xuXG4gIC8qXG4gIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkge1xuICBcdGFzc2VydCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXNzZXJ0Jyk7XG4gIH1cbiAgKi9cblxuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFzc2VydCQxKG1zZy5sZW5ndGggPD0gYXJncy5sZW5ndGgsXG4gICAgLy8gRGVmYXVsdCBvcHRpb25zIGRvIG5vdCBjb3VudC5cbiAgICBgQ29kZTogJHtrZXl9OyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzIGxlbmd0aCAoJHthcmdzLmxlbmd0aH0pIGRvZXMgbm90IGAgKyBgbWF0Y2ggdGhlIHJlcXVpcmVkIG9uZXMgKCR7bXNnLmxlbmd0aH0pLmApO1xuICAgIHJldHVybiBtc2cuYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSAobXNnLm1hdGNoKC8lW2RmaWpvT3NdL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGFzc2VydCQxKGV4cGVjdGVkTGVuZ3RoID09PSBhcmdzLmxlbmd0aCwgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBgICsgYG1hdGNoIHRoZSByZXF1aXJlZCBvbmVzICgke2V4cGVjdGVkTGVuZ3RofSkuYCk7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtc2c7XG4gIH1cbiAgYXJncy51bnNoaWZ0KG1zZyk7XG4gIHJldHVybiBmb3JtYXQkMS5hcHBseShudWxsLCBhcmdzKTtcbiAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgLy8gcmV0dXJuIGxhenlJbnRlcm5hbFV0aWxJbnNwZWN0KCkuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhZGRDb2RlVG9OYW1lKGVyciwgbmFtZSwgY29kZSkge1xuICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gIGVyci5uYW1lID0gYCR7bmFtZX0gWyR7Y29kZX1dYDtcbiAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgLy8gQGZpeG1lOiBUaGlzIG9ubHkgd29ya3Mgb24gVjgvQW5kcm9pZCwgaU9TL0pTQyBoYXMgYSBkaWZmZXJlbnQgRXJyb3Igc3RydWN0dXJlLlxuICAvLyBzaG91bGQgd2UgdHJ5IHRvIG1ha2UgZXJyb3JzIGJlaGF2ZSB0aGUgc2FtZSBhY3Jvc3MgcGxhdGZvcm1zP1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIGVyci5zdGFjaztcbiAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICBpZiAobmFtZSA9PT0gJ1N5c3RlbUVycm9yJykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICduYW1lJywge1xuICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGVyci5uYW1lO1xuICB9XG59XG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuLy8gVXNpbmcgYSBkZWZhdWx0IGFyZ3VtZW50IGhlcmUgaXMgaW1wb3J0YW50IHNvIHRoZSBhcmd1bWVudCBpcyBub3QgY291bnRlZFxuLy8gdG93YXJkcyBgRnVuY3Rpb24jbGVuZ3RoYC5cbihuYW1lID0gdW5kZWZpbmVkKSA9PiB7XG4gIGlmIChuYW1lKSB7XG4gICAgcmV0dXJuIGBcIiR7bmFtZX1cIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgO1xuICB9XG4gIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcyc7XG59LCBSYW5nZUVycm9yKTtcbkUoJ0VSUl9JTlRFUk5BTF9BU1NFUlRJT04nLCBtZXNzYWdlID0+IHtcbiAgY29uc3Qgc3VmZml4ID0gJ1RoaXMgaXMgY2F1c2VkIGJ5IGVpdGhlciBhIGJ1ZyBpbiBUaXRhbml1bSAnICsgJ29yIGluY29ycmVjdCB1c2FnZSBvZiBUaXRhbml1bSBpbnRlcm5hbHMuXFxuJyArICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSB3aXRoIHRoaXMgc3RhY2sgdHJhY2UgYXQgJyArICdodHRwczovL2dpdGh1Yi5jb20vdGlkZXYvdGl0YW5pdW0tc2RrL2lzc3Vlc1xcbic7XG4gIHJldHVybiBtZXNzYWdlID09PSB1bmRlZmluZWQgPyBzdWZmaXggOiBgJHttZXNzYWdlfVxcbiR7c3VmZml4fWA7XG59LCBFcnJvcik7XG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSA9PiB7XG4gIGFzc2VydCQxKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ1xcJ25hbWVcXCcgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIGxldCBkZXRlcm1pbmVyO1xuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBleHBlY3RlZC5zdGFydHNXaXRoKCdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cbiAgbGV0IG1zZztcbiAgaWYgKG5hbWUuZW5kc1dpdGgoJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IGBUaGUgJHtuYW1lfSAke2RldGVybWluZXJ9ICR7b25lT2YoZXhwZWN0ZWQsICd0eXBlJyl9YDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0eXBlID0gbmFtZS5pbmNsdWRlcygnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gYFRoZSBcIiR7bmFtZX1cIiAke3R5cGV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9XG5cbiAgLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cbiAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XG4gIHJldHVybiBtc2c7XG59LCBUeXBlRXJyb3IpO1xubGV0IG1heFN0YWNrX0Vycm9yTmFtZTtcbmxldCBtYXhTdGFja19FcnJvck1lc3NhZ2U7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgZXJyLm5hbWVgIGFuZCBgZXJyLm1lc3NhZ2VgIGFyZSBlcXVhbCB0byBlbmdpbmUtc3BlY2lmaWNcbiAqIHZhbHVlcyBpbmRpY2F0aW5nIG1heCBjYWxsIHN0YWNrIHNpemUgaGFzIGJlZW4gZXhjZWVkZWQuXG4gKiBcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgaW4gVjguXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RhY2tPdmVyZmxvd0Vycm9yKGVycikge1xuICBpZiAobWF4U3RhY2tfRXJyb3JNZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgZnVuY3Rpb24gb3ZlcmZsb3dTdGFjaygpIHtcbiAgICAgICAgb3ZlcmZsb3dTdGFjaygpO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dTdGFjaygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG1heFN0YWNrX0Vycm9yTWVzc2FnZSA9IGUubWVzc2FnZTtcbiAgICAgIG1heFN0YWNrX0Vycm9yTmFtZSA9IGUubmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVyci5uYW1lID09PSBtYXhTdGFja19FcnJvck5hbWUgJiYgZXJyLm1lc3NhZ2UgPT09IG1heFN0YWNrX0Vycm9yTWVzc2FnZTtcbn1cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBhc3NlcnQkMSh0eXBlb2YgdGhpbmcgPT09ICdzdHJpbmcnLCAnYHRoaW5nYCBoYXMgdG8gYmUgb2YgdHlwZSBzdHJpbmcnKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgY29uc3QgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGFzc2VydCQxKGxlbiA+IDAsICdBdCBsZWFzdCBvbmUgZXhwZWN0ZWQgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoaSA9PiBTdHJpbmcoaSkpO1xuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyl9LCBvciBgICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBgb25lIG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19IG9yICR7ZXhwZWN0ZWRbMV19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke2V4cGVjdGVkWzBdfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtTdHJpbmcoZXhwZWN0ZWQpfWA7XG4gIH1cbn1cblxuY2xhc3MgRmFzdEJ1ZmZlciBleHRlbmRzIFVpbnQ4QXJyYXkge31cblxuLyoqXG4gKiBsb29wIG92ZXIgaW5wdXQsIGV2ZXJ5IDIgY2hhcmFjdGVycywgcGFyc2UgYXMgYW4gaW50XG4gKiBiYXNpY2FsbHkgZWFjaCB0d28gY2hhcmFjdGVycyBhcmUgYSBcImJ5dGVcIiBvciBhbiA4LWJpdCB1aW50XG4gKiB3ZSBhcHBlbmQgdGhlbSBhbGwgdG9nZXRoZXIgdG8gZm9ybSBhIHNpbmdsZSBidWZmZXIgaG9sZGluZyBhbGwgdGhlIHZhbHVlc1xuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHN0cmluZyB3ZSdyZSBlbmNvZGluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtpbnRlZ2VyW119IGFycmF5IG9mIGVuY29kZWQgYnl0ZXNcbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9IZXhCeXRlcyh2YWx1ZSkge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGggLyAyO1xuICBjb25zdCBieXRlQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG51bWVyaWNWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoIU51bWJlci5pc05hTihudW1lcmljVmFsdWUpKSB7XG4gICAgICAvLyBkcm9wIGJhZCBoZXggY2hhcmFjdGVyc1xuICAgICAgYnl0ZUFycmF5LnB1c2gobnVtZXJpY1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuLy8gVXNlIGEgUHJveHkgdG8gaGFjayBhcnJheSBzdHlsZSBpbmRleCBhY2Nlc3NvcnNcbmNvbnN0IGFycmF5SW5kZXhIYW5kbGVyID0ge1xuICBnZXQodGFyZ2V0LCBwcm9wS2V5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgcHJvcEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihwcm9wS2V5KTtcbiAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGp1c3RlZEluZGV4KHRhcmdldCwgbnVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IGlzQnVmZmVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcEtleSwgcmVjZWl2ZXIpO1xuICB9LFxuICBzZXQodGFyZ2V0LCBwcm9wS2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHByb3BLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBudW0gPSBOdW1iZXIocHJvcEtleSk7XG4gICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICBzZXRBZGp1c3RlZEluZGV4KHRhcmdldCwgbnVtLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wS2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICB9LFxuICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihrZXkpO1xuICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgLy8gZW5zdXJlIGl0J3MgYSBwb3NpdGl2ZSBcInNhZmVcIiBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIGJ1ZmZlclxuICAgICAgICByZXR1cm4gbnVtID49IDAgJiYgbnVtIDwgdGFyZ2V0Ll90aUJ1ZmZlci5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXkgaW4gdGFyZ2V0O1xuICB9XG59O1xuXG4vLyBUaGlzIGlzIGEgc3BlY2lhbCBCdWZmZXIgdGhhdCB3cmFwcyBUaS5CdWZmZXJcbi8vIGFzIGEgcmVzdWx0IGl0IGlzICptdWNoKiBzbG93ZXIgdG8gcmVhZC93cml0ZSB2YWx1ZXNcbi8vIGJlY2F1c2Ugd2UgbmVlZCB0byBnbyBhY3Jvc3MgdGhlIEpTL05hdGl2ZSBib3VuZGFyeSBwZXItYnl0ZSFcbi8vIFdlIGFsc28gbmVlZCB0byB1c2UgYSBQcm94eSB0byBoYW5kbGUgaW50ZXJjZXB0aW5nIHNldC9nZXQgb2YgaW5kaWNlcyB0byByZWRpcmVjdCB0byB0aGUgdW5kZXJseWluZyBUaS5CdWZmZXJcbmNsYXNzIFNsb3dCdWZmZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIuXG4gICAqXG4gICAqIFByaW1hcmlseSB1c2VkIGludGVybmFsbHkgaW4gdGhpcyBtb2R1bGUgdG9nZXRoZXIgd2l0aCBgbmV3QnVmZmVyYCB0b1xuICAgKiBjcmVhdGUgYSBuZXcgQnVmZmVyIGluc3RhbmNlIHdyYXBwaW5nIGEgVGkuQnVmZmVyLlxuICAgKlxuICAgKiBBbHNvIHN1cHBvcnRzIHRoZSBkZXByZWNhdGVkIEJ1ZmZlcigpIGNvbnN0cnVjdG9ycyB3aGljaCBhcmUgc2FmZVxuICAgKiB0byB1c2Ugb3V0c2lkZSBvZiB0aGlzIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIHtUaS5CdWZmZXJ9IHRpQnVmZmVyIHRoZSB1bmRlcmx5aW5nIGRhdGEvYnl0ZXNcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gc3RhcnQgb2Zmc2V0IG9mIGFycmF5L2J1ZmZlclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiB0aGUgdW5kZXJseWluZyBhcnJheS9idWZmZXIgdG8gd3JhcFxuICAgKi9cbiAgY29uc3RydWN0b3IodGlCdWZmZXIsIHN0YXJ0ID0gMCwgbGVuZ3RoID0gdGlCdWZmZXIubGVuZ3RoIC0gc3RhcnQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBieXRlT2Zmc2V0OiB7XG4gICAgICAgIHZhbHVlOiBzdGFydFxuICAgICAgfSxcbiAgICAgIGxlbmd0aDoge1xuICAgICAgICB2YWx1ZTogbGVuZ3RoXG4gICAgICB9LFxuICAgICAgX3RpQnVmZmVyOiB7XG4gICAgICAgIHZhbHVlOiB0aUJ1ZmZlclxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGNyZWF0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlIGluc2lkZSBhIFByb3h5IHNvIHdlIGNhbiBoYW5kbGUgYXJyYXkgaW5kZXggYWNjZXNzXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSB0aUJ1ZmZlciB0aGUgdW5kZXJseWluZyBkYXRhL2J5dGVzXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkvYnVmZmVyIHRvIHdyYXBcbiAgICogQHJldHVybnMge0J1ZmZlcn0gd3JhcHBlZCBpbnNpZGUgYSBQcm94eVxuICAgKi9cbiAgc3RhdGljIGZyb21UaUJ1ZmZlcih0aUJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUHJveHkobmV3IFNsb3dCdWZmZXIodGlCdWZmZXIsIHN0YXJ0LCBsZW5ndGgpLCBhcnJheUluZGV4SGFuZGxlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5ldy1idWZmZXJcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cbiAgICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgY29uc3QgYmxvYiA9IFRpLlV0aWxzLmJhc2U2NGRlY29kZSh2YWx1ZSk7XG4gICAgICBjb25zdCBibG9iU3RyZWFtID0gVGkuU3RyZWFtLmNyZWF0ZVN0cmVhbSh7XG4gICAgICAgIHNvdXJjZTogYmxvYixcbiAgICAgICAgbW9kZTogVGkuU3RyZWFtLk1PREVfUkVBRFxuICAgICAgfSk7XG4gICAgICBjb25zdCBidWZmZXIgPSBUaS5TdHJlYW0ucmVhZEFsbChibG9iU3RyZWFtKTtcbiAgICAgIGJsb2JTdHJlYW0uY2xvc2UoKTtcbiAgICAgIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcihidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgICBjb25zdCBieXRlcyA9IHN0cmluZ1RvSGV4Qnl0ZXModmFsdWUpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgY29uc3QgdGlCdWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aUJ1ZmZlcltpXSA9IGJ5dGVzW2ldICYgMHhGRjsgLy8gbWFzayB0byBvbmUgYnl0ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodGlCdWZmZXIpO1xuICAgIH1cbiAgICBjb25zdCB0aUJ1ZmZlciA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB0eXBlOiBnZXRUaUNvZGVjQ2hhcnNldChlbmNvZGluZylcbiAgICB9KTtcbiAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodGlCdWZmZXIpO1xuICB9XG5cbiAgLy8gVGhpcyBpcyBhIG1ldGhvZCB3ZSBzaG91bGQgZ2V0IGJ5IGV4dGVuZGluZyBVaW50OEFycmF5LCBzbyByZWFsbHkgc2hvdWxkIG9ubHkgYmUgb3ZlcnJpZGVuIG9uIGEgXCJTbG93QnVmZmVyXCIgdGhhdCB3cmFwcyBUaS5CdWZmZXJcbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAvLyBHZXQgdGhlIHNsaWNlIG9mIHRoZSBhcnJheSBmcm9tIGJ5dGVPZmZzZXQgdG8gbGVuZ3RoXG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh0aGlzKS5idWZmZXI7XG4gIH1cbiAgX3NsaWNlKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKHRoaXMuX3RpQnVmZmVyLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgX2ZpbGwodmFsdWUsIG9mZnNldCwgZW5kLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgYnVmVG9GaWxsV2l0aCA9IFNsb3dCdWZmZXIuZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgY29uc3QgZmlsbEJ1Zkxlbmd0aCA9IGJ1ZlRvRmlsbFdpdGgubGVuZ3RoO1xuICAgICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB2YWxpZCBmaWxsIGRhdGEnKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBidWZmZXIgbGVuZ3RoID09PSAxLCB3ZSBjYW4ganVzdCBkbyB0aGlzLl90aUJ1ZmZlci5maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCk7XG4gICAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl90aUJ1ZmZlci5maWxsKGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyWzBdLCBvZmZzZXQsIGVuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBtdWx0aXBsZSBieXRlIGZpbGwhXG4gICAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlIChvbiBgdGhpc2AsIG5vdCBvbiB0aGUgYnVmZmVyIHdlIGp1c3QgY3JlYXRlZCk/XG4gICAgICAgIGNvbnN0IGZpbGxDaGFyID0gYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbaSAlIGZpbGxCdWZMZW5ndGhdO1xuICAgICAgICB0aGlzLl90aUJ1ZmZlcltpICsgb2Zmc2V0XSA9IGZpbGxDaGFyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHZhbHVlIGlzIGEgbnVtYmVyIChvciBhIGJ1ZmZlciB3aXRoIGEgc2luZ2xlIGJ5dGUpIHdlIGNhbiB1c2UgdGlCdWZmZXIuZmlsbCgpO1xuICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcbiAgfVxuICBnZXRBZGp1c3RlZEluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGhpcywgaW5kZXgpO1xuICB9XG4gIHNldEFkanVzdGVkSW5kZXgoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHNldEFkanVzdGVkSW5kZXgodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgYSBtZXRob2Qgd2Ugc2hvdWxkIGdldCBieSBleHRlbmRpbmcgVWludDhBcnJheSwgc28gcmVhbGx5IHNob3VsZCBvbmx5IGJlIG92ZXJyaWRlbiBvbiBhIFwiU2xvd0J1ZmZlclwiIHRoYXQgd3JhcHMgVGkuQnVmZmVyXG4gIHNldChzcmMsIG9mZnNldCA9IDApIHtcbiAgICBjb25zdCBudW1CeXRlcyA9IHNyYy5sZW5ndGg7XG4gICAgLy8gY2hlY2sgc3JjLmxlbmd0aCArIG9mZnNldCBkb2Vzbid0IGdvIGJleW9uZCBvdXIgbGVuZ3RoIVxuICAgIC8vIEZJWE1FOiBSZS1lbmFibGVcbiAgICAvLyBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIG51bUJ5dGVzKTtcbiAgICAvLyBjb3B5IHNyYyB2YWx1ZXMgaW50byB0aGlzIGJ1ZmZlciBzdGFydGluZyBhdCBvZmZzZXRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJ5dGVzOyBpKyspIHtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIG9mZnNldCwgc3JjW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgYSBjb252ZXJzaW9uIG1ldGhvZCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBUaSBBUElzIHRoYXQgcmVxdWlyZSBhIFRpLkJ1ZmZlclxuICAgKiBAcmV0dXJucyB7VGkuQnVmZmVyfSB0aGUgdW5kZXJseWluZyBUaS5CdWZmZXIgYmFja2luZyB0aGlzIEJ1ZmZlciBpbnN0YW5jZVxuICAgKi9cbiAgdG9UaUJ1ZmZlcigpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IHRoaXMuX3RpQnVmZmVyLmxlbmd0aCAmJiB0aGlzLmJ5dGVPZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl90aUJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyLmNsb25lKHRoaXMuYnl0ZU9mZnNldCwgdGhpcy5sZW5ndGgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBZGp1c3RlZEluZGV4KGJ1ZiwgaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gV3JhcHBpbmcgVGkuQnVmZmVyP1xuICBpZiAoYnVmLl90aUJ1ZmZlcikge1xuICAgIGlmIChpbmRleCA+PSBidWYuX3RpQnVmZmVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5fdGlCdWZmZXJbaW5kZXggKyBidWYuYnl0ZU9mZnNldF07XG4gIH1cbiAgLy8gUmF3IFR5cGVkQXJyYXkvQXJyYXlCdWZmZXJcbiAgLy8gRklYTUU6IGRvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlP1xuICByZXR1cm4gYnVmW2luZGV4XTtcbn1cbmZ1bmN0aW9uIHNldEFkanVzdGVkSW5kZXgoYnVmLCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBXcmFwcGluZyBUaS5CdWZmZXI/XG4gIGlmIChidWYuX3RpQnVmZmVyKSB7XG4gICAgaWYgKGluZGV4IDwgYnVmLl90aUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGJ1Zi5fdGlCdWZmZXJbaW5kZXggKyBidWYuYnl0ZU9mZnNldF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFJhdyBUeXBlZEFycmF5L0FycmF5QnVmZmVyXG4gIC8vIEZJWE1FOiBkbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZT9cbiAgYnVmW2luZGV4XSA9IHZhbHVlO1xufVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sI2J1ZmZlcl9idWZmZXJzX2FuZF9jaGFyYWN0ZXJfZW5jb2RpbmdzXG5jb25zdCBUSV9DT0RFQ19NQVAgPSBuZXcgTWFwKCk7XG5USV9DT0RFQ19NQVAuc2V0KCd1dGYtOCcsIFRpLkNvZGVjLkNIQVJTRVRfVVRGOCk7XG5USV9DT0RFQ19NQVAuc2V0KCd1dGY4JywgVGkuQ29kZWMuQ0hBUlNFVF9VVEY4KTtcblRJX0NPREVDX01BUC5zZXQoJ3V0Zi0xNmxlJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ3V0ZjE2bGUnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgndWNzMicsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCd1Y3MtMicsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCdsYXRpbjEnLCBUaS5Db2RlYy5DSEFSU0VUX0lTT19MQVRJTl8xKTtcblRJX0NPREVDX01BUC5zZXQoJ2JpbmFyeScsIFRpLkNvZGVjLkNIQVJTRVRfSVNPX0xBVElOXzEpO1xuVElfQ09ERUNfTUFQLnNldCgnYXNjaWknLCBUaS5Db2RlYy5DSEFSU0VUX0FTQ0lJKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIGRlc2lyZWQgZW5jb2RpbmcgbmFtZVxuICogQHJldHVybnMge2ludGVnZXJ9IFRpLkNvZGVjIGNvbnN0YW50IHRoYXQgbWFwcyB0byB0aGUgZW5jb2RpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0VGlDb2RlY0NoYXJzZXQoZW5jb2RpbmcpIHtcbiAgcmV0dXJuIFRJX0NPREVDX01BUC5nZXQoZW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgQnVmZmVyIHVzZXMgYSBUaS5CdWZmZXIgaW50ZXJuYWxseSB0byBiYWNrIGl0LlxuICogVGhpcyBpcyBsaWtsZXkgYW4gb3JkZXIgb2YgbWFnbml0dWRlIHNsb3dlciB0aGFuIHVzaW5nIGEgdmFyaWFudCB0aGF0IGV4dGVuZHMgVWludDhBcnJheSFcbiAqIEkgdGhpbmsgaWYgd2UncmUgbm90IGFscmVhZHkgd3JhcHBpbmcgYSBUaS5CdWZmZXIsIGl0IG1heSBiZSBiZXR0ZXIgdG8gaGF2ZSB0d28gaW1wbGVtZW50YXRpb25zXG4gKiBhbmQsIGxpa2UgYnJvd3NlcmlmeSwganVzdCBleHRlbmQgVWludDhBcnJheSBmb3IgYW55IEJ1ZmZlcnMgd2UgbmVlZCB0byByZWFkL3dyaXRlIGEgbG90XG4gKiBhbmQgdGhlbiBhZGQgYSBzaW1wbGUgY29udmVyc2lvbiBtZXRob2QgdG8gdHVybiBpdCBpbnRvIGEgVGkuQnVmZmVyIHdoZW4gbmVlZGVkLlxuICpcbiAqIFRoZSBUaS5CdWZmZXIgaW1wbCBoYXMgdG8gZ28gdGhyb3VnaCB0aGUgYmluZGluZyBsYXllciBmb3IgcmVhZGluZy93cml0aW5nIGV2ZXJ5IGJ5dGUuXG4gKiBJZiB3ZSBhbnRpY2lwYXRlIHRoZSBCdWZmZXIgc3RheWluZyBvbiB0aGUgSlMgc2lkZSwgSSdtIHdpbGxpbmcgdG8gYmV0IHRoYXQgdGhlIFVpbnQ4QXJyYXlcbiAqIHRoZSBKUyBlbmdpbmUgcHJvdmlkZXMgd291bGQgYmUgKndheSogZmFzdGVyLlxuICpcbiAqIEFsc28gbm90ZSB0aGF0IGJvdGggVGkuQnVmZmVyIGFuZCBOb2RlJ3MgQnVmZmVyIHdlcmUgY3JlYXRlZCBiZWZvcmUgdGhlIEpTIGVuZ2luZXMgaGFkIHR5cGVkIGFycmF5c1xuICogKGFuZCBVaW50OEFycmF5IGluIHBhcnRpY3VsYXIpIGFzIGEgbWVhbnMgb2YgZW5jYXBzdWxhdGluZyBhIGJ5dGUgYXJyYXkuIFdlIHNob3VsZCBjb25zaWRlciBhY2NlcHRpbmdcbiAqIGEgVWludDhBcnJheSBpbiBhbnkgb2Ygb3VyIEFQSXMgdGhhdCB0YWtlIGEgVGkuQnVmZmVyIGFuZCBldmVudHVhbGx5IGRlcHJlY2F0aW5nL3JlbW92aW5nIFRpLkJ1ZmZlci5cbiAqL1xuY29uc3Qge1xuICBBTExfUFJPUEVSVElFUzogQUxMX1BST1BFUlRJRVMkMSxcbiAgT05MWV9FTlVNRVJBQkxFOiBPTkxZX0VOVU1FUkFCTEUkMVxufSA9IHByb3BlcnR5RmlsdGVyO1xuY29uc3QgVkFMSURfRU5DT0RJTkdTID0gWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdsYXRpbjEnLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnXTtcblxuLy8gVXNlZCB0byBjaGVhdCBmb3IgcmVhZC93cml0ZXMgb2YgZG91Ymxlc1xuY29uc3QgZG91YmxlQXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KDEpO1xuY29uc3QgdWludDhEb3VibGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGRvdWJsZUFycmF5LmJ1ZmZlcik7XG5cbi8vIFVzZWQgdG8gY2hlYXQgdG8gcmVhZC93cml0ZSBmbG9hdHNcbmNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuY29uc3QgdWludDhGbG9hdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmxvYXRBcnJheS5idWZmZXIpO1xuXG4vLyBOb2RlLmpzIGRvZXMgc29tZSB2ZXJ5IHdlaXJkIHN0dWZmIGhlcmVcbkZhc3RCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQnVmZmVyJDE7IC8vIG5ldyBGYXN0QnVmZmVyKCkgY2FsbHMgQnVmZmVyIGZ1bmN0aW9uP1xuQnVmZmVyJDEucHJvdG90eXBlID0gRmFzdEJ1ZmZlci5wcm90b3R5cGU7IC8vIFRoZW4gaXQgaGlqYWNrcyBCdWZmZXIncyBwcm90b3R5cGUgdG8gcG9pbnQgYXQgRmFzdEJ1ZmZlcidzPyFcbi8vIERvZXMgdGhpcyBlZmZlY3RpdmVseSBtZWFuIEJ1ZmZlciBleHRlbmRzIFVpbnQ4QXJyYXksIGJlY2F1c2UgRmFzdEJ1ZmZlciBkaWQ/IFRoaXMgZmFpbHMgZm9yIG1lXG4vLyBIb3cgdGhlIGhlbGwgY2FuIHdlIG1ha2UgaXQgaGFwcHk/IFdlIHJlYWxseSB3YW50IHRvIGV4dGVuZCBVaW50OEFycmF5IGlmIHdlIGNhblxuLy8gYWRkQnVmZmVyUHJvdG90eXBlTWV0aG9kcyhCdWZmZXIucHJvdG90eXBlKTsgLy8gSGVyZSdzIHdoZXJlIGl0IGhhbmdzIHNvbWUgb2YgdGhlIG1ldGhvZHNcblxuQnVmZmVyJDEucG9vbFNpemUgPSA4MTkyO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyLlxuICpcbiAqIFByaW1hcmlseSB1c2VkIGludGVybmFsbHkgaW4gdGhpcyBtb2R1bGUgdG9nZXRoZXIgd2l0aCBgbmV3QnVmZmVyYCB0b1xuICogY3JlYXRlIGEgbmV3IEJ1ZmZlciBpbnN0YW5jZSB3cmFwcGluZyBhIFRpLkJ1ZmZlci5cbiAqXG4gKiBBbHNvIHN1cHBvcnRzIHRoZSBkZXByZWNhdGVkIEJ1ZmZlcigpIGNvbnN0cnVjdG9ycyB3aGljaCBhcmUgc2FmZVxuICogdG8gdXNlIG91dHNpZGUgb2YgdGhpcyBtb2R1bGUuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyW118QnVmZmVyfGludGVnZXJ8c3RyaW5nfFRpLkJ1ZmZlcn0gYXJnIHRoZSB1bmRlcmx5aW5nIGRhdGEvYnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IGVuY29kaW5nT3JPZmZzZXQgZW5jb2Rpbmcgb2YgdGhlIHN0cmluZywgb3Igc3RhcnQgb2Zmc2V0IG9mIGFycmF5L2J1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggbGVuZ3RoIG9mIHRoZSB1bmRlcmx5aW5nIGFycmF5L2J1ZmZlciB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBCdWZmZXIkMShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmcgIT09ICdvYmplY3QnIHx8IGFyZy5hcGlOYW1lICE9PSAnVGkuQnVmZmVyJykge1xuICAgIHNob3dGbGFnZ2VkRGVwcmVjYXRpb24oKTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIFwic3RyaW5nXCIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYXJnfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jKGFyZyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIkMS5mcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIC8vIFRoZSBzbG93IGNhc2UgLSB3ZSdyZSB3cmFwcGluZyBhIFRpLkJ1ZmZlclxuICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcltdfEJ1ZmZlcnxzdHJpbmd9IHZhbHVlIHZhbHVlIHdlJ3JlIHdyYXBwaW5nXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBlbmNvZGluZ09yT2Zmc2V0IGVuY29kaW5nIG9mIHRoZSBzdHJpbmcsIG9yIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIGxlbmd0aCBvZiB0aGUgdW5kZXJseWluZyBhcnJheS9idWZmZXIgdG8gd3JhcFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuQnVmZmVyJDEuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGNvbnN0IHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHZhbHVlVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChpc0FueUFycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIkMS5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gV2Ugd2FudCB0byBsaW1pdCB0aGUgdXNlIG9mIFNsb3dCdWZmZXJzIHRvIG9ubHkgd2hlbiB3ZSdyZSB3cmFwcGluZyBhIFRpLkJ1ZmZlciwgaG9wZWZ1bGx5IVxuICAgIGlmICh2YWx1ZS5hcGlOYW1lICYmIHZhbHVlLmFwaU5hbWUgPT09ICdUaS5CdWZmZXInKSB7XG4gICAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFwndmFsdWVcXCcgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZTogXFwnc3RyaW5nXFwnLCBcXCdBcnJheVxcJywgXFwnQnVmZmVyXFwnLCBcXCdUaS5CdWZmZXJcXCcnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gb2JqIEFycmF5QnVmZmVyIHRvIHdyYXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnl0ZU9mZnNldD0wXSBieXRlIG9mZnN0ZSB0byBiZWdpblxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIGxlbmd0aCB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29udmVydCBieXRlT2Zmc2V0IHRvIGludGVnZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldDtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgICBieXRlT2Zmc2V0ID0gMDtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF4TGVuZ3RoID0gb2JqLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xuICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoJ29mZnNldCcpO1xuICB9XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IG1heExlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb252ZXJ0IGxlbmd0aCB0byBub24tbmVnYXRpdmUgaW50ZWdlci5cbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoJ2xlbmd0aCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byB3cmFwXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gY2hhcmFjdGVyIGVuY29kaW5nXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBpZiAoIUJ1ZmZlciQxLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgfVxuICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICBjb25zdCBibG9iID0gVGkuVXRpbHMuYmFzZTY0ZGVjb2RlKHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoYmxvYi50b0FycmF5QnVmZmVyKCkpO1xuICB9XG4gIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5KHN0cmluZ1RvSGV4Qnl0ZXModmFsdWUpKTtcbiAgfVxuICAvLyBDb252ZXJ0IHRoZSBTbG93QnVmZmVyIHRvIGEgZmFzdCBidWZmZXIgYnkganVzdCBjb3B5aW5nIGJ5dGVzIHJlY3Vyc2l2ZWx5IGhlcmVcbiAgcmV0dXJuIGZyb21CdWZmZXIoU2xvd0J1ZmZlci5mcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZykpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcltdfFVpbnQ4QXJyYXl8YXJyYXl9IHZhbHVlIHZhbHVlcyB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcbiAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBJZGVhbGx5IHRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHdlJ3JlIGNvcHlpbmcgYSBTbG93QnVmZmVyIGludG8gYSBuZXcgRmFzdEJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIGJ1ZmZlciB0byBjb3B5XG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBmcm9tQnVmZmVyKHZhbHVlKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcigpO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG4gIHZhbHVlLmNvcHkoYnVmZmVyLCAwLCAwLCBsZW5ndGgpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciQxLCBVaW50OEFycmF5KTsgLy8gV2hhdCBpcyB0aGlzIGRvaW5nPyEgTWFraW5nIEJ1ZmZlci5wcm90b3R5cGUgcG9pbnQgYXQgVWludDhBcnJheSBub3dcblxuLyoqXG4gKiAwIGlzIHJldHVybmVkIGlmIHRhcmdldCBpcyB0aGUgc2FtZSBhcyBidWZcbiAqIDEgaXMgcmV0dXJuZWQgaWYgdGFyZ2V0IHNob3VsZCBjb21lIGJlZm9yZSBidWYgd2hlbiBzb3J0ZWQuXG4gKiAtMSBpcyByZXR1cm5lZCBpZiB0YXJnZXQgc2hvdWxkIGNvbWUgYWZ0ZXIgYnVmIHdoZW4gc29ydGVkLlxuICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldCBCdWZmZXIgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFt0YXJnZXRTdGFydD0wXSBpbmRleCB0byBzdGFydCBpbiB0YXJnZXRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3RhcmdldEVuZD10YXJnZXQubGVuZ3RoXSBpbmRleCB0byBlbmQgaW4gdGFyZ2V0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VTdGFydD0wXSBpbmRleCB0byBzdGFydCBpbiB0aGlzIEJ1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc291cmNlRW5kPXRoaXMubGVuZ3RoXSBpbmRleCB0byBlbmQgaW4gdGhpcyBCdWZmZXJcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldFN0YXJ0LCB0YXJnZXRFbmQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgaWYgKCFCdWZmZXIkMS5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBidWYxfWApO1xuICB9XG4gIGlmICh0YXJnZXRTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGFyZ2V0U3RhcnQgPSAwO1xuICB9XG4gIGlmIChzb3VyY2VTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlU3RhcnQgPSAwO1xuICB9XG4gIGlmICh0YXJnZXRFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRhcmdldEVuZCA9IHRhcmdldC5sZW5ndGg7XG4gIH1cbiAgaWYgKHNvdXJjZUVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICAvLyBFUlJfT1VUX09GX1JBTkdFIGlzIHRocm93biBpZiB0YXJnZXRTdGFydCA8IDAsIHNvdXJjZVN0YXJ0IDwgMCwgdGFyZ2V0RW5kID4gdGFyZ2V0LmJ5dGVMZW5ndGgsIG9yIHNvdXJjZUVuZCA+IHNvdXJjZS5ieXRlTGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA8IDAgfHwgc291cmNlU3RhcnQgPCAwIHx8IHRhcmdldEVuZCA+IHRhcmdldC5sZW5ndGggfHwgc291cmNlRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7IC8vIEZJWE1FOiBzZXQgXCJjb2RlXCIgdG8gRVJSX0lOREVYX09VVF9PRl9SQU5HRVxuICB9XG5cbiAgLy8gVXNlIHNsaWNlcyB0byBtYWtlIHRoZSBsb29wIGVhc2llclxuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNsaWNlKHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuICBjb25zdCBzb3VyY2VMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICBjb25zdCBkZXN0ID0gdGFyZ2V0LnNsaWNlKHRhcmdldFN0YXJ0LCB0YXJnZXRFbmQpO1xuICBjb25zdCBkZXN0TGVuZ3RoID0gZGVzdC5sZW5ndGg7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKHNvdXJjZUxlbmd0aCwgZGVzdExlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IGRlc3QuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZS5nZXRBZGp1c3RlZEluZGV4KGkpO1xuICAgIGlmICh0YXJnZXRWYWx1ZSAhPT0gc291cmNlVmFsdWUpIHtcbiAgICAgIC8vIE5vIG1hdGNoISBSZXR1cm4gMSBvciAtMSBiYXNlZCBvbiB3aGF0IGlzIGdyZWF0ZXIhXG4gICAgICBpZiAoc291cmNlVmFsdWUgPCB0YXJnZXRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cblxuICAvLyBzb3J0IGJhc2VkIG9uIGxlbmd0aCFcbiAgaWYgKHNvdXJjZUxlbmd0aCA8IGRlc3RMZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHNvdXJjZUxlbmd0aCA+IGRlc3RMZW5ndGgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQ29waWVzIGZyb20gdGhpcyB0byB0YXJnZXRcbiAqIEBwYXJhbSB7QnVmZmVyfSB0YXJnZXQgZGVzdGluYXRpb24gd2UncmUgY29weWluZyBpbnRvXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFt0YXJnZXRTdGFydD0wXSBzdGFydCBpbmRleCB0byBjb3B5IGludG8gaW4gZGVzdGluYXRpb24gQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzb3VyY2VTdGFydD0wXSBzdGFydCBpbmRleCB0byBjb3B5IGZyb20gd2l0aGluIGB0aGlzYFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc291cmNlRW5kPXRoaXMubGVuZ3RoXSBlbmQgaW5kZXggdG8gY29weSBmcm9tIHdpdGhpbiBgdGhpc2BcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgY29waWVkXG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgaWYgKHRhcmdldFN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0YXJnZXRTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHNvdXJjZVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VTdGFydCA9IDA7XG4gIH1cbiAgaWYgKHNvdXJjZUVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cbiAgaWYgKHNvdXJjZVN0YXJ0ID09PSBzb3VyY2VFbmQpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIFRPRE86IGNoZWNrIGZvciBvdXQgb2YgYm91bmRzP1xuICBsZXQgbGVuZ3RoID0gc291cmNlRW5kIC0gc291cmNlU3RhcnQ7XG4gIC8vIENhcCBsZW5ndGggdG8gcmVtYWluaW5nIGJ5dGVzIGluIHRhcmdldCFcbiAgY29uc3QgcmVtYWluaW5nID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0O1xuICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyByZW1haW5pbmc7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9XG4gIC8vIERldGVybWluZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdlJ2xsIGNvcHksIGNvbnN0cmFpbiBieSBzb3VyY2UgYnVmZmVyIGxlbmd0aCBhcyB3ZWxsIGFzIHRhcmdldCAoYWJvdmUpXG4gIGxldCBudW1CeXRlcyA9IGxlbmd0aDtcbiAgY29uc3Qgc291cmNlTGVuID0gdGhpcy5sZW5ndGggLSBzb3VyY2VTdGFydDtcbiAgaWYgKG51bUJ5dGVzID4gc291cmNlTGVuKSB7XG4gICAgbnVtQnl0ZXMgPSBzb3VyY2VMZW47XG4gIH1cblxuICAvLyBUT0RPOiBoYW5kbGUgb3ZlcmxhcCB3aGVuIHRhcmdldCA9PT0gdGhpcyFcbiAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byB0YWtlIHRhcmdldCBieXRlT2Zmc2V0IGludG8gYWNjb3VudCBoZXJlP1xuICBsZXQgc291cmNlID0gdGhpcztcbiAgaWYgKHNvdXJjZVN0YXJ0ICE9PSAwIHx8IHNvdXJjZUVuZCA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlciwgdGhpcy5ieXRlT2Zmc2V0ICsgc291cmNlU3RhcnQsIG51bUJ5dGVzKTtcbiAgfVxuICB0YXJnZXQuc2V0KHNvdXJjZSwgdGFyZ2V0U3RhcnQpO1xuICByZXR1cm4gbnVtQnl0ZXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gaXRlcmF0b3Igb2YgW2luZGV4LCBieXRlXSBwYWlycyBmcm9tIHRoZSBjb250ZW50cyBvZiBidWYuXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gKi9cbi8vIFRPRE86IElzIHRoaXMgb25seSBuZWNlc3NhcnkgZm9yIFNsb3dCdWZmZXI/XG5CdWZmZXIkMS5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYnVmZmVyID0gdGhpcztcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZCA9IHRoaXMubGVuZ3RoO1xuICBjb25zdCBlbnRyeUl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiBbbmV4dEluZGV4LCBidWZmZXIuZ2V0QWRqdXN0ZWRJbmRleChuZXh0SW5kZXgpXSxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZW50cnlJdGVyYXRvcjtcbn07XG5CdWZmZXIkMS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyQnVmZmVyKSB7XG4gIGlmICghQnVmZmVyJDEuaXNCdWZmZXIob3RoZXJCdWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICB9XG4gIGlmIChvdGhlckJ1ZmZlciA9PT0gdGhpcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXJCdWZmZXIpID09PSAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VUludDhBcnJheXxpbnRlZ2VyfSB2YWx1ZSBUaGUgdmFsdWUgd2l0aCB3aGljaCB0byBmaWxsIGBidWZgLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byBmaWxsIGBidWZgXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmRdIFdoZXJlIHRvIHN0b3AgZmlsbGluZyBidWYgKG5vdCBpbmNsdXNpdmUpLiBgYnVmLmxlbmd0aGAgYnkgZGVmYXVsdFxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBlbmNvZGluZyBmb3IgYHZhbHVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICogQHJldHVybnMge3RoaXN9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgY29uc3Qgb2Zmc2V0VHlwZSA9IHR5cGVvZiBvZmZzZXQ7XG4gIGlmIChvZmZzZXRUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHZhbHVlIHN1cHBsaWVkXG4gICAgb2Zmc2V0ID0gMDtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfSBlbHNlIGlmIChvZmZzZXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIC8vIHZhbHVlLCBlbmNvZGluZyBzdXBwbGllZFxuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IDA7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyB2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZyBzdXBwbGllZFxuICAgIGVuY29kaW5nID0gZW5kO1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG4gIHRoaXMuX2ZpbGwodmFsdWUsIG9mZnNldCwgZW5kLCBlbmNvZGluZyk7XG4gIHJldHVybiB0aGlzO1xufTtcbmNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheS5wcm90b3R5cGUpO1xuY29uc3QgVHlwZWRBcnJheVByb3RvX2J5dGVMZW5ndGggPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFR5cGVkQXJyYXlQcm90b3R5cGUsICdieXRlTGVuZ3RoJykuZ2V0O1xuY29uc3QgVHlwZWRBcnJheUZpbGwgPSBUeXBlZEFycmF5UHJvdG90eXBlLmZpbGw7XG5CdWZmZXIkMS5wcm90b3R5cGUuX2ZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgZW5kLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIC8vIE9PQiBjaGVja1xuICAgIGNvbnN0IGJ5dGVMZW4gPSBUeXBlZEFycmF5UHJvdG9fYnl0ZUxlbmd0aC5jYWxsKHRoaXMpO1xuICAgIGNvbnN0IGZpbGxMZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA+IGVuZCB8fCBmaWxsTGVuZ3RoICsgb2Zmc2V0ID4gYnl0ZUxlbikge1xuICAgICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpO1xuICAgIH1cbiAgICBUeXBlZEFycmF5RmlsbC5jYWxsKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGVuZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnVmVG9GaWxsV2l0aCA9IFNsb3dCdWZmZXIuZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgIGNvbnN0IGZpbGxCdWZMZW5ndGggPSBidWZUb0ZpbGxXaXRoLmxlbmd0aDtcbiAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB2YWxpZCBmaWxsIGRhdGEnKTtcbiAgICB9XG4gICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDEpIHtcbiAgICAgIFR5cGVkQXJyYXlGaWxsLmNhbGwodGhpcywgYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbMF0sIG9mZnNldCwgZW5kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIG11bHRpcGxlIGJ5dGUgZmlsbCFcbiAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBhY2NvdW50IGZvciBieXRlT2Zmc2V0IGhlcmUgKG9uIGB0aGlzYCwgbm90IG9uIHRoZSBidWZmZXIgd2UganVzdCBjcmVhdGVkKT9cbiAgICAgIGNvbnN0IGZpbGxDaGFyID0gYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbaSAlIGZpbGxCdWZMZW5ndGhdO1xuICAgICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyBvZmZzZXQsIGZpbGxDaGFyKTtcbiAgICB9XG4gIH1cbn07XG5CdWZmZXIkMS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAodmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxpbnRlZ2VyfSB2YWx1ZSBXaGF0IHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2J5dGVPZmZzZXQ9MF0gV2hlcmUgdG8gYmVnaW4gc2VhcmNoaW5nIGluIGJ1Zi4gSWYgbmVnYXRpdmUsIHRoZW4gb2Zmc2V0IGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZW5kIG9mIGJ1ZlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIElmIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIHRvIGRldGVybWluZSB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdHJpbmcgdGhhdCB3aWxsIGJlIHNlYXJjaGVkIGZvciBpbiBidWZcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdmFsdWUgaW4gYnVmLCBvciAtMSBpZiBidWYgZG9lcyBub3QgY29udGFpbiB2YWx1ZS5cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAodmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGVtcHR5IGJ1ZmZlcj8gY2FuJ3QgZmluZCBhbnl0aGluZyFcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBpZiBieXRlT2Zmc2V0IGlzIHVuZGVmaW5lZCwgbWFrZSBpdCAwXG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZiBpdCdzIGEgc3RyaW5nLCB0aGF0J3MgYWN0dWFsbHkgZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH1cblxuICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFuIGVuY29kaW5nIHlldCwgdXNlIHV0ZjhcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuICBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICAvLyBjb252ZXJ0IG5lZ2F0aXZlIGluZGljZXNcbiAgICBieXRlT2Zmc2V0ID0gdGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0O1xuICAgIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgICAgLy8gc3RpbGwgbmVnYXRpdmU/IHN0YXJ0IGF0IDBcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBjYW4ndCBmaW5kIHBhc3QgZW5kIG9mIGJ1ZmZlciFcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdmFsdWUgJj0gMHhGRjsgLy8gY2xhbXAgdG8gMjU1XG4gICAgLy8gVGhpcyBpcyBhIHNpbXBsZXIgY2FzZSwgd2UgaGF2ZSBhIHNpbmdsZSBieXRlIHdlIG5lZWQgdG8gc2VhcmNoIGZvclxuICAgIC8vIHNvIGp1c3QgbG9vcCB0aHJvdWdoIGFuZCB0cnkgdG8gZmluZCBpdFxuICAgIHJldHVybiBpbmRleE9mKHRoaXMsIHZhbHVlLCBieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIGNvZXJjZSBhIHN0cmluZyB0byBhIEJ1ZmZlclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gdmFsdWUgaXMgbm93IGEgQnVmZmVyLi4uXG4gIGNvbnN0IG1hdGNoTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICBpZiAobWF0Y2hMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7IC8vIG5ldmVyIGZpbmQgZW1wdHkgdmFsdWUhXG4gIH1cblxuICBpZiAobWF0Y2hMZW5ndGggPT09IDEpIHtcbiAgICAvLyBzaW1wbGUgY2FzZSwgbWF0Y2ggb25lIGJ5dGUhXG4gICAgcmV0dXJuIGluZGV4T2YodGhpcywgdmFsdWVbMF0sIGJ5dGVPZmZzZXQpO1xuICB9XG4gIGxldCBjdXJyZW50SW5kZXggPSBieXRlT2Zmc2V0O1xuICBjb25zdCB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIGlmIChtYXRjaExlbmd0aCA+IHRoaXNMZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7IC8vIGNhbid0IG1hdGNoIGlmIHRoZSB2YWx1ZSBpcyBsb25nZXIgdGhhbiB0aGlzIEJ1ZmZlciFcbiAgfVxuXG4gIC8vIEZJWE1FOiBDYW4gd2UgcmV3cml0ZSB0aGlzIGluIGEgbGVzcyBmdW5reSB3YXk/XG4gIC8vIEZJWE1FOiBDYW4gc3RvcCBlYXJsaWVyIGJhc2VkIG9uIG1hdGNoTGVuZ3RoIVxuICBmaXJzdE1hdGNoOiB3aGlsZSAoY3VycmVudEluZGV4IDwgdGhpc0xlbmd0aCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbGFiZWxzXG4gICAgLy8gbWF0Y2ggZmlyc3QgYnl0ZSFcbiAgICBsZXQgZmlyc3RCeXRlTWF0Y2ggPSBpbmRleE9mKHRoaXMsIHZhbHVlWzBdLCBjdXJyZW50SW5kZXgpO1xuICAgIGlmIChmaXJzdEJ5dGVNYXRjaCA9PT0gLTEpIHtcbiAgICAgIC8vIGNvdWxkbid0IGV2ZW4gbWF0Y2ggdGhlIHZlcnkgZmlyc3QgYnl0ZSwgc28gbm8gbWF0Y2ggb3ZlcmFsbCFcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBvaywgd2UgZm91bmQgdGhlIGZpcnN0IGJ5dGUsIG5vdyB3ZSBuZWVkIHRvIHNlZSBpZiB0aGUgbmV4dCBjb25zZWN1dGl2ZSBieXRlcyBtYXRjaCFcbiAgICBmb3IgKGxldCB4ID0gMTsgeCA8IG1hdGNoTGVuZ3RoOyB4KyspIHtcbiAgICAgIGlmIChmaXJzdEJ5dGVNYXRjaCArIHggPj0gdGhpc0xlbmd0aCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBmaXJzdEJ5dGVNYXRjaCArIDE7IC8vIG1vdmUgcGFzdCBvdXIgZmlyc3QgbWF0Y2hcbiAgICAgICAgY29udGludWUgZmlyc3RNYXRjaDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sYWJlbHNcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbZmlyc3RCeXRlTWF0Y2ggKyB4XSAhPT0gdmFsdWVbeF0pIHtcbiAgICAgICAgLy8gZGlkbid0IG1hdGNoIVxuICAgICAgICBjdXJyZW50SW5kZXggPSBmaXJzdEJ5dGVNYXRjaCArIDE7IC8vIG1vdmUgcGFzdCBvdXIgZmlyc3QgbWF0Y2hcbiAgICAgICAgY29udGludWUgZmlyc3RNYXRjaDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sYWJlbHNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlyc3RCeXRlTWF0Y2g7IC8vIHRoZSByZXN0IG1hdGNoZWQsIGh1cnJheSFcbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG5CdWZmZXIkMS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZCA9IHRoaXMubGVuZ3RoO1xuICBjb25zdCBteUl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiBuZXh0SW5kZXgsXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG15SXRlcmF0b3I7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA4XG4gKiBAcmV0dXJucyB7ZG91YmxlfSBSZWFkcyBhIDY0LWJpdCBkb3VibGUgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA4KTtcblxuICAvLyBOb2RlIGNoZWF0cyBhbmQgdXNlcyBhIEZsb2F0NjRBcnJheSBhbmQgVUludDhBcnJheSBiYWNrZWQgYnkgdGhlIHNhbWUgYnVmZmVyXG4gIC8vIHNvIGJhc2ljYWxseSBpdCByZWFkcyBpbiB0aGUgYnl0ZXMgc3R1ZmZpbmcgdGhlbSBpbnRvIFVpbnQ4QXJyYXksIHRoZW4gcmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgRmxvYXQ2NEFycmF5XG4gIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgTEUgc3lzdGVtIGJ5dGVPcmRlclxuICB1aW50OERvdWJsZUFycmF5WzddID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs1XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzRdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgcmV0dXJuIGRvdWJsZUFycmF5WzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gOFxuICogQHJldHVybnMge2RvdWJsZX0gUmVhZHMgYSA2NC1iaXQgZG91YmxlIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG5cbiAgLy8gTm9kZSBjaGVhdHMgYW5kIHVzZXMgYSBGbG9hdDY0QXJyYXkgYW5kIFVJbnQ4QXJyYXkgYmFja2VkIGJ5IHRoZSBzYW1lIGJ1ZmZlclxuICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0NjRBcnJheVxuICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcbiAgdWludDhEb3VibGVBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzRdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs2XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzddID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBkb3VibGVBcnJheVswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAqIEByZXR1cm5zIHtmbG9hdH0gUmVhZHMgYSAzMi1iaXQgZmxvYXQgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuXG4gIC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDMyQXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG4gIHVpbnQ4RmxvYXRBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICByZXR1cm4gZmxvYXRBcnJheVswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAqIEByZXR1cm5zIHtmbG9hdH0gUmVhZHMgYSAzMi1iaXQgZmxvYXQgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuXG4gIC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDMyQXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG4gIHVpbnQ4RmxvYXRBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzJdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICByZXR1cm4gZmxvYXRBcnJheVswXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDEuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQ4KG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQxNkxFKG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgNCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgYW5kIGludGVycHJldHMgdGhlIHJlc3VsdCBhcyBhIHR3bydzIGNvbXBsZW1lbnQgc2lnbmVkIHZhbHVlLiBTdXBwb3J0cyB1cCB0byA0OCBiaXRzIG9mIGFjY3VyYWN5LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCB1bWJlciBvZiBieXRlcyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIGJ5dGVMZW5ndGgpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlcyBmcm9tIGJ1ZiBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldCBhbmQgaW50ZXJwcmV0cyB0aGUgcmVzdWx0IGFzIGEgdHdvJ3MgY29tcGxlbWVudCBzaWduZWQgdmFsdWUuIFN1cHBvcnRzIHVwIHRvIDQ4IGJpdHMgb2YgYWNjdXJhY3kuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIHVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDEpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTtcbiAgLy8gZmlyc3QgYnl0ZSBzaGlmdGVkIGFuZCBPUidkIHdpdGggc2Vjb25kIGJ5dGVcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIC8vIGZpcnN0IGJ5dGUgT1InZCB3aXRoIHNlY29uZCBieXRlIHNoaWZ0ZWRcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gKiAweDEwMDAwMDAgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pO1xuICAvLyByYXRoZXIgdGhhbiBzaGlmdGluZyBieSA8PCAyNCwgbXVsdGlwbHkgdGhlIGZpcnN0IGJ5dGUgYW5kIGFkZCBpdCBpbiBzbyB3ZSBkb24ndCByZXRhaW4gdGhlIFwic2lnbiBiaXRcIlxuICAvLyAoYmVjYXVzZSBiaXQtd2lzZSBvcGVyYXRvcnMgYXNzdW1lIGEgMzItYml0IG51bWJlcilcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIHJldHVybiAodGhpc1tvZmZzZXRdIHwgdGhpc1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgKyB0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwO1xuICAvLyByYXRoZXIgdGhhbiBzaGlmdGluZyBieSA8PCAyNCwgbXVsdGlwbHkgdGhlIGxhc3QgYnl0ZSBhbmQgYWRkIGl0IGluIHNvIHdlIGRvbid0IHJldGFpbiB0aGUgXCJzaWduIGJpdFwiXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGxldCByZXN1bHQgPSAwO1xuICBsZXQgbXVsdGlwbGllciA9IDE7IC8vIHdlIHVzZSBhIG11bHRpcGxlciBmb3IgZWFjaCBieXRlXG4gIC8vIHdlJ3JlIGRvaW5nIHRoZSBzYW1lIGxvb3AgYXMgI3JlYWRVSW50TEUsIGp1c3QgYmFja3dhcmRzIVxuICBmb3IgKGxldCBpID0gYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcmVzdWx0ICs9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpKSAqIG11bHRpcGxpZXI7XG4gICAgbXVsdGlwbGllciAqPSAweDEwMDsgLy8gbW92ZSBtdWx0aXBsaWVyIHRvIG5leHQgYnl0ZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGxldCBtdWx0aXBsaWVyID0gMTsgLy8gd2UgdXNlIGEgbXVsdGlwbGVyIGZvciBlYWNoIGJ5dGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGkpICogbXVsdGlwbGllcjtcbiAgICBtdWx0aXBsaWVyICo9IDB4MTAwOyAvLyBtb3ZlIG11bHRpcGxpZXIgdG8gbmV4dCBieXRlXG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBXaGVyZSB0aGUgbmV3IGBCdWZmZXJgIHdpbGwgc3RhcnQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmQ9dGhpcy5sZW5ndGhdIFdoZXJlIHRoZSBuZXcgQnVmZmVyIHdpbGwgZW5kIChub3QgaW5jbHVzaXZlKS4gRGVmYXVsdDogYGJ1Zi5sZW5ndGhgLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IHRoaXNMZW5ndGggKyBzdGFydDtcbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAvLyBpZiB0aGlzIGlzIHN0aWxsIG5lZ2F0aXZlLCB1c2UgMCAodGhhdCBtYXRjaGVzIE5vZGUpXG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuZCA9IHRoaXNMZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IHRoaXNMZW5ndGggKyBlbmQ7XG4gIH1cbiAgLy8gU3BlY2lmeWluZyBlbmQgZ3JlYXRlciB0aGFuIGJ1Zi5sZW5ndGggd2lsbCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0IGFzIHRoYXQgb2YgZW5kIGVxdWFsIHRvIGJ1Zi5sZW5ndGguXG4gIGlmIChlbmQgPiB0aGlzTGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpc0xlbmd0aDtcbiAgfVxuICAvLyBXaGF0IGlmIGVuZCBpcyBsZXNzIHRoYW4gc3RhcnQ/XG4gIGxldCBsZW5ndGggPSBlbmQgLSBzdGFydDtcbiAgaWYgKGxlbmd0aCA8PSAwKSB7XG4gICAgbGVuZ3RoID0gMDsgLy8gcmV0dXJuIGVtcHR5IHZpZXcgb2YgQnVmZmVyISByZXRhaW4gYnl0ZSBvZmZzZXQsIHNldCBsZW5ndGggdG8gMFxuICB9XG4gIC8vIFdyYXAgdGhlIHNhbWUgQXJyYXlCdWZmZXIgb2JqZWN0IGJ1dCBzcGVjaWZ5IHRoZSBzdGFydC9lbmQgdG8gXCJjcm9wXCIgd2l0aFxuICByZXR1cm4gdGhpcy5fc2xpY2UodGhpcy5ieXRlT2Zmc2V0ICsgc3RhcnQsIGxlbmd0aCk7XG59O1xuQnVmZmVyJDEucHJvdG90eXBlLl9zbGljZSA9IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodGhpcy5idWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kPXRoaXMubGVuZ3RoXSBXaGVyZSB0aGUgbmV3IEJ1ZmZlciB3aWxsIGVuZCAobm90IGluY2x1c2l2ZSkuIERlZmF1bHQ6IGBidWYubGVuZ3RoYC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5zdWJhcnJheSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGJ1ZiBhcyBhbiBhcnJheSBvZiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlcnMgYW5kIHN3YXBzIHRoZSBieXRlIG9yZGVyIGluLXBsYWNlLlxuICogVGhyb3dzIEVSUl9JTlZBTElEX0JVRkZFUl9TSVpFIGlmIGJ1Zi5sZW5ndGggaXMgbm90IGEgbXVsdGlwbGUgb2YgMi5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzZWNvbmQgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDEpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpLCBzZWNvbmQpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMSwgZmlyc3QpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGJ1ZiBhcyBhbiBhcnJheSBvZiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgYW5kIHN3YXBzIHRoZSBieXRlIG9yZGVyIGluLXBsYWNlLlxuICogVGhyb3dzIEVSUl9JTlZBTElEX0JVRkZFUl9TSVpFIGlmIGJ1Zi5sZW5ndGggaXMgbm90IGEgbXVsdGlwbGUgb2YgNC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzZWNvbmQgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDEpO1xuICAgIGNvbnN0IHRoaXJkID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAyKTtcbiAgICBjb25zdCBmb3VydGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDMpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpLCBmb3VydGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMSwgdGhpcmQpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMiwgc2Vjb25kKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDMsIGZpcnN0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgNjQtYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDguXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA4KSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgY29uc3Qgc2Vjb25kID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAxKTtcbiAgICBjb25zdCB0aGlyZCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgMik7XG4gICAgY29uc3QgZm91cnRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAzKTtcbiAgICBjb25zdCBmaWZ0aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNCk7XG4gICAgY29uc3Qgc2l4dGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDUpO1xuICAgIGNvbnN0IHNldmVudGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDYpO1xuICAgIGNvbnN0IGVpZ2h0aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNyk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGksIGVpZ2h0aCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyAxLCBzZXZlbnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDIsIHNpeHRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDMsIGZpZnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDQsIGZvdXJ0aCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyA1LCB0aGlyZCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyA2LCBzZWNvbmQpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgNywgZmlyc3QpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIC8vIFRha2UgYWR2YW50YWdlIG9mIHNsaWNlIHdvcmtpbmcgb24gXCJBcnJheS1saWtlXCIgb2JqZWN0cyAoanVzdCBsaWtlIGBhcmd1bWVudHNgKVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlI0FycmF5LWxpa2Vfb2JqZWN0c1xuICAgIGRhdGE6IFtdLnNsaWNlLmNhbGwodGhpcylcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBUaGUgYnl0ZSBvZmZzZXQgdG8gc3RhcnQgZGVjb2RpbmcgYXRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZF0gVGhlIGJ5dGUgb2Zmc2V0IHRvIHN0b3AgZGVjb2RpbmcgYXQgKG5vdCBpbmNsdXNpdmUpLiBgYnVmLmxlbmd0aGAgZGVmYXVsdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIC8vIGZhc3QgY2FzZSBvZiBubyBhcmdzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMudG9UaUJ1ZmZlcigpLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIGlmIChzdGFydCA+PSBsZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7IC8vIHN0YXJ0IGlzIHBhc3QgZW5kIG9mIGJ1ZmZlciwgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG4gIGlmIChlbmQgPiBsZW5ndGggfHwgdHlwZW9mIGVuZCAhPT0gJ251bWJlcicpIHtcbiAgICAvLyBubyBlbmQgc3BlY2lmaWVkLCBvciBwYXN0IGVuZCBvZiBidWZmZXIsIHVzZSBsZW5ndGggb2YgYnVmZmVyXG4gICAgZW5kID0gbGVuZ3RoO1xuICB9IC8vIGVsc2Uga2VlcCBlbmQgYXMgcGFzc2VkIGluXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJzsgLy8gaWYgZW5kIGlzIGJlZm9yZSBzdGFydCByZXR1cm4gZW1wdHkgc3RyaW5nXG4gIH1cblxuICAvLyBJZiBzdGFydCAhPT0gMCBhbmQgZW5kICE9PSBsZW5ndGgsIG1heWJlIHdlIHNob3VsZCBkbyBhIEJ1ZmZlci5zdWJhcnJheS9zbGljZSBvdmVyIHRoZSByYW5nZSBhbmQgY2FsbCB0b1N0cmluZygpIG9uIHRoYXQ/XG4gIGlmIChzdGFydCAhPT0gMCB8fCBlbmQgIT09IGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIGJhc2UgY2FzZSwgc3RhcnQgaXMgMCwgZW5kIGlzIGxlbmd0aFxuICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9IGVsc2Uge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBUaHJvdyBpZiBiYWQgZW5jb2RpbmchXG4gICAgaWYgKCFCdWZmZXIkMS5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdGhpcy50b1RpQnVmZmVyKCkudG9TdHJpbmcoKTsgLy8gd2UgcmV0dXJuIHV0Zi04IGJ5IGRlZmF1bHQgbmF0aXZlbHlcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICByZXR1cm4gVGkuVXRpbHMuYmFzZTY0ZW5jb2RlKHRoaXMudG9UaUJ1ZmZlcigpLnRvQmxvYigpKS50b1N0cmluZygpO1xuICB9XG4gIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gdGhpcy5oZXhTbGljZSgwLCBsZW5ndGgpO1xuICB9XG4gIGlmIChlbmNvZGluZyA9PT0gJ2xhdGluMScgfHwgZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgbGV0IGxhdGluMVN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGVhY2ggb25lIGlzIGEgXCJieXRlXCJcbiAgICAgIGxhdGluMVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKSk7XG4gICAgfVxuICAgIHJldHVybiBsYXRpbjFTdHJpbmc7XG4gIH1cbiAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgbGV0IGFzY2lpID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgLy8gd2Ugc3RvcmUgYnl0ZXMgKDgtYml0KSwgYnV0IGFzY2lpIGlzIDctYml0LiBOb2RlIFwibWFza3NcIiB0aGUgbGFzdCBiaXQgb2ZmLCBzbyBsZXQncyBkbyB0aGUgc2FtZVxuICAgICAgYXNjaWkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmdldEFkanVzdGVkSW5kZXgoaSkgJiAweDdGKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzY2lpO1xuICB9XG5cbiAgLy8gVUNTMi9VVEYxNlxuICByZXR1cm4gdGhpcy51Y3MyU2xpY2UoMCwgbGVuZ3RoKTtcbn07XG5CdWZmZXIkMS5wcm90b3R5cGUuZ2V0QWRqdXN0ZWRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICByZXR1cm4gdGhpc1tpbmRleF07XG59O1xuQnVmZmVyJDEucHJvdG90eXBlLnNldEFkanVzdGVkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gIHJldHVybiB0aGlzW2luZGV4XSA9IHZhbHVlO1xufTtcbkJ1ZmZlciQxLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGxldCBoZXhTdHIgPSAnJztcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAvLyBlYWNoIG9uZSBpcyBhIFwiYnl0ZVwiXG4gICAgbGV0IGhleCA9ICh0aGlzLmdldEFkanVzdGVkSW5kZXgoaSkgJiAweGZmKS50b1N0cmluZygxNik7XG4gICAgaGV4ID0gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICBoZXhTdHIgKz0gaGV4O1xuICB9XG4gIHJldHVybiBoZXhTdHI7XG59O1xuQnVmZmVyJDEucHJvdG90eXBlLnVjczJTbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGxldCBvdXQgPSAnJztcbiAgbGV0IGkgPSBzdGFydDtcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAvLyB1dGYtMTYvdWNzLTIgaXMgMi1ieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgY29uc3QgYnl0ZTEgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSsrKTtcbiAgICBjb25zdCBieXRlMiA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKyspO1xuICAgIGNvbnN0IGNvZGVfdW5pdCA9IChieXRlMiA8PCA4KSArIGJ5dGUxOyAvLyB3ZSBtYXNoIHRvZ2V0aGVyIHRoZSB0d28gYnl0ZXNcbiAgICBvdXQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZV91bml0KTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gbWV0aG9kIGZvciBpbnRlcmFjdGluZyB3aXRoIFRpIEFQSXMgdGhhdCByZXF1aXJlIGEgVGkuQnVmZmVyXG4gKiBAcmV0dXJucyB7VGkuQnVmZmVyfSB0aGUgdW5kZXJseWluZyBUaS5CdWZmZXIgYmFja2luZyB0aGlzIEJ1ZmZlciBpbnN0YW5jZVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUudG9UaUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgdGlCdWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgIGxlbmd0aDogdGhpcy5sZW5ndGhcbiAgfSk7XG4gIGNvcHlCdWZmZXIodGhpcywgdGlCdWZmZXIsIDAsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRpQnVmZmVyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc3JjIHNvdXJjZSBCdWZmZXIgd2UncmUgY29weWluZyBmcm9tXG4gKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gZGVzdCBkZXN0aW5hdGlvbiBUaS5CdWZmZXIgd2UncmUgY29weWluZyBpbnRvXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBzdGFydCBvZmZzZXQgd2UncmUgY29weWluZyB0byBpbiBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHlcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZFxuICovXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgZGVzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgY29uc3QgZGVzdExlbmd0aCA9IGRlc3QubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkZXN0SW5kZXggPSBpICsgb2Zmc2V0O1xuICAgIC8vIGFyZSB3ZSB0cnlpbmcgdG8gd3JpdGUgcGFzdCBlbmQgb2YgZGVzdGluYXRpb24/IE9yIHJlYWQgcGFzdCBlbmQgb2Ygc291cmNlPyBTdG9wIVxuICAgIGlmIChkZXN0SW5kZXggPj0gZGVzdExlbmd0aCB8fCBpID49IHNyY0xlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlc3RbZGVzdEluZGV4XSA9IHNyY1tpXTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGl0ZXJhdG9yIGZvciBidWYgdmFsdWVzIChieXRlcylcbiAqIEByZXR1cm5zIHtJdGVyYXRvcn1cbiAqL1xuLy8gVE9ETzogTW92ZSB0byBTbG93QnVmZmVyP1xuQnVmZmVyJDEucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYnVmZmVyID0gdGhpcztcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZCA9IHRoaXMubGVuZ3RoO1xuICBjb25zdCBteUl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiBidWZmZXIuZ2V0QWRqdXN0ZWRJbmRleChuZXh0SW5kZXgpLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIHJldHVybiBteUl0ZXJhdG9yO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBidWZmZXIgaXMgdXNlZCBpbiBhIGZvci4ub2YgbG9vcC4gRGVsZWdhdGVzIHRvICN2YWx1ZXMoKVxuICogQHJldHVybnMge0l0ZXJhdG9yfVxuICovXG4vLyBUT0RPOiBNb3ZlIHRvIFNsb3dCdWZmZXI/XG5CdWZmZXIkMS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBzdHJpbmcgdG8gYnVmIGF0IG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIGNoYXJhY3RlciBlbmNvZGluZyBpbiBlbmNvZGluZy5cbiAqIFRoZSBsZW5ndGggcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIElmIGJ1ZiBkaWQgbm90IGNvbnRhaW4gZW5vdWdoIHNwYWNlIHRvXG4gKiBmaXQgdGhlIGVudGlyZSBzdHJpbmcsIG9ubHkgcGFydCBvZiBzdHJpbmcgd2lsbCBiZSB3cml0dGVuLiBIb3dldmVyLCBwYXJ0aWFsbHkgZW5jb2RlZFxuICogY2hhcmFjdGVycyB3aWxsIG5vdCBiZSB3cml0dGVuLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gd3JpdGUgdG8gYGJ1ZmAuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlIHN0cmluZ1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoPWJ1Zi5sZW5ndGggLSBvZmZzZXRdIE51bWJlciBvZiBieXRlcyB0byB3cml0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGluZz0ndXRmOCddIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2Ygc3RyaW5nXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IDA7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBjYXAgYGxlbmd0aGAgYXQgdGhlIGxlbmd0aCBvZiBvdXIgYnVmZmVyXG4gICAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JztcbiAgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IGByZW1haW5pbmdgIGJ5dGVzIG9mIG91ciBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkvYnVmZmVyXG4gIGNvbnN0IHNyYyA9IGZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZyk7IC8vIEZJWE1FOiBDYW4gd2UgbGV0IGl0IGtub3cgdG8gb25seSBjb252ZXJ0IGByZW1haW5pbmdgIGJ5dGVzP1xuXG4gIC8vIHRoZW4gc3RpY2sgdGhhdCBpbnRvIG91ciBidWZmZXIgc3RhcnRpbmcgYXQgYG9mZnNldGAhXG4gIHJldHVybiBzcmMuY29weSh0aGlzLCBvZmZzZXQsIDAsIGxlbmd0aCk7XG59O1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA4KTtcbiAgZG91YmxlQXJyYXlbMF0gPSB2YWx1ZTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzddKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzZdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzVdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzRdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzNdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzJdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzFdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzBdKTtcbiAgcmV0dXJuIG9mZnNldDsgLy8gYXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhZGRlZCA4IHRvIG9mZnNldFxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA4KTtcbiAgZG91YmxlQXJyYXlbMF0gPSB2YWx1ZTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzBdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzFdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzJdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzNdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzRdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzVdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzZdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OERvdWJsZUFycmF5WzddKTtcbiAgcmV0dXJuIG9mZnNldDsgLy8gYXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhZGRlZCA4IHRvIG9mZnNldFxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICBmbG9hdEFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzNdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzBdKTtcbiAgcmV0dXJuIG9mZnNldDsgLy8gYXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhZGRlZCA0IHRvIG9mZnNldFxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICBmbG9hdEFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzBdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzNdKTtcbiAgcmV0dXJuIG9mZnNldDsgLy8gYXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhZGRlZCA0IHRvIG9mZnNldFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0xMjgsIDEyNyk7XG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgLy8ganVzdCB3cml0ZSBpdCBub3JtYWxseVxuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gc2lnbmVkIHRvIDIncyBjb21wbGVtZW50IGJpdHNcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCAweEZGICsgdmFsdWUgKyAxKTsgLy8gbWF4IHZhbHVlLCBwbHVzIHRoZSBuZWdhdGl2ZSBudW1iZXIsIGFkZCBvbmVcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyAxO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSA+Pj4gOCk7IC8vIGp1c3Qgc2hpZnQgb3ZlciBhIGJ5dGVcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlICYgMHhGRik7IC8vIG1hc2sgdG8gZmlyc3QgYnl0ZVxuXG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSAmIDB4RkYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICByZXR1cm4gb2Zmc2V0ICsgMjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0Nyk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlID4+PiAyNCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMywgdmFsdWUgJiAweEZGKTtcbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSAmIDB4RkYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlID4+PiAyNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGNvbnN0IG1pbk1heEJhc2UgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtbWluTWF4QmFzZSwgbWluTWF4QmFzZSAtIDEpO1xuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgdmFsdWUgPSBtaW5NYXhCYXNlICogMiArIHZhbHVlO1xuICB9XG4gIGxldCBtdWx0aXBsaWVyID0gMTtcbiAgZm9yIChsZXQgaSA9IGJ5dGVMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBieXRlVmFsdWUgPSB2YWx1ZSAvIG11bHRpcGxpZXIgJiAweEZGO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgIG11bHRpcGxpZXIgKj0gMHgxMDA7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgY29uc3QgbWluTWF4QmFzZSA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC1taW5NYXhCYXNlLCBtaW5NYXhCYXNlIC0gMSk7XG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICB2YWx1ZSA9IG1pbk1heEJhc2UgKiAyICsgdmFsdWU7XG4gIH1cbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgIGxldCBieXRlVmFsdWUgPSB2YWx1ZSAvIG11bHRpcGxpZXIgJiAweEZGO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgIG11bHRpcGxpZXIgKj0gMFgxMDA7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDI1NSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlKTtcbiAgcmV0dXJuIG9mZnNldCArIDE7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDY1NTM1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDY1NTM1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDQyOTQ5NjcyOTUpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSA+Pj4gMjQpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDQpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA0Mjk0OTY3Mjk1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiAxNik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAzLCB2YWx1ZSA+Pj4gMjQpO1xuICByZXR1cm4gb2Zmc2V0ICsgNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMSk7XG4gIGxldCBtdWx0aXBsaWVyID0gMTtcbiAgZm9yIChsZXQgaSA9IGJ5dGVMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBieXRlVmFsdWUgPSB2YWx1ZSAvIG11bHRpcGxpZXIgJiAweEZGO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyBpLCBieXRlVmFsdWUpO1xuICAgIG11bHRpcGxpZXIgKj0gMFgxMDA7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDEpO1xuICBsZXQgbXVsdGlwbGllciA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbn07XG5cbi8vIFRPRE86IEltcGxlbWVudCByZW1haW5pbmcgaW5zdGFuY2UgbWV0aG9kczpcbi8vIGJ1Zi5sYXN0SW5kZXhPZih2YWx1ZVssIGJ5dGVPZmZzZXRdWywgZW5jb2RpbmddKVxuLy8gYnVmLnJlYWRCaWdJbnQ2NEJFKFtvZmZzZXRdKVxuLy8gYnVmLnJlYWRCaWdJbnQ2NExFKFtvZmZzZXRdKVxuLy8gYnVmLnJlYWRCaWdVSW50NjRCRShbb2Zmc2V0XSlcbi8vIGJ1Zi5yZWFkQmlnVUludDY0TEUoW29mZnNldF0pXG4vLyBidWYud3JpdGVCaWdJbnQ2NEJFKHZhbHVlWywgb2Zmc2V0XSlcbi8vIGJ1Zi53cml0ZUJpZ0ludDY0TEUodmFsdWVbLCBvZmZzZXRdKVxuLy8gYnVmLndyaXRlQmlnVUludDY0QkUodmFsdWVbLCBvZmZzZXRdKVxuLy8gYnVmLndyaXRlQmlnVUludDY0TEUodmFsdWVbLCBvZmZzZXRdKVxuXG4vLyBGSVhNRTogV2UgbmVlZCB0byBtaW5pbWl6ZSB1c2luZyBhIGJhY2tpbmcgVGkuQnVmZmVyIHdoZW5ldmVyIHBvc3NpYmxlLCBiZWNhdXNlXG4vLyBnb2luZyBiYWNrIGFuZCBmb3J0aCBhY3Jvc3MgdGhlIGJyaWRnZSBmb3IgZXZlcnkgYnl0ZSBpcyAqdmVyeSogZXhwZW5zaXZlXG4vLyBJZGVhbGx5IHdlIHNob3VsZCBoYXZlIGEgXCJTbG93QnVmZmVyXCIgdGhhdCBpcyB1c2VkIHdoZW4gd2UgZXhwbGljaXRseSB3cmFwIGEgVGkuQnVmZmVyXG4vLyBTbyB0aGF0IHdyaXRlcyBhcmUgcGFzc2VkIHRocm91Z2guIE90aGVyd2lzZSB3ZSBzaG91bGQgYXZvaWQgdXNpbmcgb25lIGF0IGFsbCBjb3N0c1xuLy8gaS5lLiB3aGVuIHdlIGRvIEJ1ZmZlci5jb25jYXQgYW5kIGFyZSBvbmx5IGRvaW5nIHJlYWRzIC0gd2h5IGRvIHdlIG5lZWQgYSBUaS5CdWZmZXI/XG4vLyBDYW4gd2UgaGF2ZSBUaS5CdWZmZXIgcmVhbGx5IGp1c3Qgd3JhcCBhIFVpbnQ4QXJyYXkgYW5kIGFkZCBpdCdzIG93biBtZXRob2RzP1xuQnVmZmVyJDEuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihsZW5ndGgpO1xufTtcbkJ1ZmZlciQxLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG59O1xuQnVmZmVyJDEuYWxsb2MgPSBmdW5jdGlvbiAobGVuZ3RoLCBmaWxsID0gMCwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgY29uc3QgYnVmID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgaWYgKGZpbGwgIT09IDApIHtcbiAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFR5cGVkQXJyYXl8RGF0YVZpZXd8QXJyYXlCdWZmZXJ8U2hhcmVkQXJyYXlCdWZmZXJ9IHN0cmluZyBvcmlnaW5hbCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB3aG9zZSBieXRlIGxlbmd0aCB3ZSBuZWVkIHRvIGdyYWJcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5CdWZmZXIkMS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKEJ1ZmZlciQxLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoOyAvLyByZXR1cm4gQnVmZmVyJ3MgbGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoOyAvLyBUeXBlZEFycmF5LCBBcnJheUJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIsIERhdGFWaWV3XG4gIH1cblxuICBsZXQgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgc3dpdGNoIChlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhCeXRlTGVuZ3RoKHN0cmluZyk7XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0ZjE2LWxlJzpcbiAgICAgIHJldHVybiAyICogbGVuZ3RoO1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gbGVuZ3RoIC8gMjtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gU3VidHJhY3QgdXAgdG8gdHdvIHBhZGRpbmcgY2hhcnMgZnJvbSBlbmQgb2Ygc3RyaW5nIVxuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IobGVuZ3RoICogMyAvIDQpO1xuICAgIC8vIGRyb3AgZnJhY3Rpb25hbCB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIHV0ZjhCeXRlTGVuZ3RoKHN0cmluZyk7XG59O1xuQnVmZmVyJDEuY29tcGFyZSA9IGZ1bmN0aW9uIChidWYxLCBidWYyKSB7XG4gIGlmICghQnVmZmVyJDEuaXNCdWZmZXIoYnVmMSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJidWYxXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBidWYxfWApO1xuICB9XG4gIC8vIFRPRE86IFdyYXAgVUludDhBcnJheSBhcmdzIGluIGJ1ZmZlcnM/XG4gIHJldHVybiBidWYxLmNvbXBhcmUoYnVmMik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyW118VUludDhBcnJheVtdfSBsaXN0IGxpc3Qgb2YgQnVmZmVycyB0byBjb25jYXRlbmF0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbdG90YWxMZW5ndGhdIFRvdGFsIGxlbmd0aCBvZiB0aGUgQnVmZmVyIGluc3RhbmNlcyBpbiBsaXN0IHdoZW4gY29uY2F0ZW5hdGVkLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuQnVmZmVyJDEuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheScpO1xuICB9XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcigpOyAvLyBvbmUgZW1wdHkgQnVmZmVyIVxuICB9XG4gIC8vIGFsbG9jYXRlIG9uZSBCdWZmZXIgb2YgYHRvdGFsTGVuZ3RoYD8gQ2FwIGF0IHRvdGFsTGVuZ3RoP1xuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICAvLyBnZW5lcmF0ZSB0aGUgdG90YWwgbGVuZ3RoIGZyb20gZWFjaCBidWZmZXIncyBsZW5ndGg/XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KHJlc3VsdCwgcG9zaXRpb24pO1xuICAgIHBvc2l0aW9uICs9IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKHBvc2l0aW9uID49IHRvdGFsTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIHBvc3NpYmxlIGVuY29kaW5nIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5CdWZmZXIkMS5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBWQUxJRF9FTkNPRElOR1MuaW5jbHVkZXMoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqIHBvc3NpYmxlIEJ1ZmZlciBpbnN0YW5jZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkJ1ZmZlciQxLmlzQnVmZmVyID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIG9iaiAhPT0gdW5kZWZpbmVkICYmIChvYmogaW5zdGFuY2VvZiBCdWZmZXIkMSB8fCBvYmpbaXNCdWZmZXJdID09PSB0cnVlKTtcbn07XG5sZXQgSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcbi8vIE92ZXJyaWRlIGhvdyBidWZmZXJzIGFyZSBwcmVzZW50ZWQgYnkgdXRpbC5pbnNwZWN0KCkuXG5CdWZmZXIkMS5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBmdW5jdGlvbiAocmVjdXJzZVRpbWVzLCBjdHgpIHtcbiAgY29uc3QgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gIGNvbnN0IGFjdHVhbE1heCA9IE1hdGgubWluKG1heCwgdGhpcy5sZW5ndGgpO1xuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG1heDtcbiAgbGV0IHN0ciA9IHRoaXMuc2xpY2UoMCwgYWN0dWFsTWF4KS50b1N0cmluZygnaGV4JykucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKCk7XG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgc3RyICs9IGAgLi4uICR7cmVtYWluaW5nfSBtb3JlIGJ5dGUke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gO1xuICB9XG4gIC8vIEluc3BlY3Qgc3BlY2lhbCBwcm9wZXJ0aWVzIGFzIHdlbGwsIGlmIHBvc3NpYmxlLlxuICBpZiAoY3R4KSB7XG4gICAgbGV0IGV4dHJhcyA9IGZhbHNlO1xuICAgIGNvbnN0IGZpbHRlciA9IGN0eC5zaG93SGlkZGVuID8gQUxMX1BST1BFUlRJRVMkMSA6IE9OTFlfRU5VTUVSQUJMRSQxO1xuICAgIGNvbnN0IG9iaiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh0aGlzLCBmaWx0ZXIpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgIGV4dHJhcyA9IHRydWU7XG4gICAgICBvYmpba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgfVxuICAgICAgLy8gJ1tPYmplY3Q6IG51bGwgcHJvdG90eXBlXSB7Jy5sZW5ndGggPT09IDI2XG4gICAgICAvLyBUaGlzIGlzIGd1YXJkZWQgd2l0aCBhIHRlc3QuXG4gICAgICBzdHIgKz0gaW5zcGVjdChvYmosIHtcbiAgICAgICAgLi4uY3R4LFxuICAgICAgICBicmVha0xlbmd0aDogSW5maW5pdHksXG4gICAgICAgIGNvbXBhY3Q6IHRydWVcbiAgICAgIH0pLnNsaWNlKDI3LCAtMik7XG4gICAgfVxuICB9XG4gIHJldHVybiBgPCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke3N0cn0+YDtcbn07XG5CdWZmZXIkMS5wcm90b3R5cGUuaW5zcGVjdCA9IEJ1ZmZlciQxLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXTtcblxuLy8gSEFDSzogQXJyYXlCdWZmZXIuaXNWaWV3IHJldHVybnMgdHJ1ZSBmb3IgTm9kZSBCdWZmZXIsIGJ1dCBmYWxzZSBmb3IgdXMuIFVudGlsIHdlIGNhbiBleHRlbmQgVWludDhBcnJheSwgd2UgbmVlZCB0byBoYWNrIHRoaXMgc25pZmZpbmcgbWV0aG9kXG5jb25zdCBBcnJheUJ1ZmZlcklzVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldztcbkFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uICh0aGluZykge1xuICByZXR1cm4gQXJyYXlCdWZmZXJJc1ZpZXcodGhpbmcpIHx8IHRoaW5nIGluc3RhbmNlb2YgQnVmZmVyJDE7XG59O1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNsb3dCdWZmZXIucHJvdG90eXBlLCBCdWZmZXIkMS5wcm90b3R5cGUpO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNsb3dCdWZmZXIsIEJ1ZmZlciQxKTtcbnZhciBCdWZmZXJNb2R1bGUgPSB7XG4gIEJ1ZmZlcjogQnVmZmVyJDEsXG4gIC8vIFRPRE86IEltcGxlbWVudCB0cmFuc2NvZGUoKSFcbiAgdHJhbnNjb2RlOiAoX3NvdXJjZSwgX2Zyb21FbmNvZGluZywgX3RvRW5jb2RpbmcpID0+IHt9LFxuICBJTlNQRUNUX01BWF9CWVRFUzogNTAsXG4gIGtNYXhMZW5ndGg6IDIxNDc0ODM2NDcsXG4gIGtTdHJpbmdNYXhMZW5ndGg6IDEwNzM3NDE3OTksXG4gIGNvbnN0YW50czoge1xuICAgIE1BWF9MRU5HVEg6IDIxNDc0ODM2NDcsXG4gICAgTUFYX1NUUklOR19MRU5HVEg6IDEwNzM3NDE3OTlcbiAgfVxufTtcblxuLyoqXG4gKiBTZWFyY2hlcyBhIEJ1ZmZlciBmb3IgdGhlIGluZGV4IG9mIGEgc2luZ2xlIGJ5dGUuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byBzZWFyY2hcbiAqIEBwYXJhbSB7aW50ZWdlcn0gc2luZ2xlQnl0ZSBieXRlIHdlJ3JlIGxvb2tpbmcgZm9yXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBzdGFydCBvZmZzZXQgd2Ugc2VhcmNoIGF0XG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuZnVuY3Rpb24gaW5kZXhPZihidWZmZXIsIHNpbmdsZUJ5dGUsIG9mZnNldCkge1xuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYnVmZmVyLmdldEFkanVzdGVkSW5kZXgoaSkgPT09IHNpbmdsZUJ5dGUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBleHBsaWNpdGx5IGF2b2lkcyBiaXR3aXNlIG9wZXJhdGlvbnMgYmVjYXVzZSBKUyBhc3N1bWVzIDMyLWJpdCBzZXF1ZW5jZXMgZm9yIHRob3NlLlxuICogSXQncyBwb3NzaWJsZSB3ZSBtYXkgYmUgYWJsZSB0byB1c2UgdGhlbSB3aGVuIGJ5dGVMZW5ndGggPCA0IGlmIHRoYXQncyBmYXN0ZXIuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB1bnNpZ25lZFZhbHVlIHZhbHVlIGJlZm9yZSBjb252ZXJ0aW5nIGJhY2sgdG8gc2lnbmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gdGhlIHNpZ25lZCB2YWx1ZSB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSB1bnNpZ25lZCB2YWx1ZSdzIGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCBiaXRMZW5ndGggPSBieXRlTGVuZ3RoICogODtcbiAgY29uc3QgbWF4UG9zaXRpdmVWYWx1ZSA9IE1hdGgucG93KDIsIGJpdExlbmd0aCAtIDEpO1xuICBpZiAodW5zaWduZWRWYWx1ZSA8IG1heFBvc2l0aXZlVmFsdWUpIHtcbiAgICByZXR1cm4gdW5zaWduZWRWYWx1ZTtcbiAgfVxuICBjb25zdCBtYXhVbnNpZ25lZFZhbHVlID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKTtcbiAgdW5zaWduZWRWYWx1ZSAtPSBtYXhVbnNpZ25lZFZhbHVlO1xuICByZXR1cm4gdW5zaWduZWRWYWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIHV0Zi04IHN0cmluZ1xuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cbmZ1bmN0aW9uIHV0ZjhCeXRlTGVuZ3RoKHN0cmluZykge1xuICAvLyBKdXN0IGNvbnZlcnQgdG8gYSBUaS5CdWZmZXIgYW5kIGxldCBpdCB0ZWxsIHVzIHRoZSBsZW5ndGhcbiAgY29uc3QgYnVmID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHR5cGU6IFRpLkNvZGVjLkNIQVJTRVRfVVRGOFxuICB9KTtcbiAgY29uc3QgbGVuZ3RoID0gYnVmLmxlbmd0aDtcbiAgYnVmLnJlbGVhc2UoKTsgLy8gcmVsZWFzZSB0aGUgYnVmZmVyIHNpbmNlIHdlIGp1c3QgbmVlZGVkIHRoZSBsZW5ndGhcbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB3ZSdyZSBvcGVyYXRpbmcgb25cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHVzZXIgc3VwcGxpZWQgb2Zmc2V0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBpbiByYW5nZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQoYnVmZmVyLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIGJ5dGVMZW5ndGg7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGVuZE9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgdmFsdWUgb2YgXCJvZmZzZXRcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgPj0gMCBhbmQgPD0gJHtlbmRPZmZzZXR9LiBSZWNlaXZlZCAke29mZnNldH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgdXNlci1zdXBwbGllZCB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBtaW4gbWluaW11bSB2YWxpZCB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBtYXggbWF4aW11bSB2YWxpZCB2YWx1ZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSB2YWx1ZSBvZiBcInZhbHVlXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlID49ICR7bWlufSBhbmQgPD0gJHttYXh9LiBSZWNlaXZlZCAke3ZhbHVlfWApO1xuICB9XG59XG5sZXQgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gZmFsc2U7XG5sZXQgbm9kZU1vZHVsZXNDaGVja0NvdW50ZXIgPSAwO1xuY29uc3QgYnVmZmVyV2FybmluZyA9ICdCdWZmZXIoKSBpcyBkZXByZWNhdGVkIGR1ZSB0byBzZWN1cml0eSBhbmQgdXNhYmlsaXR5ICcgKyAnaXNzdWVzLiBQbGVhc2UgdXNlIHRoZSBCdWZmZXIuYWxsb2MoKSwgJyArICdCdWZmZXIuYWxsb2NVbnNhZmUoKSwgb3IgQnVmZmVyLmZyb20oKSBtZXRob2RzIGluc3RlYWQuJztcbmZ1bmN0aW9uIHNob3dGbGFnZ2VkRGVwcmVjYXRpb24oKSB7XG4gIGlmIChidWZmZXJXYXJuaW5nQWxyZWFkeUVtaXR0ZWQgfHwgKytub2RlTW9kdWxlc0NoZWNrQ291bnRlciA+IDEwMDAwIHx8IGlzSW5zaWRlTm9kZU1vZHVsZXMoKSkge1xuICAgIC8vIFdlIGRvbid0IGVtaXQgYSB3YXJuaW5nLCBiZWNhdXNlIHdlIGVpdGhlcjpcbiAgICAvLyAtIEFscmVhZHkgZGlkIHNvLCBvclxuICAgIC8vIC0gQWxyZWFkeSBjaGVja2VkIHRvbyBtYW55IHRpbWVzIHdoZXRoZXIgYSBjYWxsIGlzIGNvbWluZ1xuICAgIC8vICAgZnJvbSBub2RlX21vZHVsZXMgYW5kIHdhbnQgdG8gc3RvcCBzbG93aW5nIGRvd24gdGhpbmdzLCBvclxuICAgIC8vIC0gVGhlIGNvZGUgaXMgaW5zaWRlIGBub2RlX21vZHVsZXNgLlxuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVtaXRXYXJuaW5nKGJ1ZmZlcldhcm5pbmcsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDAwNScpO1xuICBidWZmZXJXYXJuaW5nQWxyZWFkeUVtaXR0ZWQgPSB0cnVlO1xufVxuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb25zdCB7XG4gIEFMTF9QUk9QRVJUSUVTLFxuICBPTkxZX0VOVU1FUkFCTEVcbn0gPSBwcm9wZXJ0eUZpbHRlcjtcbmNvbnN0IEJvb2xlYW5Qcm90b3R5cGUgPSBCb29sZWFuLnByb3RvdHlwZTtcbmNvbnN0IERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbmNvbnN0IEVycm9yUHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuY29uc3QgTnVtYmVyUHJvdG90eXBlID0gTnVtYmVyLnByb3RvdHlwZTtcbmNvbnN0IE1hcFByb3RvdHlwZSA9IE1hcC5wcm90b3R5cGU7XG5jb25zdCBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuY29uc3QgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbmNvbnN0IFNldFByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XG5jb25zdCBTeW1ib2xQcm90b3R5cGUgPSBTeW1ib2wucHJvdG90eXBlO1xuY29uc3QgaXNJb3MgPSBbJ2lwYWQnLCAnaXBob25lJ10uaW5jbHVkZXMoXCJhbmRyb2lkXCIpO1xuY29uc3Qge1xuICBFUlJfSU5WQUxJRF9BUkdfVFlQRVxufSA9IGNvZGVzO1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbmNvbnN0IHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG5sZXQgaGV4U2xpY2UgPSB1bmN1cnJ5VGhpcyhCdWZmZXJNb2R1bGUuQnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSk7XG5jb25zdCBidWlsdEluT2JqZWN0cyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZ2xvYmFsKS5maWx0ZXIoZSA9PiAvXihbQS1aXVthLXpdKykrJC8udGVzdChlKSkpO1xuY29uc3QgaW5zcGVjdERlZmF1bHRPcHRpb25zID0gT2JqZWN0LnNlYWwoe1xuICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgZGVwdGg6IDIsXG4gIGNvbG9yczogZmFsc2UsXG4gIGN1c3RvbUluc3BlY3Q6IHRydWUsXG4gIHNob3dQcm94eTogZmFsc2UsXG4gIG1heEFycmF5TGVuZ3RoOiAxMDAsXG4gIGJyZWFrTGVuZ3RoOiA4MCxcbiAgY29tcGFjdDogMyxcbiAgc29ydGVkOiBmYWxzZSxcbiAgZ2V0dGVyczogZmFsc2Vcbn0pO1xuY29uc3Qga09iamVjdFR5cGUgPSAwO1xuY29uc3Qga0FycmF5VHlwZSA9IDE7XG5jb25zdCBrQXJyYXlFeHRyYXNUeXBlID0gMjtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgxZlxceDI3XFx4NWNdLztcbmNvbnN0IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyID0gL1tcXHgwMC1cXHgxZlxceDI3XFx4NWNdL2c7XG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHBTaW5nbGUgPSAvW1xceDAwLVxceDFmXFx4NWNdLztcbmNvbnN0IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyU2luZ2xlID0gL1tcXHgwMC1cXHgxZlxceDVjXS9nO1xuLyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cbmNvbnN0IGtleVN0clJlZ0V4cCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKiQvO1xuY29uc3QgbnVtYmVyUmVnRXhwID0gL14oMHxbMS05XVswLTldKikkLztcbmNvbnN0IG5vZGVNb2R1bGVzUmVnRXhwID0gL1svXFxcXF1ub2RlX21vZHVsZXNbL1xcXFxdKC4rPykoPz1bL1xcXFxdKS9nO1xuY29uc3Qga01pbkxpbmVMZW5ndGggPSAxNjtcblxuLy8gQ29uc3RhbnRzIHRvIG1hcCB0aGUgaXRlcmF0b3Igc3RhdGUuXG5jb25zdCBrV2VhayA9IDA7XG5jb25zdCBrSXRlcmF0b3IgPSAxO1xuY29uc3Qga01hcEVudHJpZXMgPSAyO1xuXG4vLyBFc2NhcGVkIHNwZWNpYWwgY2hhcmFjdGVycy4gVXNlIGVtcHR5IHN0cmluZ3MgdG8gZmlsbCB1cCB1bnVzZWQgZW50cmllcy5cbi8qIGVzbGludC1kaXNhYmxlIHF1b3RlcyAqL1xuY29uc3QgbWV0YSA9IFsnXFxcXHUwMDAwJywgJ1xcXFx1MDAwMScsICdcXFxcdTAwMDInLCAnXFxcXHUwMDAzJywgJ1xcXFx1MDAwNCcsICdcXFxcdTAwMDUnLCAnXFxcXHUwMDA2JywgJ1xcXFx1MDAwNycsICdcXFxcYicsICdcXFxcdCcsICdcXFxcbicsICdcXFxcdTAwMGInLCAnXFxcXGYnLCAnXFxcXHInLCAnXFxcXHUwMDBlJywgJ1xcXFx1MDAwZicsICdcXFxcdTAwMTAnLCAnXFxcXHUwMDExJywgJ1xcXFx1MDAxMicsICdcXFxcdTAwMTMnLCAnXFxcXHUwMDE0JywgJ1xcXFx1MDAxNScsICdcXFxcdTAwMTYnLCAnXFxcXHUwMDE3JywgJ1xcXFx1MDAxOCcsICdcXFxcdTAwMTknLCAnXFxcXHUwMDFhJywgJ1xcXFx1MDAxYicsICdcXFxcdTAwMWMnLCAnXFxcXHUwMDFkJywgJ1xcXFx1MDAxZScsICdcXFxcdTAwMWYnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgXCJcXFxcJ1wiLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJ1xcXFxcXFxcJ107XG4vKiBlc2xpbnQtZW5hYmxlIHF1b3RlcyAqL1xuXG5mdW5jdGlvbiBnZXRVc2VyT3B0aW9ucyhjdHgpIHtcbiAgY29uc3Qgb2JqID0ge1xuICAgIHN0eWxpemU6IGN0eC5zdHlsaXplXG4gIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluc3BlY3REZWZhdWx0T3B0aW9ucykpIHtcbiAgICBvYmpba2V5XSA9IGN0eFtrZXldO1xuICB9XG4gIGlmIChjdHgudXNlck9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5vYmosXG4gICAgLi4uY3R4LnVzZXJPcHRpb25zXG4gIH07XG59XG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGFueSBpbnB1dC4gVHJpZXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGB2YWx1ZWBcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgb3B0cykge1xuICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgY29uc3QgY3R4ID0ge1xuICAgIGJ1ZGdldDoge30sXG4gICAgaW5kZW50YXRpb25Mdmw6IDAsXG4gICAgc2VlbjogW10sXG4gICAgY3VycmVudERlcHRoOiAwLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yLFxuICAgIHNob3dIaWRkZW46IGluc3BlY3REZWZhdWx0T3B0aW9ucy5zaG93SGlkZGVuLFxuICAgIGRlcHRoOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuZGVwdGgsXG4gICAgY29sb3JzOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuY29sb3JzLFxuICAgIGN1c3RvbUluc3BlY3Q6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5jdXN0b21JbnNwZWN0LFxuICAgIHNob3dQcm94eTogaW5zcGVjdERlZmF1bHRPcHRpb25zLnNob3dQcm94eSxcbiAgICBtYXhBcnJheUxlbmd0aDogaW5zcGVjdERlZmF1bHRPcHRpb25zLm1heEFycmF5TGVuZ3RoLFxuICAgIGJyZWFrTGVuZ3RoOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuYnJlYWtMZW5ndGgsXG4gICAgY29tcGFjdDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmNvbXBhY3QsXG4gICAgc29ydGVkOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuc29ydGVkLFxuICAgIGdldHRlcnM6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5nZXR0ZXJzXG4gIH07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIC8vIExlZ2FjeS4uLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgdXNlci1zcGVjaWZpZWQgb3B0aW9uc1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gICAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgICBjb25zdCBvcHRLZXlzID0gT2JqZWN0LmtleXMob3B0cyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBvcHRLZXlzKSB7XG4gICAgICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBGaW5kIGEgc29sdXRpb24gd2hhdCB0byBkbyBhYm91dCBzdHlsaXplLiBFaXRoZXIgbWFrZVxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHB1YmxpYyBvciBhZGQgYSBuZXcgQVBJIHdpdGggYSBzaW1pbGFyIG9yIGJldHRlclxuICAgICAgICAvLyBmdW5jdGlvbmFsaXR5LlxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkoaW5zcGVjdERlZmF1bHRPcHRpb25zLCBrZXkpIHx8IGtleSA9PT0gJ3N0eWxpemUnKSB7XG4gICAgICAgICAgY3R4W2tleV0gPSBvcHRzW2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAoY3R4LnVzZXJPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIHBhc3MgdGhyb3VnaCB0aGUgYWN0dWFsIHVzZXIgaW5wdXQuXG4gICAgICAgICAgY3R4LnVzZXJPcHRpb25zID0gb3B0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY3R4LmNvbG9ycykge1xuICAgIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgfVxuICBpZiAoY3R4Lm1heEFycmF5TGVuZ3RoID09PSBudWxsKSB7XG4gICAgY3R4Lm1heEFycmF5TGVuZ3RoID0gSW5maW5pdHk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIDApO1xufVxuaW5zcGVjdC5jdXN0b20gPSBjdXN0b21JbnNwZWN0U3ltYm9sO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3BlY3QsICdkZWZhdWx0T3B0aW9ucycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBpbnNwZWN0RGVmYXVsdE9wdGlvbnM7XG4gIH0sXG4gIHNldChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oaW5zcGVjdERlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxufSk7XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgYm9sZDogWzEsIDIyXSxcbiAgaXRhbGljOiBbMywgMjNdLFxuICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gIGludmVyc2U6IFs3LCAyN10sXG4gIHdoaXRlOiBbMzcsIDM5XSxcbiAgZ3JleTogWzkwLCAzOV0sXG4gIGJsYWNrOiBbMzAsIDM5XSxcbiAgYmx1ZTogWzM0LCAzOV0sXG4gIGN5YW46IFszNiwgMzldLFxuICBncmVlbjogWzMyLCAzOV0sXG4gIG1hZ2VudGE6IFszNSwgMzldLFxuICByZWQ6IFszMSwgMzldLFxuICB5ZWxsb3c6IFszMywgMzldXG59KTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBzcGVjaWFsOiAnY3lhbicsXG4gIG51bWJlcjogJ3llbGxvdycsXG4gIGJpZ2ludDogJ3llbGxvdycsXG4gIGJvb2xlYW46ICd5ZWxsb3cnLFxuICB1bmRlZmluZWQ6ICdncmV5JyxcbiAgbnVsbDogJ2JvbGQnLFxuICBzdHJpbmc6ICdncmVlbicsXG4gIHN5bWJvbDogJ2dyZWVuJyxcbiAgZGF0ZTogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICByZWdleHA6ICdyZWQnLFxuICBtb2R1bGU6ICd1bmRlcmxpbmUnXG59KTtcbmZ1bmN0aW9uIGFkZFF1b3RlcyhzdHIsIHF1b3Rlcykge1xuICBpZiAocXVvdGVzID09PSAtMSkge1xuICAgIHJldHVybiBgXCIke3N0cn1cImA7XG4gIH1cbiAgaWYgKHF1b3RlcyA9PT0gLTIpIHtcbiAgICByZXR1cm4gYFxcYCR7c3RyfVxcYGA7XG4gIH1cbiAgcmV0dXJuIGAnJHtzdHJ9J2A7XG59XG5jb25zdCBlc2NhcGVGbiA9IHN0ciA9PiBtZXRhW3N0ci5jaGFyQ29kZUF0KDApXTtcblxuLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycywgc2luZ2xlIHF1b3RlcyBhbmQgdGhlIGJhY2tzbGFzaC5cbi8vIFRoaXMgaXMgc2ltaWxhciB0byBKU09OIHN0cmluZ2lmeSBlc2NhcGluZy5cbmZ1bmN0aW9uIHN0ckVzY2FwZShzdHIpIHtcbiAgbGV0IGVzY2FwZVRlc3QgPSBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHA7XG4gIGxldCBlc2NhcGVSZXBsYWNlID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXI7XG4gIGxldCBzaW5nbGVRdW90ZSA9IDM5O1xuXG4gIC8vIENoZWNrIGZvciBkb3VibGUgcXVvdGVzLiBJZiBub3QgcHJlc2VudCwgZG8gbm90IGVzY2FwZSBzaW5nbGUgcXVvdGVzIGFuZFxuICAvLyBpbnN0ZWFkIHdyYXAgdGhlIHRleHQgaW4gZG91YmxlIHF1b3Rlcy4gSWYgZG91YmxlIHF1b3RlcyBleGlzdCwgY2hlY2sgZm9yXG4gIC8vIGJhY2t0aWNrcy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIHVzZSB0aG9zZSBhcyBmYWxsYmFjayBpbnN0ZWFkIG9mIHRoZVxuICAvLyBkb3VibGUgcXVvdGVzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcXVvdGVzXG4gIGlmIChzdHIuaW5jbHVkZXMoXCInXCIpKSB7XG4gICAgLy8gVGhpcyBpbnZhbGlkYXRlcyB0aGUgY2hhckNvZGUgYW5kIHRoZXJlZm9yZSBjYW4gbm90IGJlIG1hdGNoZWQgZm9yXG4gICAgLy8gYW55bW9yZS5cbiAgICBpZiAoIXN0ci5pbmNsdWRlcygnXCInKSkge1xuICAgICAgc2luZ2xlUXVvdGUgPSAtMTtcbiAgICB9IGVsc2UgaWYgKCFzdHIuaW5jbHVkZXMoJ2AnKSAmJiAhc3RyLmluY2x1ZGVzKCckeycpKSB7XG4gICAgICBzaW5nbGVRdW90ZSA9IC0yO1xuICAgIH1cbiAgICBpZiAoc2luZ2xlUXVvdGUgIT09IDM5KSB7XG4gICAgICBlc2NhcGVUZXN0ID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlO1xuICAgICAgZXNjYXBlUmVwbGFjZSA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyU2luZ2xlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWUgbWFnaWMgbnVtYmVycyB0aGF0IHdvcmtlZCBvdXQgZmluZSB3aGlsZSBiZW5jaG1hcmtpbmcgd2l0aCB2OCA2LjBcbiAgaWYgKHN0ci5sZW5ndGggPCA1MDAwICYmICFlc2NhcGVUZXN0LnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBhZGRRdW90ZXMoc3RyLCBzaW5nbGVRdW90ZSk7XG4gIH1cbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShlc2NhcGVSZXBsYWNlLCBlc2NhcGVGbik7XG4gICAgcmV0dXJuIGFkZFF1b3RlcyhzdHIsIHNpbmdsZVF1b3RlKTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGxldCBsYXN0ID0gMDtcbiAgY29uc3QgbGFzdEluZGV4ID0gc3RyLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgIGNvbnN0IHBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKHBvaW50ID09PSBzaW5nbGVRdW90ZSB8fCBwb2ludCA9PT0gOTIgfHwgcG9pbnQgPCAzMikge1xuICAgICAgaWYgKGxhc3QgPT09IGkpIHtcbiAgICAgICAgcmVzdWx0ICs9IG1ldGFbcG9pbnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ICs9IGAke3N0ci5zbGljZShsYXN0LCBpKX0ke21ldGFbcG9pbnRdfWA7XG4gICAgICB9XG4gICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICB9XG4gIGlmIChsYXN0ICE9PSBsYXN0SW5kZXgpIHtcbiAgICByZXN1bHQgKz0gc3RyLnNsaWNlKGxhc3QpO1xuICB9XG4gIHJldHVybiBhZGRRdW90ZXMocmVzdWx0LCBzaW5nbGVRdW90ZSk7XG59XG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIGNvbnN0IHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcbiAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb2xvciA9IGluc3BlY3QuY29sb3JzW3N0eWxlXTtcbiAgICByZXR1cm4gYFxcdTAwMWJbJHtjb2xvclswXX1tJHtzdHJ9XFx1MDAxYlske2NvbG9yWzFdfW1gO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLy8gUmV0dXJuIGEgbmV3IGVtcHR5IGFycmF5IHRvIHB1c2ggaW4gdGhlIHJlc3VsdHMgb2YgdGhlIGRlZmF1bHQgZm9ybWF0dGVyLlxuZnVuY3Rpb24gZ2V0RW1wdHlGb3JtYXRBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKG9iaiwgX2N0eCkge1xuICBsZXQgZmlyc3RQcm90bztcbiAgLy8gY29uc3QgdG1wID0gb2JqO1xuICB3aGlsZSAob2JqKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCAnY29uc3RydWN0b3InKTtcbiAgICBpZiAoZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nICYmIGRlc2NyaXB0b3IudmFsdWUubmFtZSAhPT0gJycpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlLm5hbWU7XG4gICAgfVxuICAgIG9iaiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIGlmIChmaXJzdFByb3RvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpcnN0UHJvdG8gPSBvYmo7XG4gICAgfVxuICB9XG4gIGlmIChmaXJzdFByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKlxuICAgQHRvZG8gdGhpcyBjYWxscyBpbnRvIG5hdGl2ZSwgY2FuIHdlIHJlcGxhY2UgdGhpcyBzb21laG93P1xuICByZXR1cm4gYCR7aW50ZXJuYWxHZXRDb25zdHJ1Y3Rvck5hbWUodG1wKX0gPCR7aW5zcGVjdChmaXJzdFByb3RvLCB7XG4gIFx0Li4uY3R4LFxuICBcdGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gIH0pfT5gO1xuICAqL1xuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZhbGxiYWNrKSB7XG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgIGlmICh0YWcgIT09ICcnKSB7XG4gICAgICByZXR1cm4gYFske2ZhbGxiYWNrfTogbnVsbCBwcm90b3R5cGVdIFske3RhZ31dIGA7XG4gICAgfVxuICAgIHJldHVybiBgWyR7ZmFsbGJhY2t9OiBudWxsIHByb3RvdHlwZV0gYDtcbiAgfVxuICBpZiAodGFnICE9PSAnJyAmJiBjb25zdHJ1Y3RvciAhPT0gdGFnKSB7XG4gICAgcmV0dXJuIGAke2NvbnN0cnVjdG9yfSBbJHt0YWd9XSBgO1xuICB9XG4gIHJldHVybiBgJHtjb25zdHJ1Y3Rvcn0gYDtcbn1cblxuLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuZnVuY3Rpb24gZ2V0S2V5cyh2YWx1ZSwgc2hvd0hpZGRlbikge1xuICBsZXQga2V5cztcbiAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xuICBpZiAoc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gICAgaWYgKHN5bWJvbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBrZXlzLnB1c2goLi4uc3ltYm9scyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbWlnaHQgdGhyb3cgaWYgYHZhbHVlYCBpcyBhIE1vZHVsZSBOYW1lc3BhY2UgT2JqZWN0IGZyb20gYW5cbiAgICAvLyB1bmV2YWx1YXRlZCBtb2R1bGUsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIHBlcmZvcm0gdGhlIGFjdHVhbCB0eXBlXG4gICAgLy8gY2hlY2sgYmVjYXVzZSBpdCdzIGV4cGVuc2l2ZS5cbiAgICAvLyBUT0RPKGRldnNuZWspOiB0cmFjayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL2lzc3Vlcy8xMjA5XG4gICAgLy8gYW5kIG1vZGlmeSB0aGlzIGxvZ2ljIGFzIG5lZWRlZC5cbiAgICB0cnkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEBmaXhtZSBob3cgdG8gZHUgaXNNb2R1bGVOYW1lc3BhY2VPYmplY3Q/XG4gICAgICAvKlxuICAgICAgYXNzZXJ0KGlzTmF0aXZlRXJyb3IoZXJyKSAmJiBlcnIubmFtZSA9PT0gJ1JlZmVyZW5jZUVycm9yJyAmJlxuICAgICAgXHRcdFx0IGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbHVlKSk7XG4gICAgICAqL1xuICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBrZXlzLnB1c2goLi4uc3ltYm9scy5maWx0ZXIoa2V5ID0+IHByb3BlcnR5SXNFbnVtZXJhYmxlKHZhbHVlLCBrZXkpKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gZ2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpIHtcbiAgbGV0IGZhbGxiYWNrID0gJyc7XG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgIGZhbGxiYWNrID0gJ09iamVjdCc7XG4gIH1cbiAgcmV0dXJuIGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjayk7XG59XG5mdW5jdGlvbiBmaW5kVHlwZWRDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICBmb3IgKGNvbnN0IFtjaGVjaywgY2xhenpdIG9mIFtbaXNVaW50OEFycmF5LCBVaW50OEFycmF5XSwgW2lzVWludDhDbGFtcGVkQXJyYXksIFVpbnQ4Q2xhbXBlZEFycmF5XSwgW2lzVWludDE2QXJyYXksIFVpbnQxNkFycmF5XSwgW2lzVWludDMyQXJyYXksIFVpbnQzMkFycmF5XSwgW2lzSW50OEFycmF5LCBJbnQ4QXJyYXldLCBbaXNJbnQxNkFycmF5LCBJbnQxNkFycmF5XSwgW2lzSW50MzJBcnJheSwgSW50MzJBcnJheV0sIFtpc0Zsb2F0MzJBcnJheSwgRmxvYXQzMkFycmF5XSwgW2lzRmxvYXQ2NEFycmF5LCBGbG9hdDY0QXJyYXldXSkge1xuICAgIGlmIChjaGVjayh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbGF6ejtcbiAgICB9XG4gIH1cbn1cbmxldCBsYXp5TnVsbFByb3RvdHlwZUNhY2hlO1xuLy8gQ3JlYXRlcyBhIHN1YmNsYXNzIGFuZCBuYW1lXG4vLyB0aGUgY29uc3RydWN0b3IgYXMgYCR7Y2xhenp9IDogbnVsbCBwcm90b3R5cGVgXG5mdW5jdGlvbiBjbGF6eldpdGhOdWxsUHJvdG90eXBlKGNsYXp6LCBuYW1lKSB7XG4gIGlmIChsYXp5TnVsbFByb3RvdHlwZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICBsYXp5TnVsbFByb3RvdHlwZUNhY2hlID0gbmV3IE1hcCgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhY2hlZENsYXNzID0gbGF6eU51bGxQcm90b3R5cGVDYWNoZS5nZXQoY2xhenopO1xuICAgIGlmIChjYWNoZWRDbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ2xhc3M7XG4gICAgfVxuICB9XG4gIGNsYXNzIE51bGxQcm90b3R5cGUgZXh0ZW5kcyBjbGF6eiB7XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTnVsbFByb3RvdHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3IsICduYW1lJywge1xuICAgIHZhbHVlOiBgWyR7bmFtZX06IG51bGwgcHJvdG90eXBlXWBcbiAgfSk7XG4gIGxhenlOdWxsUHJvdG90eXBlQ2FjaGUuc2V0KGNsYXp6LCBOdWxsUHJvdG90eXBlKTtcbiAgcmV0dXJuIE51bGxQcm90b3R5cGU7XG59XG5mdW5jdGlvbiBub1Byb3RvdHlwZUl0ZXJhdG9yKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBsZXQgbmV3VmFsO1xuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgY29uc3QgY2xhenogPSBjbGF6eldpdGhOdWxsUHJvdG90eXBlKFNldCwgJ1NldCcpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eihTZXRQcm90b3R5cGUudmFsdWVzKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgY29uc3QgY2xhenogPSBjbGF6eldpdGhOdWxsUHJvdG90eXBlKE1hcCwgJ01hcCcpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eihNYXBQcm90b3R5cGUuZW50cmllcyh2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgY2xhenogPSBjbGF6eldpdGhOdWxsUHJvdG90eXBlKEFycmF5LCAnQXJyYXknKTtcbiAgICBuZXdWYWwgPSBuZXcgY2xhenoodmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBmaW5kVHlwZWRDb25zdHJ1Y3Rvcih2YWx1ZSk7XG4gICAgY29uc3QgY2xhenogPSBjbGF6eldpdGhOdWxsUHJvdG90eXBlKGNvbnN0cnVjdG9yLCBjb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICBuZXdWYWwgPSBuZXcgY2xhenoodmFsdWUpO1xuICB9XG4gIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5ld1ZhbCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModmFsdWUpKTtcbiAgICByZXR1cm4gZm9ybWF0UmF3KGN0eCwgbmV3VmFsLCByZWN1cnNlVGltZXMpO1xuICB9XG59XG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpIHtcbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXMuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmb3JtYXRQcmltaXRpdmUoY3R4LnN0eWxpemUsIHZhbHVlLCBjdHgpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gIH1cbiAgLy8gTWVtb3JpemUgdGhlIGNvbnRleHQgZm9yIGN1c3RvbSBpbnNwZWN0aW9uIG9uIHByb3hpZXMuXG4gIGNvbnN0IGNvbnRleHQgPSB2YWx1ZTtcbiAgLypcbiAgQGZpeG1lIGNoZWNrIGZvciBwcm94aWVzXG4gIC8vIEFsd2F5cyBjaGVjayBmb3IgcHJveGllcyB0byBwcmV2ZW50IHNpZGUgZWZmZWN0cyBhbmQgdG8gcHJldmVudCB0cmlnZ2VyaW5nXG4gIC8vIGFueSBwcm94eSBoYW5kbGVycy5cbiAgY29uc3QgcHJveHkgPSBnZXRQcm94eURldGFpbHModmFsdWUpO1xuICBpZiAocHJveHkgIT09IHVuZGVmaW5lZCkge1xuICBcdGlmIChjdHguc2hvd1Byb3h5KSB7XG4gIFx0XHRyZXR1cm4gZm9ybWF0UHJveHkoY3R4LCBwcm94eSwgcmVjdXJzZVRpbWVzKTtcbiAgXHR9XG4gIFx0dmFsdWUgPSBwcm94eVswXTtcbiAgfVxuICAqL1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdC5cbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0KSB7XG4gICAgY29uc3QgbWF5YmVDdXN0b20gPSB2YWx1ZVtjdXN0b21JbnNwZWN0U3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ3VzdG9tID09PSAnZnVuY3Rpb24nXG4gICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0cyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWwuXG4gICAgJiYgbWF5YmVDdXN0b20gIT09IGluc3BlY3RcbiAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAmJiAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhlIHJlY3Vyc2VUaW1lcyBhcmUgcmVwb3J0ZWQgYXMgYmVmb3JlIHdoaWxlIHVzaW5nXG4gICAgICAvLyBhIGNvdW50ZXIgaW50ZXJuYWxseS5cbiAgICAgIGNvbnN0IGRlcHRoID0gY3R4LmRlcHRoID09PSBudWxsID8gbnVsbCA6IGN0eC5kZXB0aCAtIHJlY3Vyc2VUaW1lcztcbiAgICAgIGNvbnN0IHJldCA9IG1heWJlQ3VzdG9tLmNhbGwoY29udGV4dCwgZGVwdGgsIGdldFVzZXJPcHRpb25zKGN0eCkpO1xuICAgICAgLy8gSWYgdGhlIGN1c3RvbSBpbnNwZWN0aW9uIG1ldGhvZCByZXR1cm5lZCBgdGhpc2AsIGRvbid0IGdvIGludG9cbiAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgIGlmIChyZXQgIT09IGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZSgvXFxuL2csIGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gVXNpbmcgYW4gYXJyYXkgaGVyZSBpcyBhY3R1YWxseSBiZXR0ZXIgZm9yIHRoZSBhdmVyYWdlIGNhc2UgdGhhbiB1c2luZ1xuICAvLyBhIFNldC4gYHNlZW5gIHdpbGwgb25seSBjaGVjayBmb3IgdGhlIGRlcHRoIGFuZCB3aWxsIG5ldmVyIGdyb3cgdG9vIGxhcmdlLlxuICBpZiAoY3R4LnNlZW4uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgbGV0IGluZGV4ID0gMTtcbiAgICBpZiAoY3R4LmNpcmN1bGFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5jaXJjdWxhciA9IG5ldyBNYXAoW1t2YWx1ZSwgaW5kZXhdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gY3R4LmNpcmN1bGFyLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IGN0eC5jaXJjdWxhci5zaXplICsgMTtcbiAgICAgICAgY3R4LmNpcmN1bGFyLnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3R4LnN0eWxpemUoYFtDaXJjdWxhciAqJHtpbmRleH1dYCwgJ3NwZWNpYWwnKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0UmF3KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSk7XG59XG5mdW5jdGlvbiBmb3JtYXRSYXcoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB0eXBlZEFycmF5KSB7XG4gIGxldCBrZXlzO1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSk7XG4gIGxldCB0YWcgPSB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAvLyBPbmx5IGxpc3QgdGhlIHRhZyBpbiBjYXNlIGl0J3Mgbm9uLWVudW1lcmFibGUgLyBub3QgYW4gb3duIHByb3BlcnR5LlxuICAvLyBPdGhlcndpc2Ugd2UnZCBwcmludCB0aGlzIHR3aWNlLlxuICBpZiAodHlwZW9mIHRhZyAhPT0gJ3N0cmluZycgfHwgdGFnICE9PSAnJyAmJiAoY3R4LnNob3dIaWRkZW4gPyBoYXNPd25Qcm9wZXJ0eSA6IHByb3BlcnR5SXNFbnVtZXJhYmxlKSh2YWx1ZSwgU3ltYm9sLnRvU3RyaW5nVGFnKSkge1xuICAgIHRhZyA9ICcnO1xuICB9XG4gIGxldCBiYXNlID0gJyc7XG4gIGxldCBmb3JtYXR0ZXIgPSBnZXRFbXB0eUZvcm1hdEFycmF5O1xuICBsZXQgYnJhY2VzO1xuICBsZXQgbm9JdGVyYXRvciA9IHRydWU7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgZmlsdGVyID0gY3R4LnNob3dIaWRkZW4gPyBBTExfUFJPUEVSVElFUyA6IE9OTFlfRU5VTUVSQUJMRTtcbiAgbGV0IGV4dHJhc1R5cGUgPSBrT2JqZWN0VHlwZTtcblxuICAvLyBJdGVyYXRvcnMgYW5kIHRoZSByZXN0IGFyZSBzcGxpdCB0byByZWR1Y2UgY2hlY2tzLlxuICBpZiAodmFsdWVbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgIG5vSXRlcmF0b3IgPSBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUsIGZpbHRlcik7XG4gICAgICAvLyBPbmx5IHNldCB0aGUgY29uc3RydWN0b3IgZm9yIG5vbiBvcmRpbmFyeSAoXCJBcnJheSBbLi4uXVwiKSBhcnJheXMuXG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ0FycmF5Jyk7XG4gICAgICBicmFjZXMgPSBbYCR7cHJlZml4ID09PSAnQXJyYXkgJyA/ICcnIDogcHJlZml4fVtgLCAnXSddO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7YnJhY2VzWzBdfV1gO1xuICAgICAgfVxuICAgICAgZXh0cmFzVHlwZSA9IGtBcnJheUV4dHJhc1R5cGU7XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRBcnJheTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnU2V0Jyk7XG4gICAgICBpZiAodmFsdWUuc2l6ZSA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fXt9YDtcbiAgICAgIH1cbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXh9e2AsICd9J107XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRTZXQ7XG4gICAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ01hcCcpO1xuICAgICAgaWYgKHZhbHVlLnNpemUgPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH17fWA7XG4gICAgICB9XG4gICAgICBicmFjZXMgPSBbYCR7cHJlZml4fXtgLCAnfSddO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0TWFwO1xuICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGNvbnN0cnVjdG9yICE9PSBudWxsID8gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcpIDogZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKS5uYW1lKTtcbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXh9W2AsICddJ107XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwICYmICFjdHguc2hvd0hpZGRlbikge1xuICAgICAgICByZXR1cm4gYCR7YnJhY2VzWzBdfV1gO1xuICAgICAgfVxuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0VHlwZWRBcnJheTtcbiAgICAgIGV4dHJhc1R5cGUgPSBrQXJyYXlFeHRyYXNUeXBlO1xuICAgIH0gZWxzZSBpZiAoaXNNYXBJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnTWFwJywgdGFnKTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yO1xuICAgIH0gZWxzZSBpZiAoaXNTZXRJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnU2V0JywgdGFnKTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBub0l0ZXJhdG9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vSXRlcmF0b3IpIHtcbiAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgIGJyYWNlcyA9IFsneycsICd9J107XG4gICAgaWYgKGNvbnN0cnVjdG9yID09PSAnT2JqZWN0Jykge1xuICAgICAgaWYgKGlzQXJndW1lbnRzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBicmFjZXNbMF0gPSAnW0FyZ3VtZW50c10geyc7XG4gICAgICB9IGVsc2UgaWYgKHRhZyAhPT0gJycpIHtcbiAgICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdPYmplY3QnKX17YDtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7YnJhY2VzWzBdfX1gO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBiYXNlID0gZ2V0RnVuY3Rpb25CYXNlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoYmFzZSwgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtbm9uLWxpdGVyYWwtcmVnZXhwXG4gICAgICBjb25zdCByZWdFeHAgPSBjb25zdHJ1Y3RvciAhPT0gbnVsbCA/IHZhbHVlIDogbmV3IFJlZ0V4cCh2YWx1ZSk7XG4gICAgICBiYXNlID0gUmVnRXhwUHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmVnRXhwKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnUmVnRXhwJyk7XG4gICAgICBpZiAocHJlZml4ICE9PSAnUmVnRXhwICcpIHtcbiAgICAgICAgYmFzZSA9IGAke3ByZWZpeH0ke2Jhc2V9YDtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCB8fCByZWN1cnNlVGltZXMgPiBjdHguZGVwdGggJiYgY3R4LmRlcHRoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCAncmVnZXhwJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICAgIGJhc2UgPSBOdW1iZXIuaXNOYU4oRGF0ZVByb3RvdHlwZS5nZXRUaW1lLmNhbGwodmFsdWUpKSA/IERhdGVQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiBEYXRlUHJvdG90eXBlLnRvSVNPU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdEYXRlJyk7XG4gICAgICBpZiAocHJlZml4ICE9PSAnRGF0ZSAnKSB7XG4gICAgICAgIGJhc2UgPSBgJHtwcmVmaXh9JHtiYXNlfWA7XG4gICAgICB9XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdkYXRlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgYmFzZSA9IGZvcm1hdEVycm9yKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnLCBjdHgpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfSBlbHNlIGlmIChpc0lvcykge1xuICAgICAgICBjb25zdCBuYXRpdmVFcnJvclByb3BzID0gWydsaW5lJywgJ2NvbHVtbicsICdzb3VyY2VVUkwnXTtcbiAgICAgICAgaWYgKGtleXMuZXZlcnkoa2V5ID0+IG5hdGl2ZUVycm9yUHJvcHMuaW5jbHVkZXMoa2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3IgQXJyYXlCdWZmZXIgYW5kIFNoYXJlZEFycmF5QnVmZmVyLlxuICAgICAgLy8gQ2FuJ3QgZG8gdGhlIHNhbWUgZm9yIERhdGFWaWV3IGJlY2F1c2UgaXQgaGFzIGEgbm9uLXByaW1pdGl2ZVxuICAgICAgLy8gLmJ1ZmZlciBwcm9wZXJ0eSB0aGF0IHdlIG5lZWQgdG8gcmVjdXJzZSBmb3IuXG4gICAgICBjb25zdCBhcnJheVR5cGUgPSBpc0FycmF5QnVmZmVyKHZhbHVlKSA/ICdBcnJheUJ1ZmZlcicgOiAnU2hhcmVkQXJyYXlCdWZmZXInO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGFycmF5VHlwZSk7XG4gICAgICBpZiAodHlwZWRBcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEFycmF5QnVmZmVyO1xuICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fXsgYnl0ZUxlbmd0aDogJHtmb3JtYXROdW1iZXIoY3R4LnN0eWxpemUsIHZhbHVlLmJ5dGVMZW5ndGgpfSB9YDtcbiAgICAgIH1cbiAgICAgIGJyYWNlc1swXSA9IGAke3ByZWZpeH17YDtcbiAgICAgIGtleXMudW5zaGlmdCgnYnl0ZUxlbmd0aCcpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRhVmlldyh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnRGF0YVZpZXcnKX17YDtcbiAgICAgIC8vIC5idWZmZXIgZ29lcyBsYXN0LCBpdCdzIG5vdCBhIHByaW1pdGl2ZSBsaWtlIHRoZSBvdGhlcnMuXG4gICAgICBrZXlzLnVuc2hpZnQoJ2J5dGVMZW5ndGgnLCAnYnl0ZU9mZnNldCcsICdidWZmZXInKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnUHJvbWlzZScpfXtgO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKGlzV2Vha1NldCh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnV2Vha1NldCcpfXtgO1xuICAgICAgZm9ybWF0dGVyID0gY3R4LnNob3dIaWRkZW4gPyBmb3JtYXRXZWFrU2V0IDogZm9ybWF0V2Vha0NvbGxlY3Rpb247XG4gICAgfSBlbHNlIGlmIChpc1dlYWtNYXAodmFsdWUpKSB7XG4gICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1dlYWtNYXAnKX17YDtcbiAgICAgIGZvcm1hdHRlciA9IGN0eC5zaG93SGlkZGVuID8gZm9ybWF0V2Vha01hcCA6IGZvcm1hdFdlYWtDb2xsZWN0aW9uO1xuICAgICAgLypcbiAgICAgICAqIEBmaXhtZSBob3cgdG8gZG8gaXNNb2R1bGVOYW1lc3BhY2VPYmplY3Q/XG4gICAgICB9IGVsc2UgaWYgKGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXHRicmFjZXNbMF0gPSBgWyR7dGFnfV0ge2A7XG4gICAgICBcdGZvcm1hdHRlciA9IGZvcm1hdE5hbWVzcGFjZU9iamVjdDtcbiAgICAgICovXG4gICAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9IGdldEJveGVkQmFzZSh2YWx1ZSwgY3R4LCBrZXlzLCBjb25zdHJ1Y3RvciwgdGFnKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGlucHV0IHByb3RvdHlwZSBnb3QgbWFuaXB1bGF0ZWQuIFNwZWNpYWwgaGFuZGxlIHRoZXNlLiBXZSBoYXZlIHRvXG4gICAgICAvLyByZWJ1aWxkIHRoZSBpbmZvcm1hdGlvbiBzbyB3ZSBhcmUgYWJsZSB0byBkaXNwbGF5IGV2ZXJ5dGhpbmcuXG4gICAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lhbEl0ZXJhdG9yID0gbm9Qcm90b3R5cGVJdGVyYXRvcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpO1xuICAgICAgICBpZiAoc3BlY2lhbEl0ZXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHNwZWNpYWxJdGVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWFwSXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdNYXAnLCB0YWcpO1xuICAgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjtcbiAgICAgIH0gZWxzZSBpZiAoaXNTZXRJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ1NldCcsIHRhZyk7XG4gICAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yO1xuICAgICAgICAvLyBIYW5kbGUgb3RoZXIgcmVndWxhciBvYmplY3RzIGFnYWluLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2dldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKX17fWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpfXtgO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVjdXJzZVRpbWVzID4gY3R4LmRlcHRoICYmIGN0eC5kZXB0aCAhPT0gbnVsbCkge1xuICAgIGxldCBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykuc2xpY2UoMCwgLTEpO1xuICAgIGlmIChjb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuICAgICAgY29uc3RydWN0b3JOYW1lID0gYFske2NvbnN0cnVjdG9yTmFtZX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKGNvbnN0cnVjdG9yTmFtZSwgJ3NwZWNpYWwnKTtcbiAgfVxuICByZWN1cnNlVGltZXMgKz0gMTtcbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG4gIGN0eC5jdXJyZW50RGVwdGggPSByZWN1cnNlVGltZXM7XG4gIGxldCBvdXRwdXQ7XG4gIGNvbnN0IGluZGVudGF0aW9uTHZsID0gY3R4LmluZGVudGF0aW9uTHZsO1xuICB0cnkge1xuICAgIG91dHB1dCA9IGZvcm1hdHRlcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleXMsIGJyYWNlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5c1tpXSwgZXh0cmFzVHlwZSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gZ2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpLnNsaWNlKDAsIC0xKTtcbiAgICByZXR1cm4gaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZShjdHgsIGVyciwgY29uc3RydWN0b3JOYW1lLCBpbmRlbnRhdGlvbkx2bCk7XG4gIH1cbiAgaWYgKGN0eC5jaXJjdWxhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgaW5kZXggPSBjdHguY2lyY3VsYXIuZ2V0KHZhbHVlKTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcmVmZXJlbmNlID0gY3R4LnN0eWxpemUoYDxyZWYgKiR7aW5kZXh9PmAsICdzcGVjaWFsJyk7XG4gICAgICAvLyBBZGQgcmVmZXJlbmNlIGFsd2F5cyB0byB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSkge1xuICAgICAgICBiYXNlID0gYmFzZSA9PT0gJycgPyByZWZlcmVuY2UgOiBgJHtyZWZlcmVuY2V9ICR7YmFzZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJhY2VzWzBdID0gYCR7cmVmZXJlbmNlfSAke2JyYWNlc1swXX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdHguc2Vlbi5wb3AoKTtcbiAgaWYgKGN0eC5zb3J0ZWQpIHtcbiAgICBjb25zdCBjb21wYXJhdG9yID0gY3R4LnNvcnRlZCA9PT0gdHJ1ZSA/IHVuZGVmaW5lZCA6IGN0eC5zb3J0ZWQ7XG4gICAgaWYgKGV4dHJhc1R5cGUgPT09IGtPYmplY3RUeXBlKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQuc29ydChjb21wYXJhdG9yKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3Qgc29ydGVkID0gb3V0cHV0LnNsaWNlKG91dHB1dC5sZW5ndGggLSBrZXlzLmxlbmd0aCkuc29ydChjb21wYXJhdG9yKTtcbiAgICAgIG91dHB1dC5zcGxpY2Uob3V0cHV0Lmxlbmd0aCAtIGtleXMubGVuZ3RoLCBrZXlzLmxlbmd0aCwgLi4uc29ydGVkKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzID0gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSk7XG4gIGNvbnN0IGJ1ZGdldCA9IGN0eC5idWRnZXRbY3R4LmluZGVudGF0aW9uTHZsXSB8fCAwO1xuICBjb25zdCBuZXdMZW5ndGggPSBidWRnZXQgKyByZXMubGVuZ3RoO1xuICBjdHguYnVkZ2V0W2N0eC5pbmRlbnRhdGlvbkx2bF0gPSBuZXdMZW5ndGg7XG4gIC8vIElmIGFueSBpbmRlbnRhdGlvbkx2bCBleGNlZWRzIHRoaXMgbGltaXQsIGxpbWl0IGZ1cnRoZXIgaW5zcGVjdGluZyB0byB0aGVcbiAgLy8gbWluaW11bS4gT3RoZXJ3aXNlIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtIG1pZ2h0IGNvbnRpbnVlIGluc3BlY3RpbmcgdGhlXG4gIC8vIG9iamVjdCBldmVuIHRob3VnaCB0aGUgbWF4aW11bSBzdHJpbmcgc2l6ZSAofjIgKiogMjggb24gMzIgYml0IHN5c3RlbXMgYW5kXG4gIC8vIH4yICoqIDMwIG9uIDY0IGJpdCBzeXN0ZW1zKSBleGNlZWRlZC4gVGhlIGFjdHVhbCBvdXRwdXQgaXMgbm90IGxpbWl0ZWQgYXRcbiAgLy8gZXhhY3RseSAyICoqIDI3IGJ1dCBhIGJpdCBoaWdoZXIuIFRoaXMgZGVwZW5kcyBvbiB0aGUgb2JqZWN0IHNoYXBlLlxuICAvLyBUaGlzIGxpbWl0IGFsc28gbWFrZXMgc3VyZSB0aGF0IGh1Z2Ugb2JqZWN0cyBkb24ndCBibG9jayB0aGUgZXZlbnQgbG9vcFxuICAvLyBzaWduaWZpY2FudGx5LlxuICBpZiAobmV3TGVuZ3RoID4gMiAqKiAyNykge1xuICAgIGN0eC5kZXB0aCA9IC0xO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRJdGVyYXRvckJyYWNlcyh0eXBlLCB0YWcpIHtcbiAgaWYgKHRhZyAhPT0gYCR7dHlwZX0gSXRlcmF0b3JgKSB7XG4gICAgaWYgKHRhZyAhPT0gJycpIHtcbiAgICAgIHRhZyArPSAnXSBbJztcbiAgICB9XG4gICAgdGFnICs9IGAke3R5cGV9IEl0ZXJhdG9yYDtcbiAgfVxuICByZXR1cm4gW2BbJHt0YWd9XSB7YCwgJ30nXTtcbn1cbmZ1bmN0aW9uIGdldEJveGVkQmFzZSh2YWx1ZSwgY3R4LCBrZXlzLCBjb25zdHJ1Y3RvciwgdGFnKSB7XG4gIGxldCBmbjtcbiAgbGV0IHR5cGU7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IE51bWJlclByb3RvdHlwZTtcbiAgICB0eXBlID0gJ051bWJlcic7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmdPYmplY3QodmFsdWUpKSB7XG4gICAgZm4gPSBTdHJpbmdQcm90b3R5cGU7XG4gICAgdHlwZSA9ICdTdHJpbmcnO1xuICAgIC8vIEZvciBib3hlZCBTdHJpbmdzLCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgMC1uIGluZGV4ZWQgZW50cmllcyxcbiAgICAvLyBzaW5jZSB0aGV5IGp1c3Qgbm9pc3kgdXAgdGhlIG91dHB1dCBhbmQgYXJlIHJlZHVuZGFudFxuICAgIC8vIE1ha2UgYm94ZWQgcHJpbWl0aXZlIFN0cmluZ3MgbG9vayBsaWtlIHN1Y2hcbiAgICBrZXlzLnNwbGljZSgwLCB2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IEJvb2xlYW5Qcm90b3R5cGU7XG4gICAgdHlwZSA9ICdCb29sZWFuJztcbiAgfSBlbHNlIHtcbiAgICBmbiA9IFN5bWJvbFByb3RvdHlwZTtcbiAgICB0eXBlID0gJ1N5bWJvbCc7XG4gIH1cbiAgbGV0IGJhc2UgPSBgWyR7dHlwZX1gO1xuICBpZiAodHlwZSAhPT0gY29uc3RydWN0b3IpIHtcbiAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgIGJhc2UgKz0gJyAobnVsbCBwcm90b3R5cGUpJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSArPSBgICgke2NvbnN0cnVjdG9yfSlgO1xuICAgIH1cbiAgfVxuICBiYXNlICs9IGA6ICR7Zm9ybWF0UHJpbWl0aXZlKHN0eWxpemVOb0NvbG9yLCBmbi52YWx1ZU9mKHZhbHVlKSwgY3R4KX1dYDtcbiAgaWYgKHRhZyAhPT0gJycgJiYgdGFnICE9PSBjb25zdHJ1Y3Rvcikge1xuICAgIGJhc2UgKz0gYCBbJHt0YWd9XWA7XG4gIH1cbiAgaWYgKGtleXMubGVuZ3RoICE9PSAwIHx8IGN0eC5zdHlsaXplID09PSBzdHlsaXplTm9Db2xvcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCB0eXBlLnRvTG93ZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25CYXNlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKSB7XG4gIGxldCB0eXBlID0gJ0Z1bmN0aW9uJztcbiAgaWYgKGlzR2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdHlwZSA9IGBHZW5lcmF0b3Ike3R5cGV9YDtcbiAgfVxuICBpZiAoaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHR5cGUgPSBgQXN5bmMke3R5cGV9YDtcbiAgfVxuICBsZXQgYmFzZSA9IGBbJHt0eXBlfWA7XG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgIGJhc2UgKz0gJyAobnVsbCBwcm90b3R5cGUpJztcbiAgfVxuICBpZiAodmFsdWUubmFtZSA9PT0gJycpIHtcbiAgICBiYXNlICs9ICcgKGFub255bW91cyknO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgKz0gYDogJHt2YWx1ZS5uYW1lfWA7XG4gIH1cbiAgYmFzZSArPSAnXSc7XG4gIGlmIChjb25zdHJ1Y3RvciAhPT0gdHlwZSAmJiBjb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuICAgIGJhc2UgKz0gYCAke2NvbnN0cnVjdG9yfWA7XG4gIH1cbiAgaWYgKHRhZyAhPT0gJycgJiYgY29uc3RydWN0b3IgIT09IHRhZykge1xuICAgIGJhc2UgKz0gYCBbJHt0YWd9XWA7XG4gIH1cbiAgcmV0dXJuIGJhc2U7XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnIsIGNvbnN0cnVjdG9yLCB0YWcsIGN0eCkge1xuICBsZXQgc3RhY2sgPSBlcnIuc3RhY2sgfHwgRXJyb3JQcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpO1xuICAvLyB0cnkgdG8gbm9ybWFsaXplIEphdmFTY3JpcHRDb3JlIHN0YWNrIHRvIG1hdGNoIHY4XG4gIGlmIChpc0lvcykge1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIHN0YWNrID0gYCR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfWA7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrICs9IGxpbmVzLm1hcChzdGFja0xpbmUgPT4ge1xuICAgICAgICBjb25zdCBhdFN5bWJvbEluZGV4ID0gc3RhY2tMaW5lLmluZGV4T2YoJ0AnKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gc3RhY2tMaW5lLnNsaWNlKGF0U3ltYm9sSW5kZXggKyAxKTtcbiAgICAgICAgY29uc3Qgc291cmNlUGF0dGVybiA9IC8oLiopOihcXGQrKTooXFxkKykvO1xuICAgICAgICBsZXQgc3ltYm9sTmFtZSA9ICd1bmtub3duJztcbiAgICAgICAgaWYgKGF0U3ltYm9sSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3ltYm9sTmFtZSA9IHN0YWNrTGluZS5zbGljZSgwLCBhdFN5bWJvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VNYXRjaCA9IHNvdXJjZS5tYXRjaChzb3VyY2VQYXR0ZXJuKTtcbiAgICAgICAgaWYgKHNvdXJjZU1hdGNoKSB7XG4gICAgICAgICAgbGV0IGZpbGVQYXRoID0gc291cmNlTWF0Y2hbMV07XG4gICAgICAgICAgY29uc3QgbGluZU51bWJlciA9IHNvdXJjZU1hdGNoWzJdO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHNvdXJjZU1hdGNoWzNdO1xuICAgICAgICAgIGlmIChmaWxlUGF0aC5zdGFydHNXaXRoKCdmaWxlOicpKSB7XG4gICAgICAgICAgICBmaWxlUGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoYGZpbGU6Ly8ke1RpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5fWAsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGBcXG4gICAgYXQgJHtzeW1ib2xOYW1lfSAoJHtmaWxlUGF0aH06JHtsaW5lTnVtYmVyfToke2NvbHVtbn0pYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYFxcbiAgICBhdCAke3N5bWJvbE5hbWV9ICgke3NvdXJjZX0pYDtcbiAgICAgICAgfVxuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQSBzdGFjayB0cmFjZSBtYXkgY29udGFpbiBhcmJpdHJhcnkgZGF0YS4gT25seSBtYW5pcHVsYXRlIHRoZSBvdXRwdXRcbiAgLy8gZm9yIFwicmVndWxhciBlcnJvcnNcIiAoZXJyb3JzIHRoYXQgXCJsb29rIG5vcm1hbFwiKSBmb3Igbm93LlxuICBjb25zdCBuYW1lID0gZXJyLm5hbWUgfHwgJ0Vycm9yJztcbiAgbGV0IGxlbiA9IG5hbWUubGVuZ3RoO1xuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwgfHwgbmFtZS5lbmRzV2l0aCgnRXJyb3InKSAmJiBzdGFjay5zdGFydHNXaXRoKG5hbWUpICYmIChzdGFjay5sZW5ndGggPT09IGxlbiB8fCBzdGFja1tsZW5dID09PSAnOicgfHwgc3RhY2tbbGVuXSA9PT0gJ1xcbicpKSB7XG4gICAgbGV0IGZhbGxiYWNrID0gJ0Vycm9yJztcbiAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhY2subWF0Y2goL14oW0EtWl1bYS16XyBBLVowLTlbXFxdKCktXSspKD86OnxcXG4gezR9YXQpLykgfHwgc3RhY2subWF0Y2goL14oW2Etel9BLVowLTktXSpFcnJvcikkLyk7XG4gICAgICBmYWxsYmFjayA9IHN0YXJ0ICYmIHN0YXJ0WzFdIHx8ICcnO1xuICAgICAgbGVuID0gZmFsbGJhY2subGVuZ3RoO1xuICAgICAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCAnRXJyb3InO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmFsbGJhY2spLnNsaWNlKDAsIC0xKTtcbiAgICBpZiAobmFtZSAhPT0gcHJlZml4KSB7XG4gICAgICBpZiAocHJlZml4LmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICBzdGFjayA9IGAke3ByZWZpeH06ICR7c3RhY2t9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjayA9IGAke3ByZWZpeH0ke3N0YWNrLnNsaWNlKGxlbil9YDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2sgPSBgJHtwcmVmaXh9IFske25hbWV9XSR7c3RhY2suc2xpY2UobGVuKX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElnbm9yZSB0aGUgZXJyb3IgbWVzc2FnZSBpZiBpdCdzIGNvbnRhaW5lZCBpbiB0aGUgc3RhY2suXG4gIGxldCBwb3MgPSBlcnIubWVzc2FnZSAmJiBzdGFjay5pbmRleE9mKGVyci5tZXNzYWdlKSB8fCAtMTtcbiAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICBwb3MgKz0gZXJyLm1lc3NhZ2UubGVuZ3RoO1xuICB9XG4gIC8vIFdyYXAgdGhlIGVycm9yIGluIGJyYWNrZXRzIGluIGNhc2UgaXQgaGFzIG5vIHN0YWNrIHRyYWNlLlxuICBsZXQgc3RhY2tTdGFydCA9IHN0YWNrLmluZGV4T2YoJ1xcbiAgICBhdCcsIHBvcyk7XG4gIGlmIChzdGFja1N0YXJ0ID09PSAtMSkge1xuICAgIHN0YWNrID0gYFske3N0YWNrfV1gO1xuICB9IGVsc2UgaWYgKGN0eC5jb2xvcnMpIHtcbiAgICAvLyBIaWdobGlnaHQgdXNlcmxhbmQgY29kZSBhbmQgbm9kZSBtb2R1bGVzLlxuICAgIGxldCBuZXdTdGFjayA9IHN0YWNrLnNsaWNlKDAsIHN0YWNrU3RhcnQpO1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc2xpY2Uoc3RhY2tTdGFydCArIDEpLnNwbGl0KCdcXG4nKTtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIC8vIFRoaXMgYWRkcyB1bmRlcnNjb3JlcyB0byBhbGwgbm9kZV9tb2R1bGVzIHRvIHF1aWNrbHkgaWRlbnRpZnkgdGhlbS5cbiAgICAgIGxldCBub2RlTW9kdWxlO1xuICAgICAgbmV3U3RhY2sgKz0gJ1xcbic7XG4gICAgICBsZXQgcG9zID0gMDtcbiAgICAgIHdoaWxlIChub2RlTW9kdWxlID0gbm9kZU1vZHVsZXNSZWdFeHAuZXhlYyhsaW5lKSkge1xuICAgICAgICAvLyAnL25vZGVfbW9kdWxlcy8nLmxlbmd0aCA9PT0gMTRcbiAgICAgICAgbmV3U3RhY2sgKz0gbGluZS5zbGljZShwb3MsIG5vZGVNb2R1bGUuaW5kZXggKyAxNCk7XG4gICAgICAgIG5ld1N0YWNrICs9IGN0eC5zdHlsaXplKG5vZGVNb2R1bGVbMV0sICdtb2R1bGUnKTtcbiAgICAgICAgcG9zID0gbm9kZU1vZHVsZS5pbmRleCArIG5vZGVNb2R1bGVbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgbmV3U3RhY2sgKz0gcG9zID09PSAwID8gbGluZSA6IGxpbmUuc2xpY2UocG9zKTtcbiAgICB9XG4gICAgc3RhY2sgPSBuZXdTdGFjaztcbiAgfVxuICAvLyBUaGUgbWVzc2FnZSBhbmQgdGhlIHN0YWNrIGhhdmUgdG8gYmUgaW5kZW50ZWQgYXMgd2VsbCFcbiAgaWYgKGN0eC5pbmRlbnRhdGlvbkx2bCAhPT0gMCkge1xuICAgIGNvbnN0IGluZGVudGF0aW9uID0gJyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpO1xuICAgIHN0YWNrID0gc3RhY2sucmVwbGFjZSgvXFxuL2csIGBcXG4ke2luZGVudGF0aW9ufWApO1xuICB9XG4gIHJldHVybiBzdGFjaztcbn1cbmZ1bmN0aW9uIGZvcm1hdFByb21pc2UoY3R4LCBfdmFsdWUsIF9yZWN1cnNlVGltZXMpIHtcbiAgLy8gTm9kZSBjYWxscyBpbnRvIG5hdGl2ZSB0byBnZXQgcHJvbWlzZSBkZXRhaWxzIHdoaWNoIHdlIGNhbid0IGRvXG4gIHJldHVybiBbY3R4LnN0eWxpemUoJzx1bmtub3duPicsICdzcGVjaWFsJyldO1xufVxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXksIHR5cGUpIHtcbiAgbGV0IG5hbWUsIHN0cjtcbiAgbGV0IGV4dHJhID0gJyAnO1xuICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7XG4gICAgdmFsdWU6IHZhbHVlW2tleV0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9O1xuICBpZiAoZGVzYy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZGlmZiA9IHR5cGUgIT09IGtPYmplY3RUeXBlIHx8IGN0eC5jb21wYWN0ICE9PSB0cnVlID8gMiA6IDM7XG4gICAgY3R4LmluZGVudGF0aW9uTHZsICs9IGRpZmY7XG4gICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMpO1xuICAgIGlmIChkaWZmID09PSAzKSB7XG4gICAgICBjb25zdCBsZW4gPSBjdHguY29sb3JzID8gcmVtb3ZlQ29sb3JzKHN0cikubGVuZ3RoIDogc3RyLmxlbmd0aDtcbiAgICAgIGlmIChjdHguYnJlYWtMZW5ndGggPCBsZW4pIHtcbiAgICAgICAgZXh0cmEgPSBgXFxuJHsnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmluZGVudGF0aW9uTHZsIC09IGRpZmY7XG4gIH0gZWxzZSBpZiAoZGVzYy5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxhYmVsID0gZGVzYy5zZXQgIT09IHVuZGVmaW5lZCA/ICdHZXR0ZXIvU2V0dGVyJyA6ICdHZXR0ZXInO1xuICAgIGNvbnN0IHMgPSBjdHguc3R5bGl6ZTtcbiAgICBjb25zdCBzcCA9ICdzcGVjaWFsJztcbiAgICBpZiAoY3R4LmdldHRlcnMgJiYgKGN0eC5nZXR0ZXJzID09PSB0cnVlIHx8IGN0eC5nZXR0ZXJzID09PSAnZ2V0JyAmJiBkZXNjLnNldCA9PT0gdW5kZWZpbmVkIHx8IGN0eC5nZXR0ZXJzID09PSAnc2V0JyAmJiBkZXNjLnNldCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG1wID0gdmFsdWVba2V5XTtcbiAgICAgICAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG4gICAgICAgIGlmICh0bXAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH06YCwgc3ApfSAke3MoJ251bGwnLCAnbnVsbCcpfSR7cygnXScsIHNwKX1gO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0bXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9XWAsIHNwKX0gJHtmb3JtYXRWYWx1ZShjdHgsIHRtcCwgcmVjdXJzZVRpbWVzKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShzLCB0bXAsIGN0eCk7XG4gICAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9OmAsIHNwKX0gJHtwcmltaXRpdmV9JHtzKCddJywgc3ApfWA7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGA8SW5zcGVjdGlvbiB0aHJldyAoJHtlcnIubWVzc2FnZX0pPmA7XG4gICAgICAgIHN0ciA9IGAke3MoYFske2xhYmVsfTpgLCBzcCl9ICR7bWVzc2FnZX0ke3MoJ10nLCBzcCl9YDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoYFske2xhYmVsfV1gLCBzcCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlc2Muc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICB9IGVsc2Uge1xuICAgIHN0ciA9IGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IGtBcnJheVR5cGUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgIGNvbnN0IHRtcCA9IGtleS50b1N0cmluZygpLnJlcGxhY2Uoc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIsIGVzY2FwZUZuKTtcbiAgICBuYW1lID0gYFske2N0eC5zdHlsaXplKHRtcCwgJ3N5bWJvbCcpfV1gO1xuICB9IGVsc2UgaWYgKGRlc2MuZW51bWVyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICBuYW1lID0gYFske2tleS5yZXBsYWNlKHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyLCBlc2NhcGVGbil9XWA7XG4gIH0gZWxzZSBpZiAoa2V5U3RyUmVnRXhwLnRlc3Qoa2V5KSkge1xuICAgIG5hbWUgPSBjdHguc3R5bGl6ZShrZXksICduYW1lJyk7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IGN0eC5zdHlsaXplKHN0ckVzY2FwZShrZXkpLCAnc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIGAke25hbWV9OiR7ZXh0cmF9JHtzdHJ9YDtcbn1cbmZ1bmN0aW9uIGdyb3VwQXJyYXlFbGVtZW50cyhjdHgsIG91dHB1dCwgdmFsdWUpIHtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgbGV0IG1heExlbmd0aCA9IDA7XG4gIGxldCBpID0gMDtcbiAgbGV0IG91dHB1dExlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoZSBcIi4uLiBuIG1vcmUgaXRlbXNcIiBwYXJ0IGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgb3V0cHV0TGVuZ3RoLS07XG4gIH1cbiAgY29uc3Qgc2VwYXJhdG9yU3BhY2UgPSAyOyAvLyBBZGQgMSBmb3IgdGhlIHNwYWNlIGFuZCAxIGZvciB0aGUgc2VwYXJhdG9yLlxuICBjb25zdCBkYXRhTGVuID0gbmV3IEFycmF5KG91dHB1dExlbmd0aCk7XG4gIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbGVuZ3RoIG9mIGFsbCBvdXRwdXQgZW50cmllcyBhbmQgdGhlIGluZGl2aWR1YWwgbWF4XG4gIC8vIGVudHJpZXMgbGVuZ3RoIG9mIGFsbCBvdXRwdXQgZW50cmllcy4gV2UgaGF2ZSB0byByZW1vdmUgY29sb3JzIGZpcnN0LFxuICAvLyBvdGhlcndpc2UgdGhlIGxlbmd0aCB3b3VsZCBub3QgYmUgY2FsY3VsYXRlZCBwcm9wZXJseS5cbiAgZm9yICg7IGkgPCBvdXRwdXRMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxlbiA9IGN0eC5jb2xvcnMgPyByZW1vdmVDb2xvcnMob3V0cHV0W2ldKS5sZW5ndGggOiBvdXRwdXRbaV0ubGVuZ3RoO1xuICAgIGRhdGFMZW5baV0gPSBsZW47XG4gICAgdG90YWxMZW5ndGggKz0gbGVuICsgc2VwYXJhdG9yU3BhY2U7XG4gICAgaWYgKG1heExlbmd0aCA8IGxlbikge1xuICAgICAgbWF4TGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfVxuICAvLyBBZGQgdHdvIHRvIGBtYXhMZW5ndGhgIGFzIHdlIGFkZCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBwbHVzIGEgY29tbWFcbiAgLy8gaW4tYmV0d2VlbiB0d28gZW50cmllcy5cbiAgY29uc3QgYWN0dWFsTWF4ID0gbWF4TGVuZ3RoICsgc2VwYXJhdG9yU3BhY2U7XG4gIC8vIENoZWNrIGlmIGF0IGxlYXN0IHRocmVlIGVudHJpZXMgZml0IG5leHQgdG8gZWFjaCBvdGhlciBhbmQgcHJldmVudCBncm91cGluZ1xuICAvLyBvZiBhcnJheXMgdGhhdCBjb250YWlucyBlbnRyaWVzIG9mIHZlcnkgZGlmZmVyZW50IGxlbmd0aCAoaS5lLiwgaWYgYSBzaW5nbGVcbiAgLy8gZW50cnkgaXMgbG9uZ2VyIHRoYW4gMS81IG9mIGFsbCBvdGhlciBlbnRyaWVzIGNvbWJpbmVkKS4gT3RoZXJ3aXNlIHRoZVxuICAvLyBzcGFjZSBpbi1iZXR3ZWVuIHNtYWxsIGVudHJpZXMgd291bGQgYmUgZW5vcm1vdXMuXG4gIGlmIChhY3R1YWxNYXggKiAzICsgY3R4LmluZGVudGF0aW9uTHZsIDwgY3R4LmJyZWFrTGVuZ3RoICYmICh0b3RhbExlbmd0aCAvIGFjdHVhbE1heCA+IDUgfHwgbWF4TGVuZ3RoIDw9IDYpKSB7XG4gICAgY29uc3QgYXBwcm94Q2hhckhlaWdodHMgPSAyLjU7XG4gICAgY29uc3QgYXZlcmFnZUJpYXMgPSBNYXRoLnNxcnQoYWN0dWFsTWF4IC0gdG90YWxMZW5ndGggLyBvdXRwdXQubGVuZ3RoKTtcbiAgICBjb25zdCBiaWFzZWRNYXggPSBNYXRoLm1heChhY3R1YWxNYXggLSAzIC0gYXZlcmFnZUJpYXMsIDEpO1xuICAgIC8vIER5bmFtaWNhbGx5IGNoZWNrIGhvdyBtYW55IGNvbHVtbnMgc2VlbSBwb3NzaWJsZS5cbiAgICBjb25zdCBjb2x1bW5zID0gTWF0aC5taW4oXG4gICAgLy8gSWRlYWxseSBhIHNxdWFyZSBzaG91bGQgYmUgZHJhd24uIFdlIGV4cGVjdCBhIGNoYXJhY3RlciB0byBiZSBhYm91dCAyLjVcbiAgICAvLyB0aW1lcyBhcyBoaWdoIGFzIHdpZGUuIFRoaXMgaXMgdGhlIGFyZWEgZm9ybXVsYSB0byBjYWxjdWxhdGUgYSBzcXVhcmVcbiAgICAvLyB3aGljaCBjb250YWlucyBuIHJlY3RhbmdsZXMgb2Ygc2l6ZSBgYWN0dWFsTWF4ICogYXBwcm94Q2hhckhlaWdodHNgLlxuICAgIC8vIERpdmlkZSB0aGF0IGJ5IGBhY3R1YWxNYXhgIHRvIHJlY2VpdmUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgLy8gVGhlIGFkZGVkIGJpYXMgaW5jcmVhc2VzIHRoZSBjb2x1bW5zIGZvciBzaG9ydCBlbnRyaWVzLlxuICAgIE1hdGgucm91bmQoTWF0aC5zcXJ0KGFwcHJveENoYXJIZWlnaHRzICogYmlhc2VkTWF4ICogb3V0cHV0TGVuZ3RoKSAvIGJpYXNlZE1heCksXG4gICAgLy8gRG8gbm90IGV4Y2VlZCB0aGUgYnJlYWtMZW5ndGguXG4gICAgTWF0aC5mbG9vcigoY3R4LmJyZWFrTGVuZ3RoIC0gY3R4LmluZGVudGF0aW9uTHZsKSAvIGFjdHVhbE1heCksXG4gICAgLy8gTGltaXQgYXJyYXkgZ3JvdXBpbmcgZm9yIHNtYWxsIGBjb21wYWN0YCBtb2RlcyBhcyB0aGUgdXNlciByZXF1ZXN0ZWRcbiAgICAvLyBtaW5pbWFsIGdyb3VwaW5nLlxuICAgIGN0eC5jb21wYWN0ICogNCxcbiAgICAvLyBMaW1pdCB0aGUgY29sdW1ucyB0byBhIG1heGltdW0gb2YgZmlmdGVlbi5cbiAgICAxNSk7XG4gICAgLy8gUmV0dXJuIHdpdGggdGhlIG9yaWdpbmFsIG91dHB1dCBpZiBubyBncm91cGluZyBzaG91bGQgaGFwcGVuLlxuICAgIGlmIChjb2x1bW5zIDw9IDEpIHtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGNvbnN0IHRtcCA9IFtdO1xuICAgIGNvbnN0IG1heExpbmVMZW5ndGggPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnM7IGkrKykge1xuICAgICAgbGV0IGxpbmVNYXhMZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBvdXRwdXQubGVuZ3RoOyBqICs9IGNvbHVtbnMpIHtcbiAgICAgICAgaWYgKGRhdGFMZW5bal0gPiBsaW5lTWF4TGVuZ3RoKSB7XG4gICAgICAgICAgbGluZU1heExlbmd0aCA9IGRhdGFMZW5bal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpbmVNYXhMZW5ndGggKz0gc2VwYXJhdG9yU3BhY2U7XG4gICAgICBtYXhMaW5lTGVuZ3RoW2ldID0gbGluZU1heExlbmd0aDtcbiAgICB9XG4gICAgbGV0IG9yZGVyID0gJ3BhZFN0YXJ0JztcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmRlciA9ICdwYWRFbmQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVhY2ggaXRlcmF0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgbGluZSBvZiBncm91cGVkIGVudHJpZXMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGg7IGkgKz0gY29sdW1ucykge1xuICAgICAgLy8gVGhlIGxhc3QgbGluZXMgbWF5IGNvbnRhaW4gbGVzcyBlbnRyaWVzIHRoYW4gY29sdW1ucy5cbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKGkgKyBjb2x1bW5zLCBvdXRwdXRMZW5ndGgpO1xuICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgbGV0IGogPSBpO1xuICAgICAgZm9yICg7IGogPCBtYXggLSAxOyBqKyspIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGV4dHJhIGNvbG9yIHBhZGRpbmcgaW4gY2FzZSBpdCdzIGFjdGl2ZS4gVGhpcyBoYXMgdG8gYmVcbiAgICAgICAgLy8gZG9uZSBsaW5lIGJ5IGxpbmUgYXMgc29tZSBsaW5lcyBtaWdodCBjb250YWluIG1vcmUgY29sb3JzIHRoYW5cbiAgICAgICAgLy8gb3RoZXJzLlxuICAgICAgICBjb25zdCBwYWRkaW5nID0gbWF4TGluZUxlbmd0aFtqIC0gaV0gKyBvdXRwdXRbal0ubGVuZ3RoIC0gZGF0YUxlbltqXTtcbiAgICAgICAgc3RyICs9IGAke291dHB1dFtqXX0sIGBbb3JkZXJdKHBhZGRpbmcsICcgJyk7XG4gICAgICB9XG4gICAgICBpZiAob3JkZXIgPT09ICdwYWRTdGFydCcpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IG1heExpbmVMZW5ndGhbaiAtIGldICsgb3V0cHV0W2pdLmxlbmd0aCAtIGRhdGFMZW5bal0gLSBzZXBhcmF0b3JTcGFjZTtcbiAgICAgICAgc3RyICs9IG91dHB1dFtqXS5wYWRTdGFydChwYWRkaW5nLCAnICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IG91dHB1dFtqXTtcbiAgICAgIH1cbiAgICAgIHRtcC5wdXNoKHN0cik7XG4gICAgfVxuICAgIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPCBvdXRwdXQubGVuZ3RoKSB7XG4gICAgICB0bXAucHVzaChvdXRwdXRbb3V0cHV0TGVuZ3RoXSk7XG4gICAgfVxuICAgIG91dHB1dCA9IHRtcDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZShjdHgsIGVyciwgY29uc3RydWN0b3JOYW1lLCBpbmRlbnRhdGlvbkx2bCkge1xuICBpZiAoaXNTdGFja092ZXJmbG93RXJyb3IoZXJyKSkge1xuICAgIGN0eC5zZWVuLnBvcCgpO1xuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCA9IGluZGVudGF0aW9uTHZsO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShgWyR7Y29uc3RydWN0b3JOYW1lfTogSW5zcGVjdGlvbiBpbnRlcnJ1cHRlZCAncHJlbWF0dXJlbHkuIE1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkLl1gLCAnc3BlY2lhbCcpO1xuICB9XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihmbiwgdmFsdWUpIHtcbiAgLy8gRm9ybWF0IC0wIGFzICctMCcuIENoZWNraW5nIGB2YWx1ZSA9PT0gLTBgIHdvbid0IGRpc3Rpbmd1aXNoIDAgZnJvbSAtMC5cbiAgcmV0dXJuIGZuKE9iamVjdC5pcyh2YWx1ZSwgLTApID8gJy0wJyA6IGAke3ZhbHVlfWAsICdudW1iZXInKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEJpZ0ludChmbiwgdmFsdWUpIHtcbiAgcmV0dXJuIGZuKGAke3ZhbHVlfW5gLCAnYmlnaW50Jyk7XG59XG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoZm4sIHZhbHVlLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoY3R4LmNvbXBhY3QgIT09IHRydWUgJiYgdmFsdWUubGVuZ3RoID4ga01pbkxpbmVMZW5ndGggJiYgdmFsdWUubGVuZ3RoID4gY3R4LmJyZWFrTGVuZ3RoIC0gY3R4LmluZGVudGF0aW9uTHZsIC0gNCkge1xuICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXG4vKS5tYXAobGluZSA9PiBmbihzdHJFc2NhcGUobGluZSksICdzdHJpbmcnKSkuam9pbihgICtcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsICsgMil9YCk7XG4gICAgfVxuICAgIHJldHVybiBmbihzdHJFc2NhcGUodmFsdWUpLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKGZuLCB2YWx1ZSk7XG4gIH1cbiAgLypcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgXHRyZXR1cm4gZm9ybWF0QmlnSW50KGZuLCB2YWx1ZSk7XG4gIH1cbiAgKi9cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZuKGAke3ZhbHVlfWAsICdib29sZWFuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZm4oJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgfVxuICAvLyBlczYgc3ltYm9sIHByaW1pdGl2ZVxuICByZXR1cm4gZm4oU3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnc3ltYm9sJyk7XG59XG5cbi8vIFRoZSBhcnJheSBpcyBzcGFyc2UgYW5kL29yIGhhcyBleHRyYSBrZXlzXG5mdW5jdGlvbiBmb3JtYXRTcGVjaWFsQXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBtYXhMZW5ndGgsIG91dHB1dCwgaSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICBsZXQgaW5kZXggPSBpO1xuICBmb3IgKDsgaSA8IGtleXMubGVuZ3RoICYmIG91dHB1dC5sZW5ndGggPCBtYXhMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgY29uc3QgdG1wID0gK2tleTtcbiAgICAvLyBBcnJheXMgY2FuIG9ubHkgaGF2ZSB1cCB0byAyXjMyIC0gMSBlbnRyaWVzXG4gICAgaWYgKHRtcCA+IDIgKiogMzIgLSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGAke2luZGV4fWAgIT09IGtleSkge1xuICAgICAgaWYgKCFudW1iZXJSZWdFeHAudGVzdChrZXkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgZW1wdHlJdGVtcyA9IHRtcCAtIGluZGV4O1xuICAgICAgY29uc3QgZW5kaW5nID0gZW1wdHlJdGVtcyA+IDEgPyAncycgOiAnJztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgPCR7ZW1wdHlJdGVtc30gZW1wdHkgaXRlbSR7ZW5kaW5nfT5gO1xuICAgICAgb3V0cHV0LnB1c2goY3R4LnN0eWxpemUobWVzc2FnZSwgJ3VuZGVmaW5lZCcpKTtcbiAgICAgIGluZGV4ID0gdG1wO1xuICAgICAgaWYgKG91dHB1dC5sZW5ndGggPT09IG1heExlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXksIGtBcnJheVR5cGUpKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIGNvbnN0IHJlbWFpbmluZyA9IHZhbHVlLmxlbmd0aCAtIGluZGV4O1xuICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gbWF4TGVuZ3RoKSB7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGNvbnN0IGVuZGluZyA9IHJlbWFpbmluZyA+IDEgPyAncycgOiAnJztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgPCR7cmVtYWluaW5nfSBlbXB0eSBpdGVtJHtlbmRpbmd9PmA7XG4gICAgICBvdXRwdXQucHVzaChjdHguc3R5bGl6ZShtZXNzYWdlLCAndW5kZWZpbmVkJykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFycmF5QnVmZmVyKGN0eCwgdmFsdWUpIHtcbiAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAvKlxuICAvLyBAZml4bWUgcm9sbHVwIGNhbm5vdCBoYW5kbGUgbGF6eSBsb2FkZWQgbW9kdWxlcywgbWF5YmUgbW92ZSB0byB3ZWJwYWNrP1xuICBpZiAoaGV4U2xpY2UgPT09IHVuZGVmaW5lZCkge1xuICBcdGhleFNsaWNlID0gdW5jdXJyeVRoaXMocmVxdWlyZSgnLi4vLi4vYnVmZmVyJykuZGVmYXVsdC5CdWZmZXIucHJvdG90eXBlLmhleFNsaWNlKTtcbiAgfVxuICAqL1xuICBsZXQgc3RyID0gaGV4U2xpY2UoYnVmZmVyLCAwLCBNYXRoLm1pbihjdHgubWF4QXJyYXlMZW5ndGgsIGJ1ZmZlci5sZW5ndGgpKS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKTtcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmZmVyLmxlbmd0aCAtIGN0eC5tYXhBcnJheUxlbmd0aDtcbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBzdHIgKz0gYCAuLi4gJHtyZW1haW5pbmd9IG1vcmUgYnl0ZSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWA7XG4gIH1cbiAgcmV0dXJuIFtgJHtjdHguc3R5bGl6ZSgnW1VpbnQ4Q29udGVudHNdJywgJ3NwZWNpYWwnKX06IDwke3N0cn0+YF07XG59XG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgY29uc3QgdmFsTGVuID0gdmFsdWUubGVuZ3RoO1xuICBjb25zdCBsZW4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBjdHgubWF4QXJyYXlMZW5ndGgpLCB2YWxMZW4pO1xuICBjb25zdCByZW1haW5pbmcgPSB2YWxMZW4gLSBsZW47XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gU3BlY2lhbCBoYW5kbGUgc3BhcnNlIGFycmF5cy5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHZhbHVlLCBpKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFNwZWNpYWxBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGxlbiwgb3V0cHV0LCBpKTtcbiAgICB9XG4gICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBpLCBrQXJyYXlUeXBlKSk7XG4gIH1cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gZm9ybWF0VHlwZWRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgY3R4Lm1heEFycmF5TGVuZ3RoKSwgdmFsdWUubGVuZ3RoKTtcbiAgY29uc3QgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICBjb25zdCBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcbiAgY29uc3QgZWxlbWVudEZvcm1hdHRlciA9IHZhbHVlLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyA/IGZvcm1hdE51bWJlciA6IGZvcm1hdEJpZ0ludDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7ICsraSkge1xuICAgIG91dHB1dFtpXSA9IGVsZW1lbnRGb3JtYXR0ZXIoY3R4LnN0eWxpemUsIHZhbHVlW2ldKTtcbiAgfVxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dFttYXhMZW5ndGhdID0gYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YDtcbiAgfVxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICAvLyAuYnVmZmVyIGdvZXMgbGFzdCwgaXQncyBub3QgYSBwcmltaXRpdmUgbGlrZSB0aGUgb3RoZXJzLlxuICAgIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsnQllURVNfUEVSX0VMRU1FTlQnLCAnbGVuZ3RoJywgJ2J5dGVMZW5ndGgnLCAnYnl0ZU9mZnNldCcsICdidWZmZXInXSkge1xuICAgICAgY29uc3Qgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMsIHRydWUpO1xuICAgICAgb3V0cHV0LnB1c2goYFske2tleX1dOiAke3N0cn1gKTtcbiAgICB9XG4gICAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNldChjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICBvdXRwdXQucHVzaChmb3JtYXRWYWx1ZShjdHgsIHYsIHJlY3Vyc2VUaW1lcykpO1xuICB9XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICAvLyBXaXRoIGBzaG93SGlkZGVuYCwgYGxlbmd0aGAgd2lsbCBkaXNwbGF5IGFzIGEgaGlkZGVuIHByb3BlcnR5IGZvclxuICAvLyBhcnJheXMuIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIGRvIHRoZSBzYW1lIGZvciBgc2l6ZWAsIGV2ZW4gdGhvdWdoIHRoaXNcbiAgLy8gcHJvcGVydHkgaXNuJ3Qgc2VsZWN0ZWQgYnkgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKS5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgb3V0cHV0LnB1c2goYFtzaXplXTogJHtjdHguc3R5bGl6ZShgJHt2YWx1ZS5zaXplfWAsICdudW1iZXInKX1gKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gZm9ybWF0TWFwKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlKSB7XG4gICAgb3V0cHV0LnB1c2goYCR7Zm9ybWF0VmFsdWUoY3R4LCBrLCByZWN1cnNlVGltZXMpfSA9PiAke2Zvcm1hdFZhbHVlKGN0eCwgdiwgcmVjdXJzZVRpbWVzKX1gKTtcbiAgfVxuICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcbiAgLy8gU2VlIGNvbW1lbnQgaW4gZm9ybWF0U2V0XG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIG91dHB1dC5wdXNoKGBbc2l6ZV06ICR7Y3R4LnN0eWxpemUoYCR7dmFsdWUuc2l6ZX1gLCAnbnVtYmVyJyl9YCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNldEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywgc3RhdGUpIHtcbiAgY29uc3QgbWF4QXJyYXlMZW5ndGggPSBNYXRoLm1heChjdHgubWF4QXJyYXlMZW5ndGgsIDApO1xuICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1pbihtYXhBcnJheUxlbmd0aCwgZW50cmllcy5sZW5ndGgpO1xuICBsZXQgb3V0cHV0ID0gbmV3IEFycmF5KG1heExlbmd0aCk7XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0W2ldID0gZm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW2ldLCByZWN1cnNlVGltZXMpO1xuICB9XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuICBpZiAoc3RhdGUgPT09IGtXZWFrICYmICFjdHguc29ydGVkKSB7XG4gICAgLy8gU29ydCBhbGwgZW50cmllcyB0byBoYXZlIGEgaGFsZndheSByZWxpYWJsZSBvdXRwdXQgKGlmIG1vcmUgZW50cmllcyB0aGFuXG4gICAgLy8gcmV0cmlldmVkIG9uZXMgZXhpc3QsIHdlIGNhbiBub3QgcmVsaWFibHkgcmV0dXJuIHRoZSBzYW1lIG91dHB1dCkgaWYgdGhlXG4gICAgLy8gb3V0cHV0IGlzIG5vdCBzb3J0ZWQgYW55d2F5LlxuICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KCk7XG4gIH1cbiAgY29uc3QgcmVtYWluaW5nID0gZW50cmllcy5sZW5ndGggLSBtYXhMZW5ndGg7XG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGZvcm1hdE1hcEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywgc3RhdGUpIHtcbiAgY29uc3QgbWF4QXJyYXlMZW5ndGggPSBNYXRoLm1heChjdHgubWF4QXJyYXlMZW5ndGgsIDApO1xuICAvLyBFbnRyaWVzIGV4aXN0IGFzIFtrZXkxLCB2YWwxLCBrZXkyLCB2YWwyLCAuLi5dXG4gIGNvbnN0IGxlbiA9IGVudHJpZXMubGVuZ3RoIC8gMjtcbiAgY29uc3QgcmVtYWluaW5nID0gbGVuIC0gbWF4QXJyYXlMZW5ndGg7XG4gIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWluKG1heEFycmF5TGVuZ3RoLCBsZW4pO1xuICBsZXQgb3V0cHV0ID0gbmV3IEFycmF5KG1heExlbmd0aCk7XG4gIGxldCBpID0gMDtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG4gIGlmIChzdGF0ZSA9PT0ga1dlYWspIHtcbiAgICBmb3IgKDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3MgPSBpICogMjtcbiAgICAgIG91dHB1dFtpXSA9IGAke2Zvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3NdLCByZWN1cnNlVGltZXMpfWAgKyBgID0+ICR7Zm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3BvcyArIDFdLCByZWN1cnNlVGltZXMpfWA7XG4gICAgfVxuICAgIC8vIFNvcnQgYWxsIGVudHJpZXMgdG8gaGF2ZSBhIGhhbGZ3YXkgcmVsaWFibGUgb3V0cHV0IChpZiBtb3JlIGVudHJpZXMgdGhhblxuICAgIC8vIHJldHJpZXZlZCBvbmVzIGV4aXN0LCB3ZSBjYW4gbm90IHJlbGlhYmx5IHJldHVybiB0aGUgc2FtZSBvdXRwdXQpIGlmIHRoZVxuICAgIC8vIG91dHB1dCBpcyBub3Qgc29ydGVkIGFueXdheS5cbiAgICBpZiAoIWN0eC5zb3J0ZWQpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5zb3J0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvcyA9IGkgKiAyO1xuICAgICAgY29uc3QgcmVzID0gW2Zvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3NdLCByZWN1cnNlVGltZXMpLCBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zICsgMV0sIHJlY3Vyc2VUaW1lcyldO1xuICAgICAgb3V0cHV0W2ldID0gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCByZXMsICcnLCBbJ1snLCAnXSddLCBrQXJyYXlFeHRyYXNUeXBlLCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgfVxuICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gZm9ybWF0V2Vha0NvbGxlY3Rpb24oY3R4KSB7XG4gIHJldHVybiBbY3R4LnN0eWxpemUoJzxpdGVtcyB1bmtub3duPicsICdzcGVjaWFsJyldO1xufVxuZnVuY3Rpb24gZm9ybWF0V2Vha1NldChjdHgsIF92YWx1ZSwgX3JlY3Vyc2VUaW1lcykge1xuICAvLyBOb2RlIGNhbGxzIGludG8gbmF0aXZlIHRvIGdldCBhIHByZXZpZXcgb2YgYWN0dWFsIHZhbHVlcyB3aGljaCB3ZSBjYW4ndCBkb1xuICByZXR1cm4gZm9ybWF0V2Vha0NvbGxlY3Rpb24oY3R4KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFdlYWtNYXAoY3R4LCBfdmFsdWUsIF9yZWN1cnNlVGltZXMpIHtcbiAgLy8gTm9kZSBjYWxscyBpbnRvIG5hdGl2ZSB0byBnZXQgYSBwcmV2aWV3IG9mIGFjdHVhbCB2YWx1ZXMgd2hpY2ggd2UgY2FuJ3QgZG9cbiAgcmV0dXJuIGZvcm1hdFdlYWtDb2xsZWN0aW9uKGN0eCk7XG59XG5mdW5jdGlvbiBmb3JtYXRJdGVyYXRvcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIF9rZXlzLCBicmFjZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBsZXQgaXNLZXlWYWx1ZSA9IGZhbHNlO1xuICBsZXQgcmVzdWx0ID0gdmFsdWUubmV4dCgpO1xuICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgY29uc3QgY3VycmVudEVudHJ5ID0gcmVzdWx0LnZhbHVlO1xuICAgIGVudHJpZXMucHVzaChjdXJyZW50RW50cnkpO1xuICAgIGlmIChjdXJyZW50RW50cnlbMF0gIT09IGN1cnJlbnRFbnRyeVsxXSkge1xuICAgICAgaXNLZXlWYWx1ZSA9IHRydWU7XG4gICAgfVxuICAgIHJlc3VsdCA9IHZhbHVlLm5leHQoKTtcbiAgfVxuICBpZiAoaXNLZXlWYWx1ZSkge1xuICAgIC8vIE1hcmsgZW50cnkgaXRlcmF0b3JzIGFzIHN1Y2guXG4gICAgYnJhY2VzWzBdID0gYnJhY2VzWzBdLnJlcGxhY2UoLyBJdGVyYXRvcl0geyQvLCAnIEVudHJpZXNdIHsnKTtcbiAgICByZXR1cm4gZm9ybWF0TWFwSXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBrTWFwRW50cmllcyk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdFNldEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywga0l0ZXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgc3RhcnQsIGJhc2UpIHtcbiAgLy8gRWFjaCBlbnRyeSBpcyBzZXBhcmF0ZWQgYnkgYXQgbGVhc3QgYSBjb21tYS4gVGh1cywgd2Ugc3RhcnQgd2l0aCBhIHRvdGFsXG4gIC8vIGxlbmd0aCBvZiBhdCBsZWFzdCBgb3V0cHV0Lmxlbmd0aGAuIEluIGFkZGl0aW9uLCBzb21lIGNhc2VzIGhhdmUgYVxuICAvLyB3aGl0ZXNwYWNlIGluLWJldHdlZW4gZWFjaCBvdGhlciB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0b3RhbCBhcyB3ZWxsLlxuICBsZXQgdG90YWxMZW5ndGggPSBvdXRwdXQubGVuZ3RoICsgc3RhcnQ7XG4gIGlmICh0b3RhbExlbmd0aCArIG91dHB1dC5sZW5ndGggPiBjdHguYnJlYWtMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmNvbG9ycykge1xuICAgICAgdG90YWxMZW5ndGggKz0gcmVtb3ZlQ29sb3JzKG91dHB1dFtpXSkubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBvdXRwdXRbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodG90YWxMZW5ndGggPiBjdHguYnJlYWtMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gRG8gbm90IGxpbmUgdXAgcHJvcGVydGllcyBvbiB0aGUgc2FtZSBsaW5lIGlmIGBiYXNlYCBjb250YWlucyBsaW5lIGJyZWFrcy5cbiAgcmV0dXJuIGJhc2UgPT09ICcnIHx8ICFiYXNlLmluY2x1ZGVzKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKGN0eCwgb3V0cHV0LCBiYXNlLCBicmFjZXMsIGV4dHJhc1R5cGUsIHJlY3Vyc2VUaW1lcywgdmFsdWUpIHtcbiAgaWYgKGN0eC5jb21wYWN0ICE9PSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBjdHguY29tcGFjdCA9PT0gJ251bWJlcicgJiYgY3R4LmNvbXBhY3QgPj0gMSkge1xuICAgICAgLy8gTWVtb3JpemUgdGhlIG9yaWdpbmFsIG91dHB1dCBsZW5ndGguIEluIGNhc2UgdGhlIHRoZSBvdXRwdXQgaXMgZ3JvdXBlZCxcbiAgICAgIC8vIHByZXZlbnQgbGluaW5nIHVwIHRoZSBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUuXG4gICAgICBjb25zdCBlbnRyaWVzID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgIC8vIEdyb3VwIGFycmF5IGVsZW1lbnRzIHRvZ2V0aGVyIGlmIHRoZSBhcnJheSBjb250YWlucyBhdCBsZWFzdCBzaXhcbiAgICAgIC8vIHNlcGFyYXRlIGVudHJpZXMuXG4gICAgICBpZiAoZXh0cmFzVHlwZSA9PT0ga0FycmF5RXh0cmFzVHlwZSAmJiBlbnRyaWVzID4gNikge1xuICAgICAgICBvdXRwdXQgPSBncm91cEFycmF5RWxlbWVudHMoY3R4LCBvdXRwdXQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIGBjdHguY3VycmVudERlcHRoYCBpcyBzZXQgdG8gdGhlIG1vc3QgaW5uZXIgZGVwdGggb2YgdGhlIGN1cnJlbnRseVxuICAgICAgLy8gaW5zcGVjdGVkIG9iamVjdCBwYXJ0IHdoaWxlIGByZWN1cnNlVGltZXNgIGlzIHRoZSBhY3R1YWwgY3VycmVudCBkZXB0aFxuICAgICAgLy8gdGhhdCBpcyBpbnNwZWN0ZWQuXG4gICAgICAvL1xuICAgICAgLy8gRXhhbXBsZTpcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdCBhID0geyBmaXJzdDogWyAxLCAyLCAzIF0sIHNlY29uZDogeyBpbm5lcjogWyAxLCAyLCAzIF0gfSB9XG4gICAgICAvL1xuICAgICAgLy8gVGhlIGRlZXBlc3QgZGVwdGggb2YgYGFgIGlzIDIgKGEuc2Vjb25kLmlubmVyKSBhbmQgYGEuZmlyc3RgIGhhcyBhIG1heFxuICAgICAgLy8gZGVwdGggb2YgMS5cbiAgICAgIC8vXG4gICAgICAvLyBDb25zb2xpZGF0ZSBhbGwgZW50cmllcyBvZiB0aGUgbG9jYWwgbW9zdCBpbm5lciBkZXB0aCB1cCB0b1xuICAgICAgLy8gYGN0eC5jb21wYWN0YCwgYXMgbG9uZyBhcyB0aGUgcHJvcGVydGllcyBhcmUgc21hbGxlciB0aGFuXG4gICAgICAvLyBgY3R4LmJyZWFrTGVuZ3RoYC5cbiAgICAgIGlmIChjdHguY3VycmVudERlcHRoIC0gcmVjdXJzZVRpbWVzIDwgY3R4LmNvbXBhY3QgJiYgZW50cmllcyA9PT0gb3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAvLyBMaW5lIHVwIGFsbCBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUgaW4gY2FzZSB0aGUgZW50cmllcyBkbyBub3RcbiAgICAgICAgLy8gZXhjZWVkIGBicmVha0xlbmd0aGAuIEFkZCAxMCBhcyBjb25zdGFudCB0byBzdGFydCBuZXh0IHRvIGFsbCBvdGhlclxuICAgICAgICAvLyBmYWN0b3JzIHRoYXQgbWF5IHJlZHVjZSBgYnJlYWtMZW5ndGhgLlxuICAgICAgICBjb25zdCBzdGFydCA9IG91dHB1dC5sZW5ndGggKyBjdHguaW5kZW50YXRpb25MdmwgKyBicmFjZXNbMF0ubGVuZ3RoICsgYmFzZS5sZW5ndGggKyAxMDtcbiAgICAgICAgaWYgKGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgc3RhcnQsIGJhc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2UgPyBgJHtiYXNlfSBgIDogJyd9JHticmFjZXNbMF19ICR7am9pbiQxKG91dHB1dCwgJywgJyl9ICR7YnJhY2VzWzFdfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTGluZSB1cCBlYWNoIGVudHJ5IG9uIGFuIGluZGl2aWR1YWwgbGluZS5cbiAgICBjb25zdCBpbmRlbnRhdGlvbiA9IGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gO1xuICAgIHJldHVybiBgJHtiYXNlID8gYCR7YmFzZX0gYCA6ICcnfSR7YnJhY2VzWzBdfSR7aW5kZW50YXRpb259ICBgICsgYCR7am9pbiQxKG91dHB1dCwgYCwke2luZGVudGF0aW9ufSAgYCl9JHtpbmRlbnRhdGlvbn0ke2JyYWNlc1sxXX1gO1xuICB9XG4gIC8vIExpbmUgdXAgYWxsIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZSBpbiBjYXNlIHRoZSBlbnRyaWVzIGRvIG5vdCBleGNlZWRcbiAgLy8gYGJyZWFrTGVuZ3RoYC5cbiAgaWYgKGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgMCwgYmFzZSkpIHtcbiAgICByZXR1cm4gYCR7YnJhY2VzWzBdfSR7YmFzZSA/IGAgJHtiYXNlfWAgOiAnJ30gJHtqb2luJDEob3V0cHV0LCAnLCAnKX0gYCArIGJyYWNlc1sxXTtcbiAgfVxuICBjb25zdCBpbmRlbnRhdGlvbiA9ICcgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKTtcbiAgLy8gSWYgdGhlIG9wZW5pbmcgXCJicmFjZVwiIGlzIHRvbyBsYXJnZSwgbGlrZSBpbiB0aGUgY2FzZSBvZiBcIlNldCB7XCIsXG4gIC8vIHdlIG5lZWQgdG8gZm9yY2UgdGhlIGZpcnN0IGl0ZW0gdG8gYmUgb24gdGhlIG5leHQgbGluZSBvciB0aGVcbiAgLy8gaXRlbXMgd2lsbCBub3QgbGluZSB1cCBjb3JyZWN0bHkuXG4gIGNvbnN0IGxuID0gYmFzZSA9PT0gJycgJiYgYnJhY2VzWzBdLmxlbmd0aCA9PT0gMSA/ICcgJyA6IGAke2Jhc2UgPyBgICR7YmFzZX1gIDogJyd9XFxuJHtpbmRlbnRhdGlvbn0gIGA7XG4gIC8vIExpbmUgdXAgZWFjaCBlbnRyeSBvbiBhbiBpbmRpdmlkdWFsIGxpbmUuXG4gIHJldHVybiBgJHticmFjZXNbMF19JHtsbn0ke2pvaW4kMShvdXRwdXQsIGAsXFxuJHtpbmRlbnRhdGlvbn0gIGApfSAke2JyYWNlc1sxXX1gO1xufVxuZnVuY3Rpb24gZm9ybWF0JDEoLi4uYXJncykge1xuICByZXR1cm4gZm9ybWF0V2l0aE9wdGlvbnModW5kZWZpbmVkLCAuLi5hcmdzKTtcbn1cbmNvbnN0IGZpcnN0RXJyb3JMaW5lID0gZXJyb3IgPT4gZXJyb3IubWVzc2FnZS5zcGxpdCgnXFxuJylbMF07XG5sZXQgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRTtcbmZ1bmN0aW9uIHRyeVN0cmluZ2lmeShhcmcpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gUG9wdWxhdGUgdGhlIGNpcmN1bGFyIGVycm9yIG1lc3NhZ2UgbGF6aWx5XG4gICAgaWYgKCFDSVJDVUxBUl9FUlJPUl9NRVNTQUdFKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhID0ge307XG4gICAgICAgIGEuYSA9IGE7XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFID0gZmlyc3RFcnJvckxpbmUoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgZmlyc3RFcnJvckxpbmUoZXJyKSA9PT0gQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuZnVuY3Rpb24gZm9ybWF0V2l0aE9wdGlvbnMoaW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpIHtcbiAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICBsZXQgYSA9IDA7XG4gIGxldCBzdHIgPSAnJztcbiAgbGV0IGpvaW4gPSAnJztcbiAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG4gICAgbGV0IHRlbXBTdHI7XG4gICAgbGV0IGxhc3RQb3MgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBpZiAoZmlyc3QuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgLy8gJyUnXG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gZmlyc3QuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgICBpZiAoYSArIDEgIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXh0Q2hhcikge1xuICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgIC8vICdzJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wQXJnID0gYXJnc1srK2FdO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBBcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9IGZvcm1hdE51bWJlcihzdHlsaXplTm9Db2xvciwgdGVtcEFyZyk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZW1wQXJnID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIFx0dGVtcFN0ciA9IGAke3RlbXBBcmd9bmA7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29uc3RyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEFyZyAhPT0gJ29iamVjdCcgfHwgdGVtcEFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgdGVtcEFyZy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJiAoaGFzT3duUHJvcGVydHkodGVtcEFyZywgJ3RvU3RyaW5nJylcbiAgICAgICAgICAgICAgICAvLyBBIGRpcmVjdCBvd24gcHJvcGVydHkgb24gdGhlIGNvbnN0cnVjdG9yIHByb3RvdHlwZSBpblxuICAgICAgICAgICAgICAgIC8vIGNhc2UgdGhlIGNvbnN0cnVjdG9yIGlzIG5vdCBhbiBidWlsdC1pbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgfHwgKGNvbnN0ciA9IHRlbXBBcmcuY29uc3RydWN0b3IpICYmICFidWlsdEluT2JqZWN0cy5oYXMoY29uc3RyLm5hbWUpICYmIGNvbnN0ci5wcm90b3R5cGUgJiYgaGFzT3duUHJvcGVydHkoY29uc3RyLnByb3RvdHlwZSwgJ3RvU3RyaW5nJykpKSB7XG4gICAgICAgICAgICAgICAgICB0ZW1wU3RyID0gU3RyaW5nKHRlbXBBcmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0ZW1wU3RyID0gaW5zcGVjdCh0ZW1wQXJnLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmluc3BlY3RPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0OiAzLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcnM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkZXB0aDogMFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDY6XG4gICAgICAgICAgICAgIC8vICdqJ1xuICAgICAgICAgICAgICB0ZW1wU3RyID0gdHJ5U3RyaW5naWZ5KGFyZ3NbKythXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDA6XG4gICAgICAgICAgICAgIC8vICdkJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wTnVtID0gYXJnc1srK2FdO1xuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBOdW0gPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgIFx0dGVtcFN0ciA9IGAke3RlbXBOdW19bmA7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBOdW0gPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdOYU4nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIE51bWJlcih0ZW1wTnVtKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDc5OlxuICAgICAgICAgICAgICAvLyAnTydcbiAgICAgICAgICAgICAgdGVtcFN0ciA9IGluc3BlY3QoYXJnc1srK2FdLCBpbnNwZWN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgICAgICAgIC8vICdvJ1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9IGluc3BlY3QoYXJnc1srK2FdLCB7XG4gICAgICAgICAgICAgICAgICAuLi5pbnNwZWN0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHNob3dIaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICBzaG93UHJveHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICBkZXB0aDogNFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEwNTpcbiAgICAgICAgICAgICAgLy8gJ2knXG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBJbnRlZ2VyID0gYXJnc1srK2FdO1xuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBJbnRlZ2VyID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICBcdHRlbXBTdHIgPSBgJHt0ZW1wSW50ZWdlcn1uYDtcbiAgICAgICAgICAgICAgfSBlbHNlICovXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEludGVnZXIgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdOYU4nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIHBhcnNlSW50KHRlbXBJbnRlZ2VyKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICAgICAgLy8gJ2YnXG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBGbG9hdCA9IGFyZ3NbKythXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wRmxvYXQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdOYU4nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXIoc3R5bGl6ZU5vQ29sb3IsIHBhcnNlRmxvYXQodGVtcEZsb2F0KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICAvLyAnJSdcbiAgICAgICAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gQW55IG90aGVyIGNoYXJhY3RlciBpcyBub3QgYSBjb3JyZWN0IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gaSAtIDEpIHtcbiAgICAgICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zLCBpIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSB0ZW1wU3RyO1xuICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gMzcpIHtcbiAgICAgICAgICBzdHIgKz0gZmlyc3Quc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0UG9zICE9PSAwKSB7XG4gICAgICBhKys7XG4gICAgICBqb2luID0gJyAnO1xuICAgICAgaWYgKGxhc3RQb3MgPCBmaXJzdC5sZW5ndGgpIHtcbiAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB3aGlsZSAoYSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhcmdzW2FdO1xuICAgIHN0ciArPSBqb2luO1xuICAgIHN0ciArPSB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnID8gaW5zcGVjdCh2YWx1ZSwgaW5zcGVjdE9wdGlvbnMpIDogdmFsdWU7XG4gICAgam9pbiA9ICcgJztcbiAgICBhKys7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5mdW5jdGlvbiBsb2dUaW1lKHNlbGYsIGxhYmVsLCBsb2dEYXRhKSB7XG4gIGxhYmVsID0gYCR7bGFiZWx9YDtcbiAgY29uc3Qgc3RhcnRUaW1lID0gc2VsZi5fdGltZXMuZ2V0KGxhYmVsKTtcbiAgaWYgKCFzdGFydFRpbWUpIHtcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBMYWJlbCBcIiR7bGFiZWx9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gIGlmIChsb2dEYXRhKSB7XG4gICAgc2VsZi5sb2coYCR7bGFiZWx9OiAke2R1cmF0aW9ufW1zYCwgLi4ubG9nRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5sb2coYCR7bGFiZWx9OiAke2R1cmF0aW9ufW1zYCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qga0NvbG9ySW5zcGVjdE9wdGlvbnMgPSB7XG4gIGNvbG9yczogdHJ1ZVxufTtcbmNvbnN0IGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMgPSB7fTtcbmxldCB0YWJsZVdhcm5lZDsgLy8gYm9vbGVhbiBmbGFnIGZvciBvbmUtdGltZSB3YXJuaW5nIGFib3V0IGNvbnNvbGUudGFibGUgbm90IGJlaW5nIGltcGxlbWVudGVkXG5cbi8vIE1ha2UgYSBmdW5jdGlvbiB0aGF0IGNhbiBzZXJ2ZSBhcyB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIGBzdHJlYW0ud3JpdGUoKWAuXG5mdW5jdGlvbiBjcmVhdGVXcml0ZUVycm9ySGFuZGxlcihzdHJlYW0pIHtcbiAgcmV0dXJuIGVyciA9PiB7XG4gICAgLy8gVGhpcyBjb25kaXRpb25hbCBldmFsdWF0ZXMgdG8gdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAvLyB0aGF0IHdhcyBub3QgYWxyZWFkeSBlbWl0dGVkICh3aGljaCBoYXBwZW5zIHdoZW4gdGhlIF93cml0ZSBjYWxsYmFja1xuICAgIC8vIGlzIGludm9rZWQgYXN5bmNocm9ub3VzbHkpLlxuICAgIGlmIChlcnIgIT09IG51bGwgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgaXQgd2lsbCBiZSBlbWl0dGVkIG9uIGBzdHJlYW1gIGFzXG4gICAgICAvLyBhbiBgZXJyb3JgIGV2ZW50LiBBZGRpbmcgYSBgb25jZWAgbGlzdGVuZXIgd2lsbCBrZWVwIHRoYXQgZXJyb3JcbiAgICAgIC8vIGZyb20gYmVjb21pbmcgYW4gdW5jYXVnaHQgZXhjZXB0aW9uLCBidXQgc2luY2UgdGhlIGhhbmRsZXIgaXNcbiAgICAgIC8vIHJlbW92ZWQgYWZ0ZXIgdGhlIGV2ZW50LCBub24tY29uc29sZS4qIHdyaXRlcyB3b24ndCBiZSBhZmZlY3RlZC5cbiAgICAgIC8vIHdlIGFyZSBvbmx5IGFkZGluZyBub29wIGlmIHRoZXJlIGlzIG5vIG9uZSBlbHNlIGxpc3RlbmluZyBmb3IgJ2Vycm9yJ1xuICAgICAgaWYgKHN0cmVhbS5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIG5vb3AkMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuY2xhc3MgQ29uc29sZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHN0ZGVyciwgaWdub3JlRXJyb3JzKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hcGlOYW1lID09PSAnVGkuQVBJJykge1xuICAgICAgLy8gUGFzc2luZyBpbiBUaS5BUEkgbW9kdWxlIHdoZXJlIHdlIHJldGFpbiBsb2cgbGV2ZWxzXG4gICAgICB0aGlzLl9hcGlNb2R1bGUgPSBvcHRpb25zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb2RlLkpTIHN0cmVhbXNcbiAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBubyBhcmdzLCBvciBmaXJzdCBhcmcgaXMgYSBzdHJlYW1cbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGRvdXQ6IG9wdGlvbnMsXG4gICAgICAgICAgc3RkZXJyLFxuICAgICAgICAgIGlnbm9yZUVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5fc3Rkb3V0ID0gb3B0aW9ucy5zdGRvdXQ7IC8vIFRPRE86IGVuZm9yY2UgaGFzIHdyaXRlIGZ1bmN0aW9uP1xuICAgICAgdGhpcy5fc3RkZXJyID0gb3B0aW9ucy5zdGRlcnIgfHwgdGhpcy5fc3Rkb3V0O1xuICAgICAgdGhpcy5faWdub3JlRXJyb3JzID0gb3B0aW9ucy5pZ25vcmVFcnJvcnMgIT09IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuX2lnbm9yZUVycm9ycykge1xuICAgICAgICB0aGlzLl9zdGRvdXRFcnJvckhhbmRsZXIgPSBjcmVhdGVXcml0ZUVycm9ySGFuZGxlcih0aGlzLl9zdGRvdXQpO1xuICAgICAgICB0aGlzLl9zdGRlcnJFcnJvckhhbmRsZXIgPSBjcmVhdGVXcml0ZUVycm9ySGFuZGxlcih0aGlzLl9zdGRlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29sb3JNb2RlID0gb3B0aW9ucy5jb2xvck1vZGUgfHwgJ2F1dG8nOyAvLyBUT0RPOiBlbmZvcmNlIGJvb2xlYW4gb3IgJ2F1dG8nXG4gICAgICB0aGlzLl9pbnNwZWN0T3B0aW9ucyA9IG9wdGlvbnMuaW5zcGVjdE9wdGlvbnM7IC8vIFRPRE86IGVuZm9yY2UgdW5kZWZpbmVkIG9yIHR5cGVvZiAnb2JqZWN0J1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2NvdW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ncm91cEluZGVudCA9ICcnO1xuICB9XG4gIF93cml0ZVRvQ29uc29sZShsZXZlbCwgc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2dyb3VwSW5kZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgaWYgKHN0cmluZy5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL1xcbi9nLCBgXFxuJHt0aGlzLl9ncm91cEluZGVudH1gKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRoaXMuX2dyb3VwSW5kZW50ICsgc3RyaW5nO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgd3JhcHBpbmcgVGkuQVBJICh3aGljaCByZXRhaW5zIGxvZyBsZXZlbClcbiAgICBpZiAodGhpcy5fYXBpTW9kdWxlKSB7XG4gICAgICB0aGlzLl9hcGlNb2R1bGVbbGV2ZWxdKHN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgTm9kZS5KUyBzdHJlYW1zIGxpa2Ugc3Rkb3V0L3N0ZGVyciB3aGljaCBkb24ndCBoYXZlIGxvZyBsZXZlbHNcbiAgICAgIGNvbnN0IHVzZVN0ZEVyciA9IGxldmVsID09PSAnd2FybicgfHwgbGV2ZWwgPT09ICdlcnJvcicgfHwgbGV2ZWwgPT09ICd0cmFjZSc7XG4gICAgICBjb25zdCBzdHJlYW0gPSB1c2VTdGRFcnIgPyB0aGlzLl9zdGRlcnIgOiB0aGlzLl9zdGRvdXQ7XG4gICAgICBpZiAodGhpcy5faWdub3JlRXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLndyaXRlKHN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXJlIG1heSBiZSBhbiBlcnJvciBvY2N1cnJpbmcgc3luY2hyb25vdXNseSAoZS5nLiBmb3IgZmlsZXMgb3IgVFRZc1xuICAgICAgLy8gb24gUE9TSVggc3lzdGVtcykgb3IgYXN5bmNocm9ub3VzbHkgKGUuZy4gcGlwZXMgb24gUE9TSVggc3lzdGVtcyksIHNvXG4gICAgICAvLyBoYW5kbGUgYm90aCBzaXR1YXRpb25zLlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQWRkIGFuZCBsYXRlciByZW1vdmUgYSBub29wIGVycm9yIGhhbmRsZXIgdG8gY2F0Y2ggc3luY2hyb25vdXMgZXJyb3JzLlxuICAgICAgICBpZiAoc3RyZWFtLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBub29wJDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IHVzZVN0ZEVyciA/IHRoaXMuX3N0ZGVyckVycm9ySGFuZGxlciA6IHRoaXMuX3N0ZG91dEVycm9ySGFuZGxlcjtcbiAgICAgICAgc3RyZWFtLndyaXRlKHN0cmluZywgZXJyb3JIYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ29uc29sZSBpcyBhIGRlYnVnZ2luZyB1dGlsaXR5LCBzbyBpdCBzd2FsbG93aW5nIGVycm9ycyBpcyBub3QgZGVzaXJhYmxlXG4gICAgICAgIC8vIGV2ZW4gaW4gZWRnZSBjYXNlcyBzdWNoIGFzIGxvdyBzdGFjayBzcGFjZS5cbiAgICAgICAgaWYgKGlzU3RhY2tPdmVyZmxvd0Vycm9yKGUpKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3JyeSwgdGhlcmUncyBubyBwcm9wZXIgd2F5IHRvIHBhc3MgYWxvbmcgdGhlIGVycm9yIGhlcmUuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIgJiYgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG5vb3AkMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGluZm8oLi4uYXJncykge1xuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCdpbmZvJywgZm9ybWF0V2l0aE9wdGlvbnMoa0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbiAgfVxuICB3YXJuKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnd2FybicsIGZvcm1hdFdpdGhPcHRpb25zKGtOb0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbiAgfVxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ2Vycm9yJywgZm9ybWF0V2l0aE9wdGlvbnMoa05vQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG4gIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnZGVidWcnLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG4gIHRyYWNlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgndHJhY2UnLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG4gIGNsZWFyKCkge30gLy8gbm8tb3BcblxuICBncm91cCguLi5kYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5sb2coLi4uZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX2dyb3VwSW5kZW50ICs9ICcgICc7XG4gIH1cbiAgZ3JvdXBFbmQoKSB7XG4gICAgdGhpcy5fZ3JvdXBJbmRlbnQgPSB0aGlzLl9ncm91cEluZGVudC5zbGljZSgwLCB0aGlzLl9ncm91cEluZGVudC5sZW5ndGggLSAyKTtcbiAgfVxuICBkaXIob2JqLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ2luZm8nLCBpbnNwZWN0KG9iaiwge1xuICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSkpO1xuICB9XG4gIGFzc2VydCh2YWx1ZSwgLi4uYXJncykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIGFyZ3NbMF0gPSBgQXNzZXJ0aW9uIGZhaWxlZCR7YXJncy5sZW5ndGggPT09IDAgPyAnJyA6IGA6ICR7YXJnc1swXX1gfWA7XG4gICAgICB0aGlzLndhcm4oLi4uYXJncyk7IC8vIFRoZSBhcmd1bWVudHMgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gd2FybigpIGFnYWluXG4gICAgfVxuICB9XG5cbiAgY291bnQobGFiZWwgPSAnZGVmYXVsdCcpIHtcbiAgICAvLyBFbnN1cmVzIHRoYXQgbGFiZWwgaXMgYSBzdHJpbmcsIGFuZCBvbmx5IHRoaW5ncyB0aGF0IGNhbiBiZVxuICAgIC8vIGNvZXJjZWQgdG8gc3RyaW5ncy4gZS5nLiBTeW1ib2wgaXMgbm90IGFsbG93ZWRcbiAgICBsYWJlbCA9IGAke2xhYmVsfWA7XG4gICAgbGV0IGNvdW50ID0gdGhpcy5fY291bnRzLmdldChsYWJlbCk7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gICAgdGhpcy5fY291bnRzLnNldChsYWJlbCwgY291bnQpO1xuICAgIHRoaXMubG9nKGAke2xhYmVsfTogJHtjb3VudH1gKTtcbiAgfVxuICBjb3VudFJlc2V0KGxhYmVsID0gJ2RlZmF1bHQnKSB7XG4gICAgaWYgKCF0aGlzLl9jb3VudHMuaGFzKGxhYmVsKSkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgQ291bnQgZm9yICcke2xhYmVsfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY291bnRzLmRlbGV0ZShgJHtsYWJlbH1gKTtcbiAgfVxuICB0aW1lKGxhYmVsID0gJ2RlZmF1bHQnKSB7XG4gICAgbGFiZWwgPSBgJHtsYWJlbH1gO1xuICAgIGlmICh0aGlzLl90aW1lcy5oYXMobGFiZWwpKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBMYWJlbCAke2xhYmVsfVwiIGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3RpbWVzLnNldChsYWJlbCwgRGF0ZS5ub3coKSk7XG4gIH1cbiAgdGltZUVuZChsYWJlbCA9ICdkZWZhdWx0Jykge1xuICAgIGNvbnN0IHdhcm5lZCA9IGxvZ1RpbWUodGhpcywgbGFiZWwpO1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB0aGlzLl90aW1lcy5kZWxldGUobGFiZWwpO1xuICAgIH1cbiAgfVxuICB0aW1lTG9nKGxhYmVsID0gJ2RlZmF1bHQnLCAuLi5sb2dEYXRhKSB7XG4gICAgbG9nVGltZSh0aGlzLCBsYWJlbCwgbG9nRGF0YSk7XG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgY29uc29sZS50YWJsZSgpXG4gIHRhYmxlKCkge1xuICAgIGlmICghdGFibGVXYXJuZWQpIHtcbiAgICAgIHRhYmxlV2FybmVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1wiY29uc29sZS50YWJsZVwiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gVGl0YW5pdW0hJyk7XG4gICAgfVxuICB9XG59XG5Db25zb2xlLnByb3RvdHlwZS5sb2cgPSBDb25zb2xlLnByb3RvdHlwZS5pbmZvOyAvLyBUcmVhdCBsb2cgYXMgYWxpYXMgdG8gaW5mb1xuQ29uc29sZS5wcm90b3R5cGUuZGlyeG1sID0gQ29uc29sZS5wcm90b3R5cGUubG9nOyAvLyBUcmVhdCBkaXJ4bWwgYXMgYWxpYXMgdG8gbG9nXG5Db25zb2xlLnByb3RvdHlwZS5ncm91cENvbGxhcHNlZCA9IENvbnNvbGUucHJvdG90eXBlLmdyb3VwO1xuY29uc3QgZ2xvYmFsQ29uc29sZSA9IG5ldyBDb25zb2xlKFRpLkFQSSk7XG5nbG9iYWxDb25zb2xlLkNvbnNvbGUgPSBDb25zb2xlO1xuZ2xvYmFsLmNvbnNvbGUgPSBnbG9iYWxDb25zb2xlO1xuXG4vKipcbiAqIFRpdGFuaXVtIFNES1xuICogQ29weXJpZ2h0IFRpRGV2LCBJbmMuIDA0LzA3LzIwMjItUHJlc2VudC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xuXG57XG4gIERhdGUucHJvdG90eXBlLnRvTG9jYWxlRGF0ZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gSW50bC5EYXRlVGltZUZvcm1hdC5fbWFrZVRpQ3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMpO1xuICAgIGNvbnN0IG9sZE9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnM7XG4gICAgaWYgKCFvbGRPcHRpb25zIHx8ICFvbGRPcHRpb25zLmRhdGVTdHlsZSAmJiAhb2xkT3B0aW9ucy5tb250aCAmJiAhb2xkT3B0aW9ucy5kYXkgJiYgIW9sZE9wdGlvbnMueWVhcikge1xuICAgICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIG1vbnRoOiAnbnVtZXJpYycsXG4gICAgICAgIGRheTogJ251bWVyaWMnLFxuICAgICAgICB5ZWFyOiAnbnVtZXJpYydcbiAgICAgIH07XG4gICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvbGRPcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQocHJvcGVydGllcy5sb2NhbGUsIHByb3BlcnRpZXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG4gIERhdGUucHJvdG90eXBlLnRvTG9jYWxlVGltZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gSW50bC5EYXRlVGltZUZvcm1hdC5fbWFrZVRpQ3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMpO1xuICAgIGNvbnN0IG9sZE9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnM7XG4gICAgaWYgKCFvbGRPcHRpb25zIHx8ICFvbGRPcHRpb25zLnRpbWVTdHlsZSAmJiAhb2xkT3B0aW9ucy5ob3VyICYmICFvbGRPcHRpb25zLm1pbnV0ZSAmJiAhb2xkT3B0aW9ucy5zZWNvbmQpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9sZE9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChwcm9wZXJ0aWVzLmxvY2FsZSwgcHJvcGVydGllcy5vcHRpb25zKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcbiAgRGF0ZS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IEludGwuRGF0ZVRpbWVGb3JtYXQuX21ha2VUaUNyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzKTtcbiAgICBjb25zdCBvbGRPcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zO1xuICAgIGxldCBoYXNPcHRpb24gPSBmYWxzZTtcbiAgICBpZiAob2xkT3B0aW9ucykge1xuICAgICAgaGFzT3B0aW9uID0gISFvbGRPcHRpb25zLmRhdGVTdHlsZSB8fCAhIW9sZE9wdGlvbnMudGltZVN0eWxlIHx8ICEhb2xkT3B0aW9ucy53ZWVrZGF5IHx8ICEhb2xkT3B0aW9ucy5tb250aCB8fCAhIW9sZE9wdGlvbnMuZGF5IHx8ICEhb2xkT3B0aW9ucy55ZWFyIHx8ICEhb2xkT3B0aW9ucy5ob3VyIHx8ICEhb2xkT3B0aW9ucy5taW51dGUgfHwgISFvbGRPcHRpb25zLnNlY29uZDtcbiAgICB9XG4gICAgaWYgKCFoYXNPcHRpb24pIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICBtb250aDogJ251bWVyaWMnLFxuICAgICAgICBkYXk6ICdudW1lcmljJyxcbiAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICBzZWNvbmQ6ICdudW1lcmljJ1xuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9sZE9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChwcm9wZXJ0aWVzLmxvY2FsZSwgcHJvcGVydGllcy5vcHRpb25zKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8vIEFkZCBhIHRvSlNPTigpIG1ldGhvZCB0byBhbGwgRXJyb3Igb2JqZWN0cyBuZWVkZWQgdG8gb3V0cHV0IG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4vLyBUaGUgSlNPTi5zdHJpbmdpZnkoKSB3aWxsIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGlzIG1ldGhvZCBpZiBpdCBleGlzdHMgdG8gcHJvdmlkZSBjdXN0b20gb3V0cHV0LlxuLy8gTm90ZXM6XG4vLyAtIEluIFY4LCBhbGwgRXJyb3IgcHJvcGVydGllcyBhcmUgbm90IGVudW1lcmFibGUuIFdlIG5lZWQgdGhpcyBvciBlbHNlIHN0cmluZ2lmeSgpIHdpbGwgcmV0dXJuIFwie31cIi5cbi8vIC0gSW4gSmF2YVNjcmlwdENvcmUsIG9ubHkgdGhlIFwic3RhY2tcIiBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZS4gV2Ugd2FudCB0byByZXZlYWwgdGhpcy5cbmlmICh0eXBlb2YgRXJyb3IucHJvdG90eXBlLnRvSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuICBFcnJvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcHJvcGVydGllc1tuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH07XG59XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBcImNyZWF0aW9uXCIgcHJvcGVydGllcyBkaWN0aW9uYXJ5IGZvciBUaXRhbml1bSdzIENvbGxhdG9yLCBEYXRlVGltZUZvcm1hdCwgYW5kIE51bWJlckZvcm1hdCBwcm94aWVzXG4gKiBmcm9tIHRoZSBnaXZlbiBJbnRsIHR5cGUncyBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdFtdfSBhcmdzXG4gKiBUaGUgYXJndW1lbnRzIGFycmF5IHRoYXQgd2FzIHBhc3NlZCBpbnRvIEludGwgQ29sbGF0b3IsIERhdGVUaW1lRm9ybWF0LCBvciBOdW1iZXJGb3JtYXQgdHlwZSdzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uIFJlZmVyZW5jZSB0byBhIHN1cHBvcnRlZExvY2FsZXNPZigpIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgcHJvcGVydGllcyBkaWN0aW9uYXJ5IHRvIGJlIHBhc3NlZCBpbnRvIGEgVGl0YW5pdW0gcHJveHkncyBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gbWFrZVRpRm9ybWF0Q3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmdzLCBzdXBwb3J0ZWRGb3JtYXRMb2NhbGVzRnVuY3Rpb24pIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICBpZiAoYXJncy5sZW5ndGggPj0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3BlcnRpZXMubG9jYWxlID0gYXJnc1swXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZExvY2FsZXMgPSBzdXBwb3J0ZWRGb3JtYXRMb2NhbGVzRnVuY3Rpb24oYXJnc1swXSk7XG4gICAgICBpZiAoc3VwcG9ydGVkTG9jYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMubG9jYWxlID0gc3VwcG9ydGVkTG9jYWxlc1swXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDIgJiYgdHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnKSB7XG4gICAgcHJvcGVydGllcy5vcHRpb25zID0gYXJnc1sxXTtcbiAgfVxuICByZXR1cm4gcHJvcGVydGllcztcbn1cblxuLy8gQWRkIFwiSW50bFwiIEFQSXMgbWlzc2luZyBvbiBBbmRyb2lkLlxue1xuICAvLyBTZXQgdXAgYW4gXCJJbnRsLkNvbGxhdG9yXCIgdHlwZSB3aGljaCB3cmFwcyBvdXIgdW5kb2N1bWVudGVkIFwiVGkuTG9jYWxlLkNvbGxhdG9yXCIgcHJveHkuXG4gIGZ1bmN0aW9uIFRpQ29sbGF0b3IoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzLCBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkQ29sbGF0b3JMb2NhbGVzKTtcbiAgICBjb25zdCBjb2xsYXRvciA9IG5ldyBUaS5Mb2NhbGUuQ29sbGF0b3IocHJvcGVydGllcyk7XG4gICAgY29sbGF0b3IuY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUuYmluZChjb2xsYXRvcik7XG4gICAgcmV0dXJuIGNvbGxhdG9yO1xuICB9XG4gIFRpQ29sbGF0b3Iuc3VwcG9ydGVkTG9jYWxlc09mID0gVGkuTG9jYWxlLmdldFN1cHBvcnRlZENvbGxhdG9yTG9jYWxlcztcblxuICAvLyBTZXQgdXAgYW4gXCJJbnRsLkRhdGVUaW1lRm9ybWF0XCIgdHlwZSB3aGljaCB3cmFwcyBvdXIgdW5kb2N1bWVudGVkIFwiVGkuTG9jYWxlLkRhdGVUaW1lRm9ybWF0XCIgcHJveHkuXG4gIGZ1bmN0aW9uIFRpRGF0ZVRpbWVGb3JtYXQoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzLCBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkRGF0ZVRpbWVGb3JtYXRMb2NhbGVzKTtcbiAgICByZXR1cm4gbmV3IFRpLkxvY2FsZS5EYXRlVGltZUZvcm1hdChwcm9wZXJ0aWVzKTtcbiAgfVxuICBUaURhdGVUaW1lRm9ybWF0Ll9tYWtlVGlDcmVhdGlvblByb3BlcnRpZXNGcm9tID0gYXJncyA9PiB7XG4gICAgcmV0dXJuIG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJncywgVGkuTG9jYWxlLmdldFN1cHBvcnRlZERhdGVUaW1lRm9ybWF0TG9jYWxlcyk7XG4gIH07XG4gIFRpRGF0ZVRpbWVGb3JtYXQuc3VwcG9ydGVkTG9jYWxlc09mID0gVGkuTG9jYWxlLmdldFN1cHBvcnRlZERhdGVUaW1lRm9ybWF0TG9jYWxlcztcblxuICAvLyBTZXQgdXAgYW4gXCJJbnRsLk51bWJlckZvcm1hdFwiIHR5cGUgd2hpY2ggd3JhcHMgb3VyIHVuZG9jdW1lbnRlZCBcIlRpLkxvY2FsZS5OdW1iZXJGb3JtYXRcIiBwcm94eS5cbiAgZnVuY3Rpb24gVGlOdW1iZXJGb3JtYXQoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzLCBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkTnVtYmVyRm9ybWF0TG9jYWxlcyk7XG4gICAgcmV0dXJuIG5ldyBUaS5Mb2NhbGUuTnVtYmVyRm9ybWF0KHByb3BlcnRpZXMpO1xuICB9XG4gIFRpTnVtYmVyRm9ybWF0LnN1cHBvcnRlZExvY2FsZXNPZiA9IFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWROdW1iZXJGb3JtYXRMb2NhbGVzO1xuXG4gIC8vIE1ha2Ugb3VyIGN1c3RvbSBcIkludGxcIiBtb2R1bGUgYXZhaWxhYmxlIGdsb2JhbGx5LlxuICBjb21tb25qc0dsb2JhbC5JbnRsID0ge1xuICAgIENvbGxhdG9yOiBUaUNvbGxhdG9yLFxuICAgIERhdGVUaW1lRm9ybWF0OiBUaURhdGVUaW1lRm9ybWF0LFxuICAgIE51bWJlckZvcm1hdDogVGlOdW1iZXJGb3JtYXQsXG4gICAgZ2V0Q2Fub25pY2FsTG9jYWxlczogVGkuTG9jYWxlLmdldENhbm9uaWNhbExvY2FsZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cblxue1xuICBOdW1iZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCguLi5hcmd1bWVudHMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMudmFsdWVPZigpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cblxue1xuICBTdHJpbmcucHJvdG90eXBlLmxvY2FsZUNvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZVN0cmluZywgbG9jYWxlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbGxhdG9yID0gbmV3IEludGwuQ29sbGF0b3IobG9jYWxlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvbGxhdG9yLmNvbXBhcmUodGhpcywgY29tcGFyZVN0cmluZyk7XG4gIH07XG4gIFN0cmluZy5wcm90b3R5cGUudG9Mb2NhbGVMb3dlckNhc2UgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgcmV0dXJuIFRpLkxvY2FsZS5tYWtlTG93ZXJDYXNlKHRoaXMsIGxvY2FsZSk7XG4gIH07XG4gIFN0cmluZy5wcm90b3R5cGUudG9Mb2NhbGVVcHBlckNhc2UgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgcmV0dXJuIFRpLkxvY2FsZS5tYWtlVXBwZXJDYXNlKHRoaXMsIGxvY2FsZSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgdG8gaGlqYWNrIHRoZSBzdGFuZGFyZCByZXF1aXJlIHRvIGFsbG93IGZvciBKU1xuICogaW1wbGVtZW50YXRpb25zIG9mIFwiY29yZVwiIG1vZHVsZXMuXG4gKlxuICogWW91IGFkZCBhIGJpbmRpbmcgZnJvbSB0aGUgXCJjb3JlXCIgbW9kdWxlIGlkIHRvIHRoZSB1bmRlciB0aGUgaG9vZCBKU1xuICogaW1wbGVtZW50YXRpb24uIFdlIHRoZW4gaW50ZXJjZXB0IHJlcXVpcmUgY2FsbHMgdG8gaGFuZGxlIHJlcXVlc3RzIGZvciB0aGVzZSBtb2R1bGVzXG4gKiBhbmQgbGF6aWx5IGxvYWQgdGhlIGZpbGUuXG4gKi9cblxuLyoqXG4gKiBVc2VkIGJ5IEBmdW5jdGlvbiBiaW5kT2JqZWN0VG9Db3JlTW9kdWxlSWRcbiAqIEB0eXBlIHttYXA8c3RyaW5nLCBvYmplY3Q+fVxuICovXG5jb25zdCBiaW5kaW5ncyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBVc2VkIGJ5IEBmdW5jdGlvbiByZWRpcmVjdENvcmVNb2R1bGVJZFRvUGF0aFxuICogQHR5cGUge21hcDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmNvbnN0IHJlZGlyZWN0cyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBEb2VzIHRoZSByZXF1ZXN0IGxvb2sgbGlrZSBhIHR5cGljYWwgY29yZSBtb2R1bGU/IChubyAnLicgb3IgJy8nIGNoYXJhY3RlcnMpXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBvcmlnaW5hbCByZXF1aXJlIHBhdGgvaWRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0hpamFja2FibGVNb2R1bGVJZChwYXRoKSB7XG4gIGlmICghcGF0aCB8fCBwYXRoLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGFyID0gcGF0aC5jaGFyQXQoMCk7XG4gIHJldHVybiBmaXJzdENoYXIgIT09ICcuJyAmJiBmaXJzdENoYXIgIT09ICcvJztcbn1cblxuLy8gSGFjayByZXF1aXJlIHRvIHBvaW50IHRvIHRoaXMgYXMgY29yZSBtb2R1bGUgXCJiaW5kaW5nXCIuIChOb3RlIHRoYXQgaU9TIGRvZXMgbm90IGhhdmUgYSBnbG9iYWwgcmVxdWlyZS4pXG5jb25zdCBvcmlnaW5hbFJlcXVpcmUgPSBnbG9iYWwucmVxdWlyZSA/IGdsb2JhbC5yZXF1aXJlIDogcmVxdWlyZS5tYWluLnJlcXVpcmUuYmluZChyZXF1aXJlLm1haW4pO1xuLy8gVGhpcyB3b3JrcyBmb3IgV2luZG93cyBhcy1pcywgYW5kIGFsc28gaW50ZXJjZXB0cyB0aGUgY2FsbCBvbiBBbmRyb2lkL2lPUyBmb3IgdGkubWFpbi5qcyAodGhlIGZpcnN0IGZpbGUgZXhlY3V0ZWQpXG5nbG9iYWwucmVxdWlyZSA9IGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuICBpZiAoYmluZGluZ3MuaGFzKG1vZHVsZUlkKSkge1xuICAgIHJldHVybiBiaW5kaW5ncy5nZXQobW9kdWxlSWQpO1xuICB9XG4gIGlmIChyZWRpcmVjdHMuaGFzKG1vZHVsZUlkKSkge1xuICAgIG1vZHVsZUlkID0gcmVkaXJlY3RzLmdldChtb2R1bGVJZCk7XG4gIH1cbiAgcmV0dXJuIG9yaWdpbmFsUmVxdWlyZShtb2R1bGVJZCk7XG59O1xuXG4vLyAuLi4gYnV0IHdlIHN0aWxsIG5lZWQgdG8gaGFjayBpdCB3aGVuIHJlcXVpcmluZyBmcm9tIG90aGVyIGZpbGVzIGZvciBBbmRyb2lkL2lPUyAoZHVlIHRvIG1vZHVsZS5qcyBpbXBsKVxuY29uc3Qgb3JpZ2luYWxNb2R1bGVSZXF1aXJlID0gZ2xvYmFsLk1vZHVsZS5wcm90b3R5cGUucmVxdWlyZTtcbmdsb2JhbC5Nb2R1bGUucHJvdG90eXBlLnJlcXVpcmUgPSBmdW5jdGlvbiAocGF0aCwgY29udGV4dCkge1xuICBpZiAoYmluZGluZ3MuaGFzKHBhdGgpKSB7XG4gICAgcmV0dXJuIGJpbmRpbmdzLmdldChwYXRoKTtcbiAgfVxuICBpZiAocmVkaXJlY3RzLmhhcyhwYXRoKSkge1xuICAgIHBhdGggPSByZWRpcmVjdHMuZ2V0KHBhdGgpO1xuICB9XG4gIHJldHVybiBvcmlnaW5hbE1vZHVsZVJlcXVpcmUuY2FsbCh0aGlzLCBwYXRoLCBjb250ZXh0KTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIGFuIGFscmVhZHkgbG9hZGVkL2NvbnN0cnVjdGVkIG9iamVjdC92YWx1ZSB0byBleHBvcnQgZm9yIHRoYXQgY29yZSBtb2R1bGUgaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgdGhlIG1vZHVsZSBpZCB0byBcImhpamFja1wiXG4gKiBAcGFyYW0geyp9IGJpbmRpbmcgYW4gYWxyZWFkeSBjb25zdHJ1Y3R1cmVkIHZhbHVlL29iamVjdCB0byByZXR1cm5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXIobW9kdWxlSWQsIGJpbmRpbmcpIHtcbiAgaWYgKCFpc0hpamFja2FibGVNb2R1bGVJZChtb2R1bGVJZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWdpc3RlciBmb3IgcmVsYXRpdmUvYWJzb2x1dGUgZmlsZSBwYXRoczsgbm8gbGVhZGluZyAnLicgb3IgJy8nIGFsbG93ZWQgKHdhcyBnaXZlbiAke21vZHVsZUlkfSlgKTtcbiAgfVxuICBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICAgIHJlZGlyZWN0cy5kZWxldGUobW9kdWxlSWQpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICB9XG4gIGJpbmRpbmdzLnNldChtb2R1bGVJZCwgYmluZGluZyk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIHRoZSBmdWxsIHVuZGVyIHRoZSBob29kIGZpbGVwYXRoIGlmIGdpdmVuIGEgc3RyaW5nLlxuICogVGhpcyBhbGxvd3MgZm9yIGxhenkgaW5zdGFudGlhdGlvbiBvZiB0aGUgbW9kdWxlIG9uLWRlbWFuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCB0aGUgbW9kdWxlIGlkIHRvIFwiaGlqYWNrXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCB0aGUgZnVsbCBmaWxlcGF0aCB0byByZXF1aXJlIHVuZGVyIHRoZSBob29kLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIHNob3VsZCBiZSBhbiBhbHJlYWR5IHJlc29sdmVkIGFic29sdXRlIHBhdGgsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIG90aGVyd2lzZSB0aGUgY29udGV4dCBvZiB0aGUgY2FsbCBjb3VsZCBjaGFuZ2Ugd2hhdCBnZXRzIGxvYWRlZCFcbiAqL1xuZnVuY3Rpb24gcmVkaXJlY3QobW9kdWxlSWQsIGZpbGVwYXRoKSB7XG4gIGlmICghaXNIaWphY2thYmxlTW9kdWxlSWQobW9kdWxlSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgZm9yIHJlbGF0aXZlL2Fic29sdXRlIGZpbGUgcGF0aHM7IG5vIGxlYWRpbmcgJy4nIG9yICcvJyBhbGxvd2VkICh3YXMgZ2l2ZW4gJHttb2R1bGVJZH0pYCk7XG4gIH1cbiAgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICAgIGJpbmRpbmdzLmRlbGV0ZShtb2R1bGVJZCk7XG4gIH0gZWxzZSBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICB9XG4gIHJlZGlyZWN0cy5zZXQobW9kdWxlSWQsIGZpbGVwYXRoKTtcbn1cblxuLy8gRklYTUU6IFRoZXJlJ3MgYSBjb2xsaXNpb24gaGVyZSB3aXRoIGdsb2JhbC5iaW5kaW5nIGRlY2xhcmVkIGluIEtyb2xsQnJpZGdlLm0gb24gaU9TXG5pZiAoIWdsb2JhbC5iaW5kaW5nKSB7XG4gIGdsb2JhbC5iaW5kaW5nID0ge307XG59XG5nbG9iYWwuYmluZGluZy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZ2xvYmFsLmJpbmRpbmcucmVkaXJlY3QgPSByZWRpcmVjdDtcblxuLy8gTG9hZCBhbGwgSmF2YVNjcmlwdCBleHRlbnNpb25zL3BvbHlmaWxsc1xucmVnaXN0ZXIoJ2NvbnNvbGUnLCBnbG9iYWxDb25zb2xlKTtcblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIC8vIEF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gSlNPTiBzdHJ1Y3R1cmVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpdGFuaXVtLkFjdGl2aXR5LnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGsgPT09ICd3aW5kb3cnIHx8IGsgPT09ICdpbnRlbnQnIHx8IGsuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkW2tdID0gdGhpc1trXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBjb25zdCBQcm9wZXJ0aWVzID0gVGl0YW5pdW0uQXBwLlByb3BlcnRpZXM7XG4gIGZ1bmN0aW9uIG51bGxPckRlZmF1bHRWYWx1ZShkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHByb3BlcnR5R2V0dGVyKGRlbGVnYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgaWYgKCFQcm9wZXJ0aWVzLmhhc1Byb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxPckRlZmF1bHRWYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGVnYXRlLmNhbGwoUHJvcGVydGllcywga2V5KTtcbiAgICB9O1xuICB9XG4gIFsnZ2V0Qm9vbCcsICdnZXREb3VibGUnLCAnZ2V0SW50JywgJ2dldFN0cmluZyddLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikge1xuICAgIFByb3BlcnRpZXNbZ2V0dGVyXSA9IHByb3BlcnR5R2V0dGVyKFByb3BlcnRpZXNbZ2V0dGVyXSk7XG4gIH0pO1xuICBQcm9wZXJ0aWVzLmdldExpc3QgPSBQcm9wZXJ0aWVzLmdldE9iamVjdCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICghUHJvcGVydGllcy5oYXNQcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gbnVsbE9yRGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKFByb3BlcnRpZXMuZ2V0U3RyaW5nKGtleSkpO1xuICB9O1xuICBQcm9wZXJ0aWVzLnNldExpc3QgPSBQcm9wZXJ0aWVzLnNldE9iamVjdCA9IGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIFByb3BlcnRpZXMuc2V0U3RyaW5nKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsKSk7XG4gIH07XG59XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuLyogZ2xvYmFscyBPU19BTkRST0lELCBPU19JT1MsIE9TX1ZFUlNJT05fTUFKT1IgKi9cbmNvbnN0IGJ1ZmZlciA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gIHZhbHVlOiAnJ1xufSk7XG5jb25zdCBibG9iID0gYnVmZmVyLnRvQmxvYigpO1xuY29uc3QgQmxvYlByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihibG9iKTtcbntcbiAgLy8gVGhpcyBkb2Vzbid0IFwic3RpY2tcIiBmb3IgaU9TLiBJdCBpcyBpbXBsZW1lbnRlZCBuYXRpdmVseS5cbiAgLy8gV2ViIEJsb2IgaGFzIGFuIGFycmF5QnVmZmVyKCkgbWV0aG9kIHRoYXQgcmV0dXJucyBhIFByb21pc2VcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Jsb2IvYXJyYXlCdWZmZXJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2JQcm90b3R5cGUsICdhcnJheUJ1ZmZlcicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGJ1ZjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBidWYgPSB0aGlzLnRvQXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoYnVmKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIGNvbnN0IExvY2FsZSA9IFRpdGFuaXVtLkxvY2FsZTtcbiAgY29uc3Qgd3JhcHBlZEdldFN0cmluZyA9IExvY2FsZS5nZXRTdHJpbmc7XG4gIExvY2FsZS5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVUeXBlID0gdHlwZW9mIGRlZmF1bHRWYWx1ZTtcbiAgICAvLyBJZiB0aGUgaGludC9kZWZhdWx0IGlzIG5vdCBhIHN0cmluZywgaWdub3JlIGl0IVxuICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHdyYXBwZWRHZXRTdHJpbmcuY2FsbChMb2NhbGUsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwcGVkR2V0U3RyaW5nLmNhbGwoTG9jYWxlLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH07XG4gIGNvbW1vbmpzR2xvYmFsLkwgPSBMb2NhbGUuZ2V0U3RyaW5nO1xufVxuXG4vLyBLZWVwcyBhbiBvYmplY3QgYWxpdmUgdW50aWwgZGlzcG9zZSgpIGlzIGNhbGxlZC5cbi8vIFRoaXMgaXMgY3VycmVudGx5IHVzZWQgdG8ga2VlcCBcInRvcCBsZXZlbFwiIG9iamVjdHNcbi8vIChleDogd2luZG93cywgdGFiIGdyb3VwcykgYWxpdmUgdW50aWwgdGhlaXIgbGlmZWN5Y2xlIGVuZHMuXG5mdW5jdGlvbiBQZXJzaXN0ZW50SGFuZGxlKG9iamVjdCkge1xuICB0aGlzLmNlbGwgPSBQZXJzaXN0ZW50SGFuZGxlLmxhc3RJZCsrO1xuICBQZXJzaXN0ZW50SGFuZGxlLm9iamVjdHNbdGhpcy5jZWxsXSA9IG9iamVjdDtcbn1cblxuLy8gT2JqZWN0cyByZXRhaW5lZCBieSBwZXJzaXN0ZW50IGhhbmRsZXMuXG4vLyBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBhY3RzIGFzIGEgc3RvcmFnZSBcImNlbGxcIlxuLy8ga2VlcGluZyB0aGUgb2JqZWN0IHJlYWNoYWJsZSBhbmQgYWxpdmUgdW50aWwgaXQgaXMgcmVtb3ZlZC5cblBlcnNpc3RlbnRIYW5kbGUub2JqZWN0cyA9IHt9O1xuUGVyc2lzdGVudEhhbmRsZS5sYXN0SWQgPSAwO1xuUGVyc2lzdGVudEhhbmRsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2VsbCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIGhhbmRsZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgUGVyc2lzdGVudEhhbmRsZS5vYmplY3RzW3RoaXMuY2VsbF07XG4gIHRoaXMuY2VsbCA9IC0xO1xufTtcblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG57XG4gIGNvbnN0IEhUVFBDbGllbnQgPSBUaXRhbml1bS5OZXR3b3JrLkhUVFBDbGllbnQ7XG4gIGNvbnN0IF9zZW5kID0gSFRUUENsaWVudC5wcm90b3R5cGUuc2VuZDtcbiAgSFRUUENsaWVudC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gUmV0YWluIHRoZSBodHRwY2xpZW50IHVudGlsIHRoZSByZXF1ZXN0IGhhcyBiZWVuIGZpbmlzaGVkLlxuICAgIGNvbnN0IGhhbmRsZSA9IG5ldyBQZXJzaXN0ZW50SGFuZGxlKHRoaXMpO1xuICAgIHRoaXMub24oJ2Rpc3Bvc2VoYW5kbGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgaWYgKGtyb2xsLkRCRykge1xuICAgICAgICBrcm9sbC5sb2coJ0hUVFBDbGllbnQnLCAnVGhlIHBlcnNpc3RlbnQgaGFuZGxlIGlzIGRpc3Bvc2VkLicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9zZW5kLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIH07XG59XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG5cbntcbiAgZnVuY3Rpb24gaVBob25lQ29uc3RhbnQobmFtZSkge1xuICAgIFRpdGFuaXVtLkFQSS5lcnJvcignISEhJyk7XG4gICAgVGl0YW5pdW0uQVBJLmVycm9yKCchISEgV0FSTklORyA6IFVzZSBvZiB1bnN1cHBvcnRlZCBjb25zdGFudCBUaS5VSS5pUGhvbmUuJyArIG5hbWUgKyAnICEhIScpO1xuICAgIFRpdGFuaXVtLkFQSS5lcnJvcignISEhJyk7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBUT0RPOiBSZW1vdmUgbWUuIE9ubHkgZm9yIHRlbXBvcmFyeSBjb21wYXRpYmlsaXR5XG4gIFRpdGFuaXVtLlVJLmlQaG9uZSA9IHtcbiAgICBBY3Rpdml0eUluZGljYXRvclN0eWxlOiB7XG4gICAgICBnZXQgQklHKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ0FjdGl2aXR5SW5kaWNhdG9yU3R5bGUuQklHJyk7XG4gICAgICB9LFxuICAgICAgZ2V0IERBUksoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnQWN0aXZpdHlJbmRpY2F0b3JTdHlsZS5EQVJLJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBBbmltYXRpb25TdHlsZToge1xuICAgICAgZ2V0IEZMSVBfRlJPTV9MRUZUKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ0FuaW1hdGlvblN0eWxlLkZMSVBfRlJPTV9MRUZUJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBQcm9ncmVzc0JhclN0eWxlOiB7XG4gICAgICBnZXQgU0lNUExFKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1Byb2dyZXNzQmFyU3R5bGUuU0lNUExFJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBTeXN0ZW1CdXR0b246IHtcbiAgICAgIGdldCBGTEVYSUJMRV9TUEFDRSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdTeXN0ZW1CdXR0b24uRkxFWElCTEVfU1BBQ0UnKTtcbiAgICAgIH0sXG4gICAgICBnZXQgRElTQ0xPU1VSRSgpIHtcbiAgICAgICAgcmV0dXJuIGlQaG9uZUNvbnN0YW50KCdTeXN0ZW1CdXR0b24uRElTQ0xPU1VSRScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgU3lzdGVtQnV0dG9uU3R5bGU6IHtcbiAgICAgIGdldCBCQVIoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnU3lzdGVtQnV0dG9uU3R5bGUuQkFSJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBUYWJsZVZpZXdDZWxsU2VsZWN0aW9uU3R5bGU6IHtcbiAgICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1RhYmxlVmlld0NlbGxTZWxlY3Rpb25TdHlsZS5OT05FJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBUYWJsZVZpZXdTZXBhcmF0b3JTdHlsZToge1xuICAgICAgZ2V0IE5PTkUoKSB7XG4gICAgICAgIHJldHVybiBpUGhvbmVDb25zdGFudCgnVGFibGVWaWV3U2VwYXJhdG9yU3R5bGUuTk9ORScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgUm93QW5pbWF0aW9uU3R5bGU6IHtcbiAgICAgIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1Jvd0FuaW1hdGlvblN0eWxlLk5PTkUnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFRhYmxlVmlld1Njcm9sbFBvc2l0aW9uOiB7XG4gICAgICBnZXQgTUlERExFKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1RhYmxlVmlld1Njcm9sbFBvc2l0aW9uLk1JRERMRScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgVGFibGVWaWV3U3R5bGU6IHtcbiAgICAgIGdldCBHUk9VUEVEKCkge1xuICAgICAgICByZXR1cm4gaVBob25lQ29uc3RhbnQoJ1RhYmxlVmlld1N0eWxlLkdST1VQRUQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWwgT1NfQU5EUk9JRCAqL1xuXG57XG4gIGNvbnN0IExpc3RWaWV3ID0gVGl0YW5pdW0uVUkuTGlzdFZpZXc7XG4gIGNvbnN0IGRlZmF1bHRUZW1wbGF0ZSA9IHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBoZWlnaHQ6ICc0NWRwJ1xuICAgIH0sXG4gICAgY2hpbGRUZW1wbGF0ZXM6IFt7XG4gICAgICB0eXBlOiAnVGkuVUkuTGFiZWwnLFxuICAgICAgYmluZElkOiAndGl0bGUnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBsZWZ0OiAnNmRwJyxcbiAgICAgICAgd2lkdGg6ICc3NSUnXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgdHlwZTogJ1RpLlVJLkltYWdlVmlldycsXG4gICAgICBiaW5kSWQ6ICdpbWFnZScsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJpZ2h0OiAnMjVkcCcsXG4gICAgICAgIHdpZHRoOiAnMTUlJ1xuICAgICAgfVxuICAgIH1dXG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZUxpc3RWaWV3KG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucy50ZW1wbGF0ZXMgPSB7XG4gICAgICBbVGl0YW5pdW0uVUkuTElTVF9JVEVNX1RFTVBMQVRFX0RFRkFVTFRdOiBkZWZhdWx0VGVtcGxhdGUsXG4gICAgICAuLi5vcHRpb25zLnRlbXBsYXRlc1xuICAgIH07XG4gICAgY29uc3QgdGVtcGxhdGVzID0gb3B0aW9ucy50ZW1wbGF0ZXM7XG4gICAgZm9yIChjb25zdCBiaW5kaW5nIGluIHRlbXBsYXRlcykge1xuICAgICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gdGVtcGxhdGVzW2JpbmRpbmddO1xuICAgICAgcHJvY2Vzc1RlbXBsYXRlKGN1cnJlbnRUZW1wbGF0ZSk7XG4gICAgICBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMoY3VycmVudFRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaXN0VmlldyhvcHRpb25zKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBMaXN0SXRlbVByb3h5LCBhZGQgZXZlbnRzLCB0aGVuIHN0b3JlIGl0IGluICd0aVByb3h5JyBwcm9wZXJ0eVxuICBmdW5jdGlvbiBwcm9jZXNzVGVtcGxhdGUocHJvcGVydGllcykge1xuICAgIGNvbnN0IGNlbGxQcm94eSA9IFRpdGFuaXVtLlVJLmNyZWF0ZUxpc3RJdGVtKCk7XG4gICAgY29uc3QgZXZlbnRzID0gcHJvcGVydGllcy5ldmVudHM7XG4gICAgcHJvcGVydGllcy50aVByb3h5ID0gY2VsbFByb3h5O1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKGV2ZW50cywgY2VsbFByb3h5KTtcbiAgfVxuXG4gIC8vIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IHByb2Nlc3MgY2hpbGRUZW1wbGF0ZXMgYW5kIGFwcGVuZCBjb3JyZXNwb25kaW5nIHByb3hpZXMgdG9cbiAgLy8gcHJvcGVydHkgJ3RpUHJveHknLiBJLmU6IHR5cGU6IFwiVGl0YW5pdW0uVUkuTGFiZWxcIiAtPiB0aVByb3h5OiBMYWJlbFByb3h5IG9iamVjdFxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRUZW1wbGF0ZXMocHJvcGVydGllcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BlcnRpZXMsICdjaGlsZFRlbXBsYXRlcycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkUHJvcGVydGllcyA9IHByb3BlcnRpZXMuY2hpbGRUZW1wbGF0ZXM7XG4gICAgaWYgKCFjaGlsZFByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRQcm9wZXJ0aWVzW2ldO1xuICAgICAgY29uc3QgcHJveHlUeXBlID0gY2hpbGQudHlwZTtcbiAgICAgIGlmIChwcm94eVR5cGUpIHtcbiAgICAgICAgY29uc3QgY3JlYXRpb25Qcm9wZXJ0aWVzID0gY2hpbGQucHJvcGVydGllcztcbiAgICAgICAgY29uc3QgY3JlYXRpb25GdW5jdGlvbiA9IGxvb2t1cChwcm94eVR5cGUpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBwcm94eS5cbiAgICAgICAgbGV0IGNoaWxkUHJveHk7XG4gICAgICAgIGlmIChjcmVhdGlvblByb3BlcnRpZXMpIHtcbiAgICAgICAgICBjaGlsZFByb3h5ID0gY3JlYXRpb25GdW5jdGlvbihjcmVhdGlvblByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoaWxkUHJveHkgPSBjcmVhdGlvbkZ1bmN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgY29uc3QgZXZlbnRzID0gY2hpbGQuZXZlbnRzO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVycyhldmVudHMsIGNoaWxkUHJveHkpO1xuXG4gICAgICAgIC8vIEFwcGVuZCBwcm94eSB0byB0aVByb3h5IHByb3BlcnR5LlxuICAgICAgICBjaGlsZC50aVByb3h5ID0gY2hpbGRQcm94eTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3NDaGlsZFRlbXBsYXRlcyhjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycy5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoZXZlbnRzLCBwcm94eSkge1xuICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIHByb3h5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGxvb2t1cFByb3h5Q29uc3RydWN0b3IobmFtZXNwYWNlKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlSW5kZXggPSBuYW1lc3BhY2UubGFzdEluZGV4T2YoJy4nKTtcbiAgICBjb25zdCBwcm94eU5hbWUgPSBuYW1lc3BhY2Uuc2xpY2UobmFtZXNwYWNlSW5kZXggKyAxKTtcbiAgICBjb25zdCBwYXJlbnROYW1lc3BhY2UgPSBuYW1lc3BhY2Uuc3Vic3RyaW5nKDAsIG5hbWVzcGFjZUluZGV4KTtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhcmVudE5hbWVzcGFjZS5zcGxpdCgnLicpO1xuICAgIGxldCBwYXJlbnRQcm94eSA9IGNvbW1vbmpzR2xvYmFsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcmVudFByb3h5ID0gcGFyZW50UHJveHlbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICBpZiAocGFyZW50UHJveHkpIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBhcmVudFByb3h5W2BjcmVhdGUke3Byb3h5TmFtZX1gXTtcbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbG9va3VwIGNvbnN0cnVjdG9yIGZvciBuYW1lc3BhY2U6IFwiJHtuYW1lc3BhY2V9XCJgKTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgbmFtZSBvZiBVSSBlbGVtZW50cyBpbnRvIGEgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gIC8vIGkuZTogbG9va3VwKFwiVGl0YW5pdW0uVUkuTGFiZWxcIikgcmV0dXJucyBUaXRhbml1bS5VSS5jcmVhdGVMYWJlbCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gbG9va3VwKG5hbWVzcGFjZSkge1xuICAgIC8vIEhhbmRsZSBUaXRhbml1bSB3aWRnZXRzLlxuICAgIGlmICgvXihUaXxUaXRhbml1bSkvLnRlc3QobmFtZXNwYWNlKSkge1xuICAgICAgcmV0dXJuIGxvb2t1cFByb3h5Q29uc3RydWN0b3IobmFtZXNwYWNlKTtcblxuICAgICAgLy8gSGFuZGxlIEFsbG95IHdpZGdldHMuXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB3aWRnZXQ7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGxvYWQgYWxsb3kgd2lkZ2V0LlxuICAgICAgICB3aWRnZXQgPSBjb21tb25qc0dsb2JhbC5Nb2R1bGUubWFpbi5yZXF1aXJlKGAvYWxsb3kvd2lkZ2V0cy8ke25hbWVzcGFjZX0vY29udHJvbGxlcnMvd2lkZ2V0YCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gV2lkZ2V0IGRvZXMgbm90IGV4aXN0LCBhdHRlbXB0IHRvIGxvYWQgbmFtZXNwYWNlLlxuICAgICAgICAgIHdpZGdldCA9IGNvbW1vbmpzR2xvYmFsLk1vZHVsZS5tYWluLnJlcXVpcmUobmFtZXNwYWNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gTmFtZXNwYWNlIGRvZXMgbm90IGV4aXN0LCBmYWxsIGJhY2sgdG8gbGVnYWN5IGJlaGF2aW91ci5cbiAgICAgICAgICByZXR1cm4gbG9va3VwUHJveHlDb25zdHJ1Y3RvcihuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgICAgIGNvbnN0IG9iaiA9IG5ldyB3aWRnZXQocGFyYW1ldGVycyk7XG4gICAgICAgICAgcmV0dXJuIG9iai5nZXRWaWV3KCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gT3ZlcndyaXRlIGxpc3QgdmlldyBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aXRoIG91ciBvd24uXG4gIFRpdGFuaXVtLlVJLmNyZWF0ZUxpc3RWaWV3ID0gY3JlYXRlTGlzdFZpZXc7XG59XG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICAvLyBBdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIGluIEpTT04gc3RydWN0dXJlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXRhbml1bS5VSS5OYXZpZ2F0aW9uV2luZG93LnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGsgPT09ICdwYXJlbnQnIHx8IGsgPT09ICd3aW5kb3cnIHx8IGsuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzZXJpYWxpemVkW2tdID0gdGhpc1trXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5cbi8qKlxuICogVGhpcyBzY3JpcHQgaXMgdXNlZCBhdCBydW50aW1lIGZvciBUaS5VSS5mZXRjaFNlbWFudGljQ29sb3IgLSBhcyB3ZWxsIGFzIGF0IGJ1aWxkIHRpbWUgYnkgYm90aCBpT1MvQW5kcm9pZC5cbiAqIEl0IHByb3ZpZGVzIGEgY29tbW9uIGludGVyZmFjZSBmb3IgaGFuZGxpbmcgY29sb3JzIGFuZCBjb252ZXJ0aW5nIHRvIG5lY2Vzc2FyeSBzdHJpbmcgZm9ybXMuXG4gKi9cbmNvbnN0IEhFWF8zX1JFR0VYID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTsgLy8gaS5lLiAjMEYzXG5jb25zdCBIRVhfNF9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pOyAvLyBpLmUuICMwRjM4XG5jb25zdCBIRVhfNl9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pezZ9JC9pOyAvLyBpLmUuICMwMEZGMzNcbmNvbnN0IEhFWF84X1JFR0VYID0gL14jPyhbYS1mXFxkXSl7OH0kL2k7IC8vIGkuZS4gIzAwRkYzMzg4XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGludGVnZXIgaW4gcmFuZ2Ugb2YgMC0yNTVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IDItY2hhcmFjdGVyIGhleCBzdHJpbmcgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcGFkZGVkSGV4KGludGVnZXIpIHtcbiAgY29uc3Qgc3RyID0gaW50ZWdlci50b1N0cmluZygxNik7XG4gIGlmIChzdHIubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGAwJHtzdHJ9YDtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuY2xhc3MgQ29sb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHIgcmVkIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBnIGdyZWVuIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiIGJsdWUgdmFsdWUgaW4gcmFuZ2UgMC0yNTVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthPTEuMF0gYWxwaGEgdmFsdWUgaW4gcmFuZ2UgMC4wLTEuMFxuICAgKi9cbiAgY29uc3RydWN0b3IociwgZywgYiwgYSA9IDEuMCkge1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5nID0gZztcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYWxwaGEgPSBhO1xuICB9XG5cbiAgLyoqXG4gICAqIGluZGljYXRlcyBpZiB0aGlzIGlzIGEgZnVsbHkgb3BhcXVlIGNvbG9yIChhbHBoYSBpcyAxLjAgb3Igd2FzIHVuZGVmaW5lZClcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc09wYXF1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYSA9PT0gMS4wO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBhbHBoYSB2YWx1ZSBpbnRvIGVxdWl2YWxlbnQgaGV4IHN0cmluZyB2YWx1ZSBwcm9wZXJseS5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGFscGhhSGV4KCkge1xuICAgIC8vIG5lZWQgdG8gcm91bmQgdG8gYXZvaWQgbm9uc2Vuc2ljYWwgdmFsdWVzIGxpa2UgJzdmLjgnIGZvciBhIDAuNSBhbHBoYVxuICAgIHJldHVybiBwYWRkZWRIZXgoTWF0aC5yb3VuZCh0aGlzLmFscGhhICogMjU1LjApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyBhbnkgYWxwaGEgdmFsdWUuIFRvIGJlIHVzZWQgaW50ZXJuYWxseSwgbm90IGV4dGVybmFsIGFwaS4gRG9lcyBub3QgcHJvdmlkZSBsZWFkaW5nICcjJyBzeW1ib2wuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBfdG9SR0JIZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3BhZGRlZEhleCh0aGlzLnIpfSR7cGFkZGVkSGV4KHRoaXMuZyl9JHtwYWRkZWRIZXgodGhpcy5iKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgQ1NTLlxuICAgKiBDb252ZXJ0cyB0aGlzIGNvbG9yIHRvIGEgaGV4IHN0cmluZyB3aXRoIGxlYWRpbmcgJyMnIHN5bWJvbCBhbmQgNi0gb3IgOC1cbiAgICogaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoZGVwZW5kaW5nIG9uIGlmIGFscGhhIGlzIDEuMClcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvUkdCQUhleFN0cmluZygpIHtcbiAgICBpZiAodGhpcy5pc09wYXF1ZSgpKSB7XG4gICAgICByZXR1cm4gYCMke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAjJHt0aGlzLl90b1JHQkhleFN0cmluZygpfSR7dGhpcy5hbHBoYUhleCgpfWA7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBBbmRyb2lkL2lPU1xuICAgKiBDb252ZXJ0cyB0aGlzIGNvbG9yIHRvIGEgaGV4IHN0cmluZyB3aXRoIGxlYWRpbmcgJyMnIHN5bWJvbCBhbmQgNi0gb3IgOC1cbiAgICogaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoZGVwZW5kaW5nIG9uIGlmIGFscGhhIGlzIDEuMCkuIEFscGhhIGlzIHRoZSBmaXJzdCBlbnRyeSAoaWYgdGhlcmUgaXMgYWxwaGEuKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9BUkdCSGV4U3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmlzT3BhcXVlKCkpIHtcbiAgICAgIHJldHVybiBgIyR7dGhpcy5fdG9SR0JIZXhTdHJpbmcoKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCMke3RoaXMuYWxwaGFIZXgoKX0ke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgY29tbW9uYWxpdHkgd2l0aCBuYXRpdmUgaU9TIFRpQ29sb3IgcHJveHkuIFByb2R1Y2VzIGFuIEFBUlJHR0JCIChvciBSUkdHQkIgaWYgZnVsbCBhbHBoYSkgaGV4IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9IZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BUkdCSGV4U3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBjb2xvciB0byBhbiByZ2JhIGV4cHJlc3Npb24uIFRoaXMgZXhwcmVzc2lvbiBpcyBtb3JlIGNvbnNpc3RlbnQgYWNyb3NzIHBsYXRmb3Jtcy5cbiAgICogKHdoZXJlYXMgaU9TL0FuZHJvaWQgZGlmZmVyIGluIGV4cGVjdGF0aW9ucyBmb3IgaGV4IHN0cmluZ3MuKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgdG9SR0JBU3RyaW5nKCkge1xuICAgIHJldHVybiBgcmdiYSgke3RoaXMucn0sICR7dGhpcy5nfSwgJHt0aGlzLmJ9LCAke3RoaXMuYWxwaGEudG9GaXhlZCgzKX0pYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Q29sb3J9XG4gICAqL1xuICBzdGF0aWMgZmFsbGJhY2soKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwKTsgLy8gcmV0dXJuIGJsYWNrIHRvIG1hdGNoIG5hdGl2ZSBpbXBsIGluIGlPU1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdXBwbGllZCBoZXggc3RyaW5nIE1VU1QgYmUgaW4gZm9ybSAnIzAwMDAwMCcgKGkuZS4gbGVhZGluZyBwb3VuZCBzeW1ib2wsIDYgaGV4IGNoYXJhY3RlcnMgYWZ0ZXIpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgY29sb3Igc3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGFdIGFscGhhIHZhbHVlXG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICovXG4gIHN0YXRpYyBmcm9tSGV4NlN0cmluZyhoZXgsIGFscGhhKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGhleC5zdGFydHNXaXRoKCcjJykgPyAxIDogMDtcbiAgICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnN1YnN0cihzdGFydEluZGV4LCAyKSwgMTYpO1xuICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyAyLCAyKSwgMTYpO1xuICAgIGNvbnN0IGIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA0LCAyKSwgMTYpO1xuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYWxwaGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdXBwbGllZCBoZXggc3RyaW5nIE1VU1QgYmUgaW4gZm9ybSAnIzAwMDAwMDAwJyAoaS5lLiBsZWFkaW5nIHBvdW5kIHN5bWJvbCwgOCBoZXggY2hhcmFjdGVycyBhZnRlcilcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhleCBoZXhhZGVjaW1hbCBjb2xvciBzdHJpbmdcbiAgICogQHJldHVybnMge0NvbG9yfVxuICAgKi9cbiAgc3RhdGljIGZyb21IZXg4U3RyaW5nKGhleCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBoZXguc3RhcnRzV2l0aCgnIycpID8gMSA6IDA7XG4gICAgY29uc3QgYWxwaGEgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXgsIDIpLCAxNik7IC8vIGFscGhhIGlzIG5vdyAwLTI1NVxuICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyAyLCAyKSwgMTYpO1xuICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA0LCAyKSwgMTYpO1xuICAgIGNvbnN0IGIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA2LCAyKSwgMTYpO1xuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYWxwaGEgLyAyNTUuMCk7IC8vIGNvbnZlcnQgdG8gMC4wLTEuMCAocGVyY2VudClcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlIHRoYXQgdGhlIGhleCB2YWx1ZSBjYW4gY29udGFpbiBhbHBoYSwgYnV0IG11c3QgZm9sbG93IHRoZSBDU1Mgc3RhbmRhcmQgb2YgI1JSR0dCQkFBIChOT1QgdGhlIEFuZHJvaWQgc3RhbmRhcmQgb2YgI0FBUlJHR0JCKVxuICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGVudHJ5IHBvc3NpYmxlIGhleCBzdHJpbmcgb3IgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2hleC5hbHBoYV0gYWxwaGEgdmFsdWUgaW4gcGVyY2VudCAoMC4wLTEwMC4wKSB3aGVuIGhleCBpcyBhbiBvYmplY3RcbiAgXHQgKiBAcGFyYW0ge3N0cmluZ30gW2hleC5jb2xvcl0gaGV4IHN0cmluZyBmb3IgdGhlIGJhc2UgY29sb3Igd2hlbiBoZXggaXMgYW4gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICogQHRocm93cyBpZiBlbnRyeSBoYXMgYm90aCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYW4gYWxwaGEgdmFsdWVcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VtYW50aWNDb2xvcnNFbnRyeShlbnRyeSkge1xuICAgIGxldCBjb2xvciA9IGVudHJ5O1xuICAgIGxldCBhbHBoYSA9IDEuMDtcbiAgICBsZXQgaGFkQWxwaGEgPSBmYWxzZTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudHJ5LCAnYWxwaGEnKSkge1xuICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGVudHJ5LmFscGhhKSAvIDEwMC4wOyAvLyBjb252ZXJ0IGZyb20gMC0xMDAgcmFuZ2UgdG8gMC0xIHJhbmdlXG4gICAgICBoYWRBbHBoYSA9IHRydWU7XG4gICAgICBjb2xvciA9IGVudHJ5LmNvbG9yOyAvLyBpZiBpdCBoYXMgYW4gYWxwaGEgcHJvcGVydHkgYXNzdW1lIGl0IGhhcyBhIGNvbG9yIHByb3BlcnR5IHRvbyFcbiAgICB9XG5cbiAgICAvLyBleHBhbmQgdGhlIHNob3J0ZXIgaGV4IHN0cmluZyBmb3JtcyB0byA2IG9yIDggZGlnaXRzXG4gICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKEhFWF8zX1JFR0VYLCAobSwgciwgZywgYikgPT4gciArIHIgKyBnICsgZyArIGIgKyBiKTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGOFwiKSB0byBmdWxsIGZvcm0gKGUuZy4gXCIwMDMzRkY4OFwiKVxuICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKEhFWF80X1JFR0VYLCAobSwgYSwgciwgZywgYikgPT4gYSArIGEgKyByICsgciArIGcgKyBnICsgYiArIGIpO1xuICAgIH1cbiAgICBpZiAoSEVYXzZfUkVHRVguZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4NlN0cmluZyhjb2xvciwgYWxwaGEpO1xuICAgIH1cbiAgICBpZiAoSEVYXzhfUkVHRVguZXhlYyhjb2xvcikpIHtcbiAgICAgIGlmIChoYWRBbHBoYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbG9yICR7ZW50cnl9IGhhZCBhbiBleHBsaWNpdCBhbHBoYSB2YWx1ZSBBTkQgYSBoZXggdmFsdWUgY29udGFpbmluZyBhbHBoYS4gVXNlIG9uZSBvciB0aGUgb3RoZXIuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29sb3IuZnJvbUhleDhTdHJpbmcoY29sb3IpO1xuICAgIH1cbiAgICAvLyB1aC1vaCwgc29tZXRoaW5nIGlzIHVwIVxuICAgIHJldHVybiBDb2xvci5mYWxsYmFjaygpO1xuICB9XG59XG52YXIgY29sb3IgPSBDb2xvcjtcblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8vIEFzIEFuZHJvaWQgcGFzc2VzIGEgbmV3IGluc3RhbmNlIG9mIFRpLlVJIHRvIGV2ZXJ5IEpTIGZpbGUgd2UgY2FuJ3QganVzdFxuLy8gVGkuVUkgd2l0aGluIHRoaXMgZmlsZSwgd2UgbXVzdCBjYWxsIGtyb2xsLmJpbmRpbmcgdG8gZ2V0IHRoZSBUaXRhbml1bVxuLy8gbmFtZXNwYWNlIHRoYXQgaXMgcGFzc2VkIGluIHdpdGggcmVxdWlyZSBhbmQgdGhhdCBkZWFsIHdpdGggdGhlIC5VSVxuLy8gbmFtZXNwYWNlIHRoYXQgaXMgb24gdGhhdCBkaXJlY3RseS5cbmNvbnN0IFVJID0ga3JvbGwuYmluZGluZygnVGl0YW5pdW0nKS5UaXRhbml1bS5VSSA7XG5cbi8vIE1ha2Ugb3VyIHJlYWQtb25seSBjb25zdGFudHNcbi8vIFRPRE86IFJlbW92ZSBpbiBTREsgMTAsIERFUFJFQ0FURUQgaW4gOS4xLjBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVSSwgJ1NFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQnLCB7XG4gIHZhbHVlOiAnbGlnaHQnLFxuICB3cml0YWJsZTogZmFsc2Vcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnU0VNQU5USUNfQ09MT1JfVFlQRV9EQVJLJywge1xuICB2YWx1ZTogJ2RhcmsnLFxuICB3cml0YWJsZTogZmFsc2Vcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnc2VtYW50aWNDb2xvclR5cGUnLCB7XG4gIGdldDogKCkgPT4ge1xuICAgIC8vIFRPRE86IEd1YXJkIGFnYWluc3QgaW9zIDwgMTMgYW5kIEFuZHJvaWQgYXBpIDwgMjk/XG4gICAgLy8gQXNzdW1lIFwibGlnaHRcIiBtb2RlIHVubGVzcyB3ZSBleHBsaWNpdGx5IGtub3cgaXQncyBkYXJrXG4gICAgaWYgKFRpLlVJLnVzZXJJbnRlcmZhY2VTdHlsZSA9PT0gVGkuVUkuVVNFUl9JTlRFUkZBQ0VfU1RZTEVfREFSSykge1xuICAgICAgcmV0dXJuIFVJLlNFTUFOVElDX0NPTE9SX1RZUEVfREFSSztcbiAgICB9XG4gICAgcmV0dXJuIFVJLlNFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQ7XG4gIH1cbn0pO1xuXG4vLyBvbiBBbmRyb2lkL2lPUyA8IDEzLCB3ZSBuZWVkIHRvIHJvbGwgb3VyIG93biBmZXRjaFNlbWFudGljQ29sb3IgaW1wbFxuLy8gb24gaU9TIDEzKywgd2UgaGF2ZSBhIG5hdGl2ZSB2ZXJzaW9uXG57XG4gIGxldCBjb2xvcnNldDtcbiAgVUkuZmV0Y2hTZW1hbnRpY0NvbG9yID0gZnVuY3Rpb24gZmV0Y2hTZW1hbnRpY0NvbG9yKGNvbG9yTmFtZSkge1xuICAgIC8vIExvYWQgYWxsIHNlbWFudGljIGNvbG9ycyBmcm9tIEpTT04gaWYgbm90IGRvbmUgYWxyZWFkeS5cbiAgICAvLyBEbyBzbyB2aWEgcmVxdWlyZSgpIGluIGNhc2UgdGhpcyBmaWxlIHdhcyBjaGFuZ2VkIHdoaWxlIHJ1bm5pbmcgTGl2ZVZpZXcuXG4gICAgaWYgKCFjb2xvcnNldCkge1xuICAgICAgY29uc3QgY29sb3JzZXRGaWxlTmFtZSA9ICdzZW1hbnRpYy5jb2xvcnMuanNvbic7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb2xvcnNldEZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksIGNvbG9yc2V0RmlsZU5hbWUpO1xuICAgICAgICBpZiAoY29sb3JzZXRGaWxlLmV4aXN0cygpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG4gICAgICAgICAgY29sb3JzZXQgPSByZXF1aXJlKGAvJHtjb2xvcnNldEZpbGVOYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBjb2xvcnMgZmlsZSAnJHtjb2xvcnNldEZpbGVOYW1lfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yLmZhbGxiYWNrKCkudG9IZXgoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgIC8vIE9uIEFuZHJvaWQsIHVzZSBjdXN0b20gc3RyaW5nIHJlZmVyZW5jZXMgdG8gYmUgaGFuZGxlZCBieSBcIlRpQ29sb3JIZWxwZXIuamF2YVwiLlxuICAgICAgICBpZiAoY29sb3JzZXRbY29sb3JOYW1lXSkge1xuICAgICAgICAgIC8vIEFkZCBhbGwgdGhlbWUgY29sb3JzIHRvIGEgc2luZ2xlIHN0cmluZy5cbiAgICAgICAgICAvLyBFeGFtcGxlOiBcInRpLnNlbWFudGljLmNvbG9yOmRhcms9PENvbG9yU3RyaW5nPjtsaWdodD08Q29sb3JTdHJpbmc+XCJcbiAgICAgICAgICBjb25zdCBjb2xvckFycmF5ID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBjb2xvclR5cGUgaW4gY29sb3JzZXRbY29sb3JOYW1lXSkge1xuICAgICAgICAgICAgY29uc3QgY29sb3JPYmogPSBjb2xvci5mcm9tU2VtYW50aWNDb2xvcnNFbnRyeShjb2xvcnNldFtjb2xvck5hbWVdW2NvbG9yVHlwZV0pO1xuICAgICAgICAgICAgY29sb3JBcnJheS5wdXNoKGAke2NvbG9yVHlwZX09JHtjb2xvck9iai50b1JHQkFTdHJpbmcoKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICd0aS5zZW1hbnRpYy5jb2xvcjonICsgY29sb3JBcnJheS5qb2luKCc7Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoVGkuQW5kcm9pZC5SLmNvbG9yW2NvbG9yTmFtZV0pIHtcbiAgICAgICAgICAvLyBXZSdyZSByZWZlcmVuY2luZyBhIG5hdGl2ZSBcInJlc1wiIGNvbG9yIGVudHJ5LlxuICAgICAgICAgIHJldHVybiBgQGNvbG9yLyR7Y29sb3JOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvb2t1cCBjb2xvciBmb3IgJHtjb2xvck5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBjb2xvci5mYWxsYmFjaygpLnRvSGV4KCk7XG4gIH07XG59XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuLyogZ2xvYmFscyBPU19BTkRST0lELCBPU19JT1MgKi9cbntcbiAgY29uc3QgVGFiID0gVGl0YW5pdW0uVUkuVGFiO1xuICBmdW5jdGlvbiBjcmVhdGVUYWIob3B0aW9ucykge1xuICAgIGNvbnN0IHRhYiA9IG5ldyBUYWIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRhYi5fd2luZG93ID0gb3B0aW9ucy53aW5kb3c7XG4gICAgfVxuICAgIHJldHVybiB0YWI7XG4gIH1cbiAgVGl0YW5pdW0uVUkuY3JlYXRlVGFiID0gY3JlYXRlVGFiO1xuICBUYWIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAod2luZG93LCBvcHRpb25zKSB7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gV2hlbiB3ZSBvcGVuIGEgd2luZG93IHVzaW5nIHRhYi5vcGVuKHdpbiksIHdlIHRyZWF0IGl0IGFzXG4gICAgLy8gb3BlbmluZyBhIEhXIHdpbmRvdyBvbiB0b3Agb2YgdGhlIHRhYi5cbiAgICBvcHRpb25zLnRhYk9wZW4gPSB0cnVlO1xuICAgIHdpbmRvdy5vcGVuKG9wdGlvbnMpO1xuICB9O1xuICBUYWIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aW5kb3cgPSB0aGlzLmdldFdpbmRvdygpO1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5jbG9zZShvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0V2luZG93KG51bGwpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgX3NldFdpbmRvdyA9IFRhYi5wcm90b3R5cGUuc2V0V2luZG93O1xuICBUYWIucHJvdG90eXBlLnNldFdpbmRvdyA9IGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3c7XG4gICAgX3NldFdpbmRvdy5jYWxsKHRoaXMsIHdpbmRvdyk7XG4gIH07XG5cbiAgLy8gVE9ETzogUmVtb3ZlISBUaGlzIGlzIGFuIHVuZG9jdW1lbnRlZCBhY2Nlc3NvciBtZXRob2RcbiAgVGFiLnByb3RvdHlwZS5nZXRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvdztcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYi5wcm90b3R5cGUsICd3aW5kb3cnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IFRhYi5wcm90b3R5cGUuc2V0V2luZG93LFxuICAgIGdldDogVGFiLnByb3RvdHlwZS5nZXRXaW5kb3dcbiAgfSk7XG59XG5cbi8qKlxuICogVGl0YW5pdW0gU0RLXG4gKiBDb3B5cmlnaHQgVGlEZXYsIEluYy4gMDQvMDcvMjAyMi1QcmVzZW50LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG5cbntcbiAgY29uc3QgVGFiR3JvdXAgPSBUaXRhbml1bS5VSS5UYWJHcm91cDtcblxuICAvLyBBdm9pZCBjaXJjdWxhciBsb29wcyBpbiB0b0pTT04oKVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFiR3JvdXAucHJvdG90eXBlLCAndG9KU09OJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgICBjb25zdCBrZXlDb3VudCA9IGtleXMubGVuZ3RoO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoayA9PT0gJ2FjdGl2aXR5JyB8fCBrLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplZFtrXSA9IHRoaXNba107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGl0YW5pdW0uVUkuVGFiLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgICAgY29uc3Qga2V5Q291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGsgPT09ICd3aW5kb3cnIHx8IGsgPT09ICd0YWJHcm91cCcgfHwgay5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlcmlhbGl6ZWRba10gPSB0aGlzW2tdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cblxue1xuICBjb25zdCBWaWV3ID0gVGl0YW5pdW0uVUkuVmlldztcbiAgY29uc3QgX2FkZCA9IFZpZXcucHJvdG90eXBlLmFkZDtcbiAgVmlldy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGl0YW5pdW0uVGlXaW5kb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCB3aW5kb3cvdGFiR3JvdXAgdG8gYSB2aWV3LicpO1xuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuIHx8IFtdO1xuICAgIF9hZGQuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGhhdmUgdG8gYmUgcmV0YWluZWQgYnkgdGhlIHZpZXcgaW4gdGhlIEphdmFzY3JpcHQgc2lkZVxuICAgIC8vIGluIG9yZGVyIHRvIGxldCBWOCBrbm93IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBjaGlsZHJlbiBhbmQgdGhlIHZpZXcuXG4gICAgLy8gVGhlcmVmb3JlLCBhcyBsb25nIGFzIGl0cyB3aW5kb3cgaXMgb3BlbiwgYWxsIGl0cyBjaGlsZHJlbiB3b24ndCBiZSBkZXRhY2hlZFxuICAgIC8vIG9yIGdhcmJhZ2UgY29sbGVjdGVkIGFuZCBWOCB3aWxsIHJlY29nYW5pemUgdGhlIGNsb3N1cmVzIGFuZCByZXRhaW4gYWxsXG4gICAgLy8gdGhlIHJlbGF0ZWQgcHJveGllcy5cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgfTtcbiAgY29uc3QgX3JlbW92ZSA9IFZpZXcucHJvdG90eXBlLnJlbW92ZTtcbiAgVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgX3JlbW92ZS5jYWxsKHRoaXMsIGNoaWxkKTtcblxuICAgIC8vIFJlbW92ZSB0aGUgY2hpbGQgaW4gdGhlIEphdmFzY3JpcHQgc2lkZSBzbyBpdCBjYW4gYmUgZGV0YWNoZWQgYW5kIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4gfHwgW107XG4gICAgY29uc3QgY2hpbGRJbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChjaGlsZEluZGV4ICE9PSAtMSkge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEbyBub3Qgc2VyaWFsaXplIHRoZSBwYXJlbnQgdmlldy4gRG9pbmcgc28gd2lsbCByZXN1bHRcbiAgLy8gaW4gYSBjaXJjdWxhciByZWZlcmVuY2UgbG9vcC5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpdGFuaXVtLlRpVmlldy5wcm90b3R5cGUsICd0b0pTT04nLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICAgIGNvbnN0IGtleUNvdW50ID0ga2V5cy5sZW5ndGg7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgICAgIGlmIChrID09PSAncGFyZW50JyB8fCBrLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VyaWFsaXplZFtrXSA9IHRoaXNba107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cbntcbiAgY29uc3QgY3JlYXRlV2ViVmlldyA9IFRpdGFuaXVtLlVJLmNyZWF0ZVdlYlZpZXc7XG4gIGZ1bmN0aW9uIGNyZWF0ZVdlYlZpZXdXcmFwcGVyKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3ZWJWaWV3ID0gY3JlYXRlV2ViVmlldy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB3ZWJWaWV3Lm9uQ3JlYXRlV2luZG93ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZS5pc1VzZXJHZXN0dXJlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2luID0gVGl0YW5pdW0uVUkuY3JlYXRlV2luZG93KHt9LCB7XG4gICAgICAgIGZ1bGxzY3JlZW46IGZhbHNlIC8vIEZvcmNlIG5ldyBhY3Rpdml0eS5cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBuZXdXZWJWaWV3ID0gVGl0YW5pdW0uVUkuY3JlYXRlV2ViVmlldygpO1xuICAgICAgd2luLmFkZChuZXdXZWJWaWV3KTtcbiAgICAgIHdpbi5vcGVuKCk7XG4gICAgICByZXR1cm4gbmV3V2ViVmlldztcbiAgICB9O1xuICAgIHJldHVybiB3ZWJWaWV3O1xuICB9XG4gIFRpdGFuaXVtLlVJLmNyZWF0ZVdlYlZpZXcgPSBjcmVhdGVXZWJWaWV3V3JhcHBlcjtcbn1cblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG57XG4gIGNvbnN0IFRBRyA9ICdXaW5kb3cnO1xuICBjb25zdCBTY3JpcHQgPSBrcm9sbC5iaW5kaW5nKCdldmFscycpLlNjcmlwdDsgLy8gQW5kcm9pZC1zcGVjaWZpYyB3YXkgdG8gZ3JhYiBiaW5kaW5nLCBoYW5ncyBvZmYgJ3NjcmlwdCcgb24gaU9TXG4gIGNvbnN0IFdpbmRvdyA9IFRpdGFuaXVtLlVJLldpbmRvdztcbiAgV2luZG93LnByb3RvdHlwZS5fY2FjaGVkQWN0aXZpdHlQcm94eSA9IG51bGw7XG4gIGZ1bmN0aW9uIGNyZWF0ZVdpbmRvdyhvcHRpb25zKSB7XG4gICAgY29uc3Qgd2luZG93ID0gbmV3IFdpbmRvdyhvcHRpb25zKTtcbiAgICB3aW5kb3cuX2NoaWxkcmVuID0gW107XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBUaXRhbml1bS5VSS5jcmVhdGVXaW5kb3cgPSBjcmVhdGVXaW5kb3c7XG5cbiAgLy8gQWN0aXZpdHkgZ2V0dGVyIChhY2NvdW50IGZvciBzY2VuYXJpbyB3aGVuIGhlYXZ5IHdlaWdodCB3aW5kb3cncyBhY3Rpdml0eSBpcyBub3QgY3JlYXRlZCB5ZXQpXG4gIGZ1bmN0aW9uIGFjdGl2aXR5UHJveHlHZXR0ZXIoKSB7XG4gICAgY29uc3QgYWN0aXZpdHlQcm94eSA9IHRoaXMuX2dldFdpbmRvd0FjdGl2aXR5UHJveHkoKTtcbiAgICBpZiAoYWN0aXZpdHlQcm94eSkge1xuICAgICAgcmV0dXJuIGFjdGl2aXR5UHJveHk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRBY3Rpdml0eVByb3h5ID09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEFjdGl2aXR5UHJveHk7XG4gIH1cbiAgV2luZG93LnByb3RvdHlwZS5nZXRBY3Rpdml0eSA9IGFjdGl2aXR5UHJveHlHZXR0ZXI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaW5kb3cucHJvdG90eXBlLCAnYWN0aXZpdHknLCB7XG4gICAgZ2V0OiBhY3Rpdml0eVByb3h5R2V0dGVyXG4gIH0pO1xuICBjb25zdCBfb3BlbiA9IFdpbmRvdy5wcm90b3R5cGUub3BlbjtcbiAgV2luZG93LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAvLyBSZXRhaW4gdGhlIHdpbmRvdyB1bnRpbCBpdCBoYXMgY2xvc2VkLlxuICAgIGNvbnN0IGhhbmRsZSA9IG5ldyBQZXJzaXN0ZW50SGFuZGxlKHRoaXMpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUuX2Nsb3NlRnJvbUFjdGl2aXR5Rm9yY2VkVG9EZXN0cm95KSB7XG4gICAgICAgIGlmIChrcm9sbC5EQkcpIHtcbiAgICAgICAgICBrcm9sbC5sb2coVEFHLCAnV2luZG93IGlzIGNsb3NlZCBiZWNhdXNlIHRoZSBhY3Rpdml0eSBpcyBmb3JjZWQgdG8gZGVzdHJveSBieSBBbmRyb2lkIE9TLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzcG9zZSB0aGUgVVJMIGNvbnRleHQgaWYgdGhlIHdpbmRvdydzIGFjdGl2aXR5IGlzIGRlc3Ryb3llZC5cbiAgICAgIGlmIChzZWxmLl91cmxDb250ZXh0KSB7XG4gICAgICAgIFNjcmlwdC5kaXNwb3NlQ29udGV4dChzZWxmLl91cmxDb250ZXh0KTtcbiAgICAgICAgc2VsZi5fdXJsQ29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBoYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgaWYgKGtyb2xsLkRCRykge1xuICAgICAgICBrcm9sbC5sb2coVEFHLCAnV2luZG93IGlzIGNsb3NlZCBub3JtYWxseS4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX29wZW4uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgfTtcbiAgY29uc3QgX2FkZCA9IFdpbmRvdy5wcm90b3R5cGUuYWRkO1xuICBXaW5kb3cucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRpdGFuaXVtLlRpV2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgd2luZG93L3RhYkdyb3VwIHRvIGFub3RoZXIgd2luZG93L3RhYkdyb3VwLicpO1xuICAgIH1cbiAgICBfYWRkLmNhbGwodGhpcywgY2hpbGQpO1xuXG4gICAgLy8gVGhlIGNoaWxkcmVuIGhhdmUgdG8gYmUgcmV0YWluZWQgYnkgdGhlIHdpbmRvdyBpbiB0aGUgSmF2YXNjcmlwdCBzaWRlXG4gICAgLy8gaW4gb3JkZXIgdG8gbGV0IFY4IGtub3cgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGNoaWxkcmVuIGFuZCB0aGUgd2luZG93LlxuICAgIC8vIFRoZXJlZm9yZSwgYXMgbG9uZyBhcyB0aGUgd2luZG93IGlzIG9wZW4sIGFsbCBpdHMgY2hpbGRyZW4gd29uJ3QgYmUgZGV0YWNoZWRcbiAgICAvLyBvciBnYXJiYWdlIGNvbGxlY3RlZCBhbmQgVjggd2lsbCByZWNvZ2FuaXplIHRoZSBjbG9zdXJlcyBhbmQgcmV0YWluIGFsbFxuICAgIC8vIHRoZSByZWxhdGVkIHByb3hpZXMuXG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIH07XG4gIGNvbnN0IF9yZW1vdmUgPSBXaW5kb3cucHJvdG90eXBlLnJlbW92ZTtcbiAgV2luZG93LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBfcmVtb3ZlLmNhbGwodGhpcywgY2hpbGQpO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBpbiB0aGUgSmF2YXNjcmlwdCBzaWRlIHNvIGl0IGNhbiBiZSBkZXRhY2hlZCBhbmQgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChjaGlsZEluZGV4ICE9PSAtMSkge1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoY2hpbGRJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBXaW5kb3cucHJvdG90eXBlLnBvc3RXaW5kb3dDcmVhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChrcm9sbC5EQkcpIHtcbiAgICAgIGtyb2xsLmxvZyhUQUcsICdDaGVja3BvaW50OiBwb3N0V2luZG93Q3JlYXRlZCgpJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZWRBY3Rpdml0eVByb3h5KSB7XG4gICAgICB0aGlzLl9pbnRlcm5hbEFjdGl2aXR5LmV4dGVuZCh0aGlzLl9jYWNoZWRBY3Rpdml0eVByb3h5KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgdGhlIEV2ZW50RW1pdHRlciBpbnN0YW5jZSB0byB1c2UgdG8gcmVnaXN0ZXIgZm9yIGl0J3MgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byByZWdpc3RlciBmb3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIHRoZSBsaXN0ZW5lciBjYWxsYmFjay9mdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICogQHBhcmFtIHtib29sZWFufSBwcmVwZW5kIHdoZXRoZXIgdG8gcHJlcGVuZCBvciBhcHBlbmQgdGhlIGxpc3RlbmVyXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICovXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnROYW1lLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTsgLy8gaW5pdGlhbGl6ZSBpdFxuICB9XG4gIC8vIGlmIHRoZXJlJ3Mgc29tZW9uZSBsaXN0ZW5pbmcgdG8gJ25ld0xpc3RlbmVyJyBldmVudHMsIGVtaXQgdGhhdCAqKmJlZm9yZSoqIHdlIGFkZCB0aGUgbGlzdGVuZXIgKHRvIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvbilcbiAgaWYgKGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzLm5ld0xpc3RlbmVyKSB7XG4gICAgZW1pdHRlci5lbWl0KCduZXdMaXN0ZW5lcicsIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIGNvbnN0IGV2ZW50TGlzdGVuZXJzID0gZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgaWYgKHByZXBlbmQpIHtcbiAgICBldmVudExpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuICBlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdID0gZXZlbnRMaXN0ZW5lcnM7XG5cbiAgLy8gQ2hlY2sgbWF4IGxpc3RlbmVycyBhbmQgc3BpdCBvdXQgd2FybmluZyBpZiA+XG4gIGNvbnN0IG1heCA9IGVtaXR0ZXIuZ2V0TWF4TGlzdGVuZXJzKCk7XG4gIGNvbnN0IGxlbmd0aCA9IGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcbiAgaWYgKG1heCA+IDAgJiYgbGVuZ3RoID4gbWF4KSB7XG4gICAgY29uc3QgdyA9IG5ldyBFcnJvcihgUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAke2xlbmd0aH0gJHtldmVudE5hbWV9IGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXRgKTtcbiAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICB3LmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHcudHlwZSA9IGV2ZW50TmFtZTtcbiAgICB3LmNvdW50ID0gbGVuZ3RoO1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcodyk7XG4gIH1cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5mdW5jdGlvbiBvbmNlV3JhcChlbWl0dGVyLCBldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgIHRoaXMuZW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcy53cmFwcGVkRnVuYyk7IC8vIHJlbW92ZSBvdXJzZWx2ZXNcbiAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMuZW1pdHRlciwgYXJncyk7IC8vIHRoZW4gZm9yd2FyZCB0aGUgZXZlbnQgY2FsbGJhY2tcbiAgfVxuICAvLyB3ZSBoYXZlIHRvIHVzZSBiaW5kIHdpdGggYSBjdXN0b20gJ3RoaXMnLCBiZWNhdXNlIGV2ZW50cyBmaXJlIHdpdGggJ3RoaXMnIHBvaW50aW5nIGF0IHRoZSBlbWl0dGVyXG4gIGNvbnN0IHdyYXBwZXJUaGlzID0ge1xuICAgIGVtaXR0ZXIsXG4gICAgZXZlbnROYW1lLFxuICAgIGxpc3RlbmVyXG4gIH07XG4gIGNvbnN0IGJvdW5kID0gd3JhcHBlci5iaW5kKHdyYXBwZXJUaGlzKTsgLy8gYmluZCB0byBmb3JjZSBcInRoaXNcIiB0byByZWZlciB0byBvdXIgY3VzdG9tIG9iamVjdCB0cmFja2luZyB0aGUgd3JhcHBlci9lbWl0dGVyL2xpc3RlbmVyXG4gIGJvdW5kLmxpc3RlbmVyID0gbGlzdGVuZXI7IC8vIGhhdmUgdG8gYWRkIGxpc3RlbmVyIHByb3BlcnR5IGZvciBcInVud3JhcHBpbmdcIlxuICB3cmFwcGVyVGhpcy53cmFwcGVkRnVuYyA9IGJvdW5kO1xuICByZXR1cm4gYm91bmQ7XG59XG5cbi8vIG1hbnkgY29uc3VtZXJzIG1ha2UgdXNlIG9mIHRoaXMgdmlhIHV0aWwuaW5oZXJpdHMsIHdoaWNoIGRvZXMgbm90IGNoYWluIGNvbnN0cnVjdG9yIGNhbGxzIVxuLy8gc28gd2UgbmVlZCB0byBiZSBhd2FyZSB0aGF0IF9ldmVudHNUb0xpc3RlbmVycyBtYXllIGJlIG51bGwvdW5kZWZpbmVkIG9uIGluc3RhbmNlcywgYW5kIGNoZWNrIGluIG1ldGhvZHMgYmVmb3JlIGFjY2Vzc2luZyBpdFxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9XG4gIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICBwcmVwZW5kTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gIH1cbiAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5vbihldmVudE5hbWUsIG9uY2VXcmFwKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpKTtcbiAgfVxuICBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIG9uY2VXcmFwKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpKTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xO1xuICAgIGxldCB1bndyYXBwZWRMaXN0ZW5lcjtcbiAgICAvLyBOZWVkIHRvIHNlYXJjaCBMSUZPLCBhbmQgbmVlZCB0byBoYW5kbGUgd3JhcHBlZCBmdW5jdGlvbnMgKG9uY2Ugd3JhcHBlcnMpXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoZXZlbnRMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyIHx8IGV2ZW50TGlzdGVuZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgdW53cmFwcGVkTGlzdGVuZXIgPSBldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBsZW5ndGggd2FzIDEgYW5kIHdlIHdhbnQgdG8gcmVtb3ZlIGxhc3QgZW50cnksIHNvIGRlbGV0ZSB0aGUgZXZlbnQgdHlwZSBmcm9tIG91ciBsaXN0ZW5lciBtYXBwaW5nIG5vdyFcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBoYWQgMisgbGlzdGVuZXJzLCBzbyBzdG9yZSBhcnJheSB3aXRob3V0IHRoaXMgZ2l2ZW4gbGlzdGVuZXJcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGZvdW5kSW5kZXgsIDEpOyAvLyBtb2RpZmllcyBpbiBwbGFjZSwgbm8gbmVlZCB0byBhc3NpZ24gdG8gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgZW1pdCBpZiB0aGVyZSdzIG5vIGxpc3RlbmVycyBmb3IgJ3JlbW92ZUxpc3RlbmVyJyB0eXBlIVxuICAgICAgaWYgKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCBldmVudE5hbWUsIHVud3JhcHBlZExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBldmVudExpc3RlbmVycy5zbGljZSgpKSB7XG4gICAgICAvLyBtdXN0IG9wZXJhdGUgb24gY29weSBiZWNhdXNlIGxpc3RlbmVycyAsYXkgZ2V0IHJlbW92ZSBhcyBzaWRlLWVmZmVjdCBvZiBjYWxsaW5nXG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoICE9PSAwO1xuICB9XG4gIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHJldHVybiBldmVudExpc3RlbmVycy5sZW5ndGg7XG4gIH1cbiAgZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgfHwge30pO1xuICB9XG4gIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gTmVlZCB0byBcInVud3JhcFwiIG9uY2Ugd3JhcHBlcnMhXG4gICAgY29uc3QgcmF3ID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICByZXR1cm4gcmF3Lm1hcChsID0+IGwubGlzdGVuZXIgfHwgbCk7IC8vIGhlcmUgd2UgdW53cmFwIHRoZSBvbmNlIHdyYXBwZXIgaWYgdGhlcmUgaXMgb25lIG9yIGZhbGwgYmFjayB0byBsaXN0ZW5lciBmdW5jdGlvblxuICB9XG5cbiAgcmF3TGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW10pLnNsaWNlKDApOyAvLyByZXR1cm4gYSBjb3B5XG4gIH1cblxuICBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heExpc3RlbmVycyB8fCBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgfVxuICBzZXRNYXhMaXN0ZW5lcnMobikge1xuICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47IC8vIFRPRE86IFR5cGUgY2hlY2sgbiwgbWFrZSBzdXJlID49IDAgKG8gZXF1YWxzIG5vIGxpbWl0KVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKSB7XG4gICAgICAvLyBubyBldmVudHMvbGlzdGVuZXJzIHJlZ2lzdGVyZWRcbiAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307IC8vIGluaXRpYWxpemUgaXRcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGVtaXQhIHdlIGNhbiBqdXN0IHdpcGUhXG4gICAgICBpZiAoZXZlbnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZXJ5IHR5cGUhXG4gICAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgc3BlY2lmaWMgdHlwZVxuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHl1Y2ssIHdlJ2xsIGhhdmUgdG8gZW1pdCAncmVtb3ZlTGlzdGVuZXInIGV2ZW50cyBhcyB3ZSBnb1xuICAgIGlmIChldmVudE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gUmVtb3ZlIGFsbCB0eXBlcyAoYnV0IGRvICdyZW1vdmVMaXN0ZW5lcicgbGFzdCEpXG4gICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzKS5maWx0ZXIobmFtZSA9PiBuYW1lICE9PSAncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgIG5hbWVzLmZvckVhY2gobmFtZSA9PiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhuYW1lKSk7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lcnMgZm9yIG9uZSB0eXBlLCBiYWNrIHRvIGZyb250IChMYXN0LWluLCBmaXJzdC1vdXQsIGV4Y2VwdCB3aGVyZSBwcmVwZW5kIGYtZWQgaXQgdXApXG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCBldmVudE5hbWUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xufTtcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8qKlxuICogQHBhcmFtICB7Kn0gYXJnIHBhc3NlZCBpbiBhcmd1bWVudCB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVuYW1lIGkuZS4gJ3N0cmluZycsICdGdW5jdGlvbicgKHZhbHVlIGlzIGNvbXBhcmVkIHRvIHR5cGVvZiBhZnRlciBsb3dlcmNhc2luZylcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50VHlwZShhcmcsIG5hbWUsIHR5cGVuYW1lKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSAhPT0gdHlwZW5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgJHt0eXBlbmFtZX0uIFJlY2VpdmVkIHR5cGUgJHt0eXBlfWApO1xuICB9XG59XG5cbi8vIFN0YXJ0IG91ciBwcm9jZXNzIHVwdGltZSB0aW1lciBpbW1lZGlhdGVseSFcbmNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiAnc3RhbmRhcmRpemVzJyB0aGUgcmVwb3J0ZWQgYXJjaGl0ZWN0dXJlcyB0byB0aGUgZXF1aXZhbGVudHMgcmVwb3J0ZWQgYnkgTm9kZS5qc1xuICogbm9kZSB2YWx1ZXM6ICdhcm0nLCAnYXJtNjQnLCAnaWEzMicsICdtaXBzJywgJ21pcHNlbCcsICdwcGMnLCAncHBjNjQnLCAnczM5MCcsICdzMzkweCcsICd4MzInLCBhbmQgJ3g2NCcuXG4gKiBpT1MgdmFsdWVzOiBcImFybTY0XCIsIFwiYXJtdjdcIiwgXCJ4ODZfNjRcIiwgXCJpMzg2XCIsIFwiVW5rbm93blwiXG4gKiBBbmRyb2lkIHZhbHVlczogXCJhcm1lYWJpXCIsIFwiYXJtZWFiaS12N2FcIiwgXCJhcm02NC12OGFcIiwgXCJ4ODZcIiwgXCJ4ODZfNjRcIiwgXCJtaXBzXCIsIFwibWlwczY0XCIsIFwidW5rbm93blwiXG4gKiBXaW5kb3dzIHZhbHVlczogXCJ4NjRcIiwgXCJpYTY0XCIsIFwiQVJNXCIsIFwieDg2XCIsIFwidW5rbm93blwiXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWwgb3JpZ2luYWwgYXJjaGl0ZWN0dXJlIHJlcG9ydGVkIGJ5IFRpLlBsYXRmb3JtXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZUFyY2gob3JpZ2luYWwpIHtcbiAgc3dpdGNoIChvcmlnaW5hbCkge1xuICAgIC8vIGNvZXJjZSAnYXJtdjcnLCAnYXJtZWFiaScsICdhcm1lYWJpLXY3YScsICdBUk0nIC0+ICdhcm0nXG4gICAgLy8gJ2FybWVhYmknIGlzIGEgZGVhZCBBQkkgZm9yIEFuZHJvaWQsIHJlbW92ZWQgaW4gTkRLIHIxN1xuICAgIGNhc2UgJ2FybXY3JzpcbiAgICBjYXNlICdhcm1lYWJpJzpcbiAgICBjYXNlICdhcm1lYWJpLXY3YSc6XG4gICAgY2FzZSAnQVJNJzpcbiAgICAgIHJldHVybiAnYXJtJztcblxuICAgIC8vIGNvZXJjZSAnYXJtNjQtdjhhJyAtPiAnYXJtNjQnXG4gICAgY2FzZSAnYXJtNjQtdjhhJzpcbiAgICAgIHJldHVybiAnYXJtNjQnO1xuXG4gICAgLy8gY29lcmNlICdpMzg2JywgJ3g4NicgLT4gJ2lhMzInXG4gICAgY2FzZSAnaTM4Nic6XG4gICAgY2FzZSAneDg2JzpcbiAgICAgIHJldHVybiAnaWEzMic7XG5cbiAgICAvLyBjb2VyY2UgJ3g4Nl82NCcsICdpYTY0JywgJ3g2NCcgLT4gJ3g2NCdcbiAgICBjYXNlICd4ODZfNjQnOlxuICAgIGNhc2UgJ2lhNjQnOlxuICAgICAgcmV0dXJuICd4NjQnO1xuXG4gICAgLy8gY29lcmNlICdtaXBzNjQnIC0+ICdtaXBzJyAvLyAnbWlwcycgYW5kICdtaXBzNjQnIGFyZSBkZWFkIEFCSXMgZm9yIEFuZHJvaWQsIHJlbW92ZWQgaW4gTkRLIHIxN1xuICAgIGNhc2UgJ21pcHM2NCc6XG4gICAgICByZXR1cm4gJ21pcHMnO1xuXG4gICAgLy8gY29lcmNlICdVbmtub3duJyAtPiAndW5rbm93bidcbiAgICBjYXNlICdVbmtub3duJzpcbiAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxufVxuY29uc3QgcHJvY2VzcyQxID0gbmV3IEV2ZW50RW1pdHRlcigpO1xucHJvY2VzcyQxLmFib3J0ID0gKCkgPT4ge307IC8vIFRPRE86IERvIHdlIGhhdmUgZXF1aXZhbGVudCBvZiBmb3JjaWJseSBraWxsaW5nIHRoZSBwcm9jZXNzPyBXZSBoYXZlIHJlc3RhcnQsIGJ1dCBJIHRoaW5rIHdlIGp1c3Qgd2FudCBhIG5vLW9wIHN0dWIgaGVyZVxucHJvY2VzcyQxLmFyY2ggPSBzdGFuZGFyZGl6ZUFyY2goVGkuUGxhdGZvcm0uYXJjaGl0ZWN0dXJlKTtcbnByb2Nlc3MkMS5hcmd2ID0gW107IC8vIFRPRE86IFdoYXQgbWFrZXMgc2Vuc2UgaGVyZT8gcGF0aCB0byB0aXRhbml1bSBjbGkgZm9yIGZpcnN0IGFyZz8gcGF0aCB0byB0aS5tYWluL2FwcC5qcyBmb3Igc2Vjb25kP1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb2Nlc3MkMSwgJ2FyZ3YwJywge1xuICB2YWx1ZTogJycsXG4gIC8vIFRPRE86IFBhdGggdG8gLmFwcCBvbiBpT1M/XG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5wcm9jZXNzJDEuYmluZGluZyA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgdW5zdXBwb3J0ZWQgYW5kIG5vdCB1c2VyLWZhY2luZyBBUEknKTtcbn07XG5wcm9jZXNzJDEuY2hhbm5lbCA9IHVuZGVmaW5lZDtcbnByb2Nlc3MkMS5jaGRpciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIHVuc3VwcG9ydGVkJyk7XG59O1xucHJvY2VzcyQxLmNvbmZpZyA9IHt9O1xucHJvY2VzcyQxLmNvbm5lY3RlZCA9IGZhbHNlO1xucHJvY2VzcyQxLmNwdVVzYWdlID0gKCkgPT4ge1xuICAvLyBGSVhNRTogQ2FuIHdlIGxvb2sgYXQgT1MuY3B1cyB0byBnZXQgdGhpcyBkYXRhP1xuICByZXR1cm4ge1xuICAgIHVzZXI6IDAsXG4gICAgc3lzdGVtOiAwXG4gIH07XG59O1xucHJvY2VzcyQxLmN3ZCA9ICgpID0+IF9fZGlybmFtZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9jZXNzJDEsICdkZWJ1Z1BvcnQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGxldCB2YWx1ZSA9IDA7IC8vIGRlZmF1bHQgdG8gMFxuICAgIHRyeSB7XG4gICAgICBpZiAoXCJhbmRyb2lkXCIgPT09ICdhbmRyb2lkJykge1xuICAgICAgICBjb25zdCBhc3NldHMgPSBrcm9sbC5iaW5kaW5nKCdhc3NldHMnKTtcbiAgICAgICAgY29uc3QganNvbiA9IGFzc2V0cy5yZWFkQXNzZXQoJ2RlcGxveS5qc29uJyk7XG4gICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgY29uc3QgZGVwbG95RGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgaWYgKGRlcGxveURhdGEuZGVidWdnZXJQb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gLTEgbWVhbnMgbm90IHNldCAobm90IGluIGRlYnVnIG1vZGUpXG4gICAgICAgICAgICB2YWx1ZSA9IGRlcGxveURhdGEuZGVidWdnZXJQb3J0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9XG4gICAgLy8gb3ZlcndyaXRlIHRoaXMgZ2V0dGVyIHdpdGggc3RhdGljIHZhbHVlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWJ1Z1BvcnQnLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5wcm9jZXNzJDEuZGlzY29ubmVjdCA9ICgpID0+IHt9OyAvLyBuby1vcFxucHJvY2VzcyQxLmRsb3BlbiA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmRsb3BlbiBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2VzcyQxLmVtaXRXYXJuaW5nID0gZnVuY3Rpb24gKHdhcm5pbmcsIG9wdGlvbnMsIGNvZGUsIGN0b3IpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICBsZXQgdHlwZTtcbiAgbGV0IGRldGFpbDtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIHR5cGUgPSBvcHRpb25zO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgY29kZSA9IG9wdGlvbnMuY29kZTtcbiAgICBkZXRhaWwgPSBvcHRpb25zLmRldGFpbDtcbiAgfVxuICBpZiAodHlwZW9mIHdhcm5pbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVE9ETzogbWFrZSB1c2Ugb2YgYGN0b3JgIGFyZyBmb3IgbGltaXRpbmcgc3RhY2sgdHJhY2VzPyBDYW4gb25seSByZWFsbHkgYmUgdXNlZCBvbiBWOFxuICAgIC8vIHNldCBzdGFjayB0cmFjZSBsaW1pdCB0byAwLCB0aGVuIGNhbGwgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Uod2FybmluZywgY3Rvcik7XG4gICAgd2FybmluZyA9IG5ldyBFcnJvcih3YXJuaW5nKTtcbiAgICB3YXJuaW5nLm5hbWUgPSB0eXBlIHx8ICdXYXJuaW5nJztcbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nLmNvZGUgPSBjb2RlO1xuICAgIH1cbiAgICBpZiAoZGV0YWlsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdhcm5pbmcuZGV0YWlsID0gZGV0YWlsO1xuICAgIH1cbiAgfVxuICAvLyBUT0RPOiBUaHJvdyBUeXBlRXJyb3IgaWYgbm90IGFuIGluc3RhbmNlb2YgRXJyb3IgYXQgdGhpcyBwb2ludCFcbiAgY29uc3QgaXNEZXByZWNhdGlvbiA9IHdhcm5pbmcubmFtZSA9PT0gJ0RlcHJlY2F0aW9uV2FybmluZyc7XG4gIGlmIChpc0RlcHJlY2F0aW9uICYmIHByb2Nlc3MkMS5ub0RlcHJlY2F0aW9uKSB7XG4gICAgcmV0dXJuOyAvLyBpZ25vcmVcbiAgfVxuXG4gIGlmIChpc0RlcHJlY2F0aW9uICYmIHByb2Nlc3MkMS50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgdGhyb3cgd2FybmluZztcbiAgfVxuICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCB3YXJuaW5nKTtcbn07XG5mdW5jdGlvbiBsb2FkRW52SnNvbigpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBqc29uRmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeSwgJ19lbnZfLmpzb24nKTtcbiAgICBpZiAoanNvbkZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb25GaWxlLnJlYWQoKS50ZXh0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgVGkuQVBJLmVycm9yKGBGYWlsZWQgdG8gcmVhZCBcIl9lbnZfLmpzb25cIi4gUmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb2Nlc3MkMSwgJ2VudicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgZGVsZXRlIHRoaXMuZW52O1xuICAgIHJldHVybiB0aGlzLmVudiA9IGxvYWRFbnZKc29uKCk7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5wcm9jZXNzJDEuZXhlY0FyZ3YgPSBbXTtcbnByb2Nlc3MkMS5leGVjUGF0aCA9ICcnOyAvLyBGSVhNRTogV2hhdCBtYWtlcyBzZW5zZSBoZXJlPyBQYXRoIHRvIHRpdGFuaXVtIENMSSBoZXJlP1xucHJvY2VzcyQxLmV4aXQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5leGl0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzJDEuZXhpdENvZGUgPSB1bmRlZmluZWQ7XG5wcm9jZXNzJDEubm9EZXByZWNhdGlvbiA9IGZhbHNlO1xucHJvY2VzcyQxLnBpZCA9IDA7XG4vLyBGSVhNRTogU2hvdWxkIHdlIHRyeSBhbmQgYWRvcHQgJ2lwYWQnLydpcGhvbmUnIHRvICdkYXJ3aW4nPyBvciAnaW9zJz9cbnByb2Nlc3MkMS5wbGF0Zm9ybSA9IFwiYW5kcm9pZFwiO1xucHJvY2VzcyQxLnBwaWQgPSAwO1xuLy8gVE9ETzogQWRkIHJlbGVhc2UgcHJvcGVydHkgKE9iamVjdClcbi8vIFRPRE86IENhbiB3ZSBleHBvc2Ugc3Rkb3V0L3N0ZGVyci9zdGRpbiBuYXRpdmVseT9cbi8vIERvbid0IHdyYXAgY29uc29sZS5sb2cvZXJyb3IgYmVjYXVzZSB0ZWNobmljYWxseSBnbG9iYWwgY29uc29sZSB3cmFwcyBwcm9jZXNzLnN0ZG91dC9zdGRlcnIgKG9yIHNob3VsZClcbnByb2Nlc3MkMS5zdGRlcnIgPSB7XG4gIGlzVFRZOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgIFRpLkFQSS5lcnJvcihjaHVuayk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnByb2Nlc3MkMS5zdGRvdXQgPSB7XG4gIGlzVFRZOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgIFRpLkFQSS5pbmZvKGNodW5rKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xucHJvY2VzcyQxLnRpdGxlID0gVGkuQXBwLm5hbWU7XG5wcm9jZXNzJDEudGhyb3dEZXByZWNhdGlvbiA9IGZhbHNlO1xucHJvY2VzcyQxLnRyYWNlRGVwcmVjYXRpb24gPSBmYWxzZTtcbnByb2Nlc3MkMS51bWFzayA9ICgpID0+IDA7IC8vIGp1c3QgYWx3YXlzIHJldHVybiAwXG5wcm9jZXNzJDEudXB0aW1lID0gKCkgPT4ge1xuICBjb25zdCBkaWZmTXMgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmZk1zIC8gMTAwMC4wOyAvLyBjb252ZXJ0IHRvIFwic2Vjb25kc1wiIHdpdGggZnJhY3Rpb25zXG59O1xuXG5wcm9jZXNzJDEudmVyc2lvbiA9IFwiMTIuNS4xXCI7XG5wcm9jZXNzJDEudmVyc2lvbnMgPSB7XG4gIG1vZHVsZXM6ICcnLFxuICAvLyBUT0RPOiBSZXBvcnQgbW9kdWxlIGFwaSB2ZXJzaW9uIChmb3IgY3VycmVudCBwbGF0Zm9ybSEpXG4gIHY4OiAnJyxcbiAgLy8gVE9ETzogcmVwb3J0IGFuZHJvaWQncyB2OCB2ZXJzaW9uIChpZiBvbiBBbmRyb2lkISlcbiAganNjOiAnJyAvLyBUT0RPOiByZXBvcnQgamF2YXNjcmlwdGNvcmUgdmVyc2lvbiBmb3IgaU9TL1dJbmRvd3M/XG4gIC8vIFRPRE86IFJlcG9ydCBpb3MvQW5kcm9pZC9XaW5kb3dzIHBsYXRmb3JtIHZlcnNpb25zP1xufTtcblxucHJvY2VzcyQxW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAncHJvY2Vzcyc7XG5nbG9iYWwucHJvY2VzcyA9IHByb2Nlc3MkMTtcbi8vIGhhbmRsZSBzcGl0dGluZyBvdXQgd2FybmluZ3NcbmNvbnN0IFdBUk5JTkdfUFJFRklYID0gYCh0aXRhbml1bToke3Byb2Nlc3MkMS5waWR9KSBgO1xucHJvY2VzcyQxLm9uKCd3YXJuaW5nJywgd2FybmluZyA9PiB7XG4gIGNvbnN0IGlzRGVwcmVjYXRpb24gPSB3YXJuaW5nLm5hbWUgPT09ICdEZXByZWNhdGlvbldhcm5pbmcnO1xuICAvLyBpZiB3ZSdyZSBub3QgZG9pbmcgZGVwcmVjYXRpb25zLCBpZ25vcmUhXG4gIGlmIChpc0RlcHJlY2F0aW9uICYmIHByb2Nlc3MkMS5ub0RlcHJlY2F0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRPRE86IENoZWNrIHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbiBhbmQgaWYgc2V0LCBpbmNsdWRlIHN0YWNrIHRyYWNlIGluIG1lc3NhZ2UhXG4gIGxldCBtc2cgPSBXQVJOSU5HX1BSRUZJWDtcbiAgaWYgKHdhcm5pbmcuY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbXNnICs9IGBbJHt3YXJuaW5nLmNvZGV9XSBgO1xuICB9XG4gIGlmICh3YXJuaW5nLnRvU3RyaW5nKSB7XG4gICAgbXNnICs9IHdhcm5pbmcudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAod2FybmluZy5kZXRhaWwpIHtcbiAgICBtc2cgKz0gYFxcbiR7d2FybmluZy5kZXRhaWx9YDtcbiAgfVxuICBjb25zb2xlLmVycm9yKG1zZyk7XG59KTtcbmxldCB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrID0gbnVsbDtcbnByb2Nlc3MkMS5oYXNVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjayA9ICgpID0+IHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgIT09IG51bGw7XG5wcm9jZXNzJDEuc2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2sgPSBmbiA9PiB7XG4gIGlmIChmbiA9PT0gbnVsbCkge1xuICAgIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnRBcmd1bWVudFR5cGUoZm4sICdmbicsICdmdW5jdGlvbicpO1xuICBpZiAodW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHByb2Nlc3Muc2V0VW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2soKWAgd2FzIGNhbGxlZCB3aGlsZSBhIGNhcHR1cmUgY2FsbGJhY2sgd2FzIGFscmVhZHkgYWN0aXZlJyk7XG4gIH1cbiAgdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayA9IGZuO1xufTtcblRpLkFwcC5hZGRFdmVudExpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBDcmVhdGUgYW4gRXJyb3IgaW5zdGFuY2UgdGhhdCB3cmFwcyB0aGUgZGF0YSBmcm9tIHRoZSBldmVudFxuICAvLyBpZGVhbGx5IHdlJ2QganVzdCBmb3J3YXJkIGFsb25nIHRoZSBvcmlnaW5hbCBFcnJvciFcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXZlbnQubWVzc2FnZSk7XG4gIGVycm9yLnN0YWNrID0gZXZlbnQuYmFja3RyYWNlO1xuICBlcnJvci5maWxlTmFtZSA9IGV2ZW50LnNvdXJjZU5hbWU7XG4gIGVycm9yLmxpbmVOdW1iZXIgPSBldmVudC5saW5lO1xuICBlcnJvci5jb2x1bW5OdW1iZXIgPSBldmVudC5saW5lT2Zmc2V0O1xuICBpZiAocHJvY2VzcyQxLmhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrKCkpIHtcbiAgICByZXR1cm4gdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayhlcnJvcik7XG4gIH1cbiAgLy8gb3RoZXJ3aXNlIGZvcndhcmQgdGhlIGV2ZW50IVxuICBwcm9jZXNzJDEuZW1pdCgndW5jYXVnaHRFeGNlcHRpb24nLCBlcnJvcik7XG59KTtcblxuLy8gVXNlIGEgbmljZSBwcmVkaWN0YWJsZSBjbGFzcy9zdHJ1Y3R1cmUgZm9yIG91ciBJbW1lZGlhdGUvVGljayBcInRpbWVyc1wiXG4vLyBKUyBlbmdpbmUgc2hvdWxkIGJlIGFibGUgdG8gb3B0aW1pemUgZWFzaWVyXG5jbGFzcyBDYWxsYmFja1dpdGhBcmdzIHtcbiAgY29uc3RydWN0b3IoZnVuYywgYXJncykge1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuICBydW4oKSB7XG4gICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgdGhpcy5mdW5jLmFwcGx5KG51bGwsIHRoaXMuYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnVuKCk7XG4gICAgfVxuICB9XG59XG4vLyBuZXh0VGljayB2cyBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIGhhbmRsZWQgaW4gYSBzZW1pLXNtYXJ0IHdheVxuLy8gQmFzaWNhbGx5IG5leHRUaWNrIG5lZWRzIHRvIGRyYWluIHRoZSBmdWxsIHF1ZXVlIChhbmQgY2FuIGNhdXNlIGluZmluaXRlIGxvb3BzIGlmIG5leHRUaWNrIGNhbGxiYWNrIGNhbGxzIG5leHRUaWNrISlcbi8vIFRoZW4gd2Ugc2hvdWxkIGdvIHRocm91Z2ggdGhlIFwiaW1tZWRpYXRlXCIgcXVldWVcbi8vIGh0dHA6Ly9wbGFmZXIuZ2l0aHViLmlvLzIwMTUvMDkvMDgvbmV4dFRpY2stdnMtc2V0SW1tZWRpYXRlL1xuY29uc3QgdGlja1F1ZXVlID0gW107XG5jb25zdCBpbW1lZGlhdGVRdWV1ZSA9IFtdO1xubGV0IGRyYWluaW5nVGlja1F1ZXVlID0gZmFsc2U7XG5sZXQgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gbnVsbDtcblxuLyoqXG4gKiBJdGVyYXRpdmVseSBydW5zIGFsbCBcInRpY2tzXCIgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUuXG4gKiBUaGlzIGNhbiBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24gaWYgYSB0aWNrIHNjaGVkdWxlcyBhbm90aGVyIGZvcmV2ZXIuXG4gKi9cbmZ1bmN0aW9uIGRyYWluVGlja1F1ZXVlKCkge1xuICBpZiAoZHJhaW5pbmdUaWNrUXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZHJhaW5pbmdUaWNrUXVldWUgPSB0cnVlO1xuICB3aGlsZSAodGlja1F1ZXVlLmxlbmd0aCkge1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrUXVldWUuc2hpZnQoKTtcbiAgICB0aWNrLnJ1bigpO1xuICB9XG4gIGRyYWluaW5nVGlja1F1ZXVlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmFpblF1ZXVlcygpIHtcbiAgLy8gZHJhaW4gdGhlIGZ1bGwgdGljayBxdWV1ZSBmaXJzdC4uLlxuICBkcmFpblRpY2tRdWV1ZSgpO1xuICAvLyB0aWNrIHF1ZXVlIHNob3VsZCBiZSBlbXB0eSFcbiAgY29uc3QgaW1tZWRpYXRlc1JlbWFpbmluZyA9IHByb2Nlc3NJbW1lZGlhdGVRdWV1ZSgpO1xuICBpZiAoaW1tZWRpYXRlc1JlbWFpbmluZyAhPT0gMCkge1xuICAgIC8vIHJlLXNjaGVkdWxlIGRyYWluaW5nIG91ciBxdWV1ZXMsIGFzIHdlIGhhdmUgYXQgbGVhc3Qgb25lIG1vcmUgXCJpbW1lZGlhdGVcIiB0byBoYW5kbGVcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRyYWluUXVldWVzLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcHJvY2VzcyBcImltbWVkaWF0ZXNcIiAoaW4gYSBtdWNoIG1vcmUgbGVpc3VyZWx5IHdheSB0aGFuIHRpY2tzKVxuICogV2UgZ2l2ZSBhIDEwMG1zIHdpbmRvdyB0byBydW4gdGhlbSBpbiBiZWZvcmUgcmUtc2NoZWR1bGluZyB0aGUgdGltZW91dCB0byBwcm9jZXNzIHRoZW0gYWdhaW4uXG4gKiBJZiBhbnkgdGlja3MgYXJlIGFkZGVkIGR1cmluZyBpbnZvY2F0aW9uIG9mIGltbWVkaWF0ZSwgd2UgZHJhaW4gdGhlIHRpY2sgcXVldWUgZnVsbHkgYmVmb3JlXG4gKiBwcm9jZWVkaW5nIHRvIG5leHQgaW1tZWRpYXRlIChpZiB3ZSBzdGlsbCBoYXZlIHRpbWUgaW4gb3VyIHdpbmRvdykuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgb2YgcmVtYWluaW5nIGltbWVkaWF0ZXMgdG8gYmUgcHJvY2Vzc2VkXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NJbW1lZGlhdGVRdWV1ZSgpIHtcbiAgY29uc3QgaW1tZWRpYXRlRGVhZGxpbmUgPSBEYXRlLm5vdygpICsgMTAwOyAvLyBnaXZlIHVzIHVwIHRvIDEwMG1zIHRvIHByb2Nlc3MgaW1tZWRpYXRlc1xuICB3aGlsZSAoaW1tZWRpYXRlUXVldWUubGVuZ3RoICYmIERhdGUubm93KCkgPCBpbW1lZGlhdGVEZWFkbGluZSkge1xuICAgIGNvbnN0IGltbWVkaWF0ZSA9IGltbWVkaWF0ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgaW1tZWRpYXRlLnJ1bigpO1xuICAgIGlmICh0aWNrUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgLy8gdGhleSBhZGRlZCBhIHRpY2shIGRyYWluIHRoZSB0aWNrIHF1ZXVlIGJlZm9yZSB3ZSBkbyBhbnl0aGluZyBlbHNlICh0aGlzICptYXkqIGVhdCB1cCBvdXIgZGVhZGxpbmUvd2luZG93IHRvIHByb2Nlc3MgYW55IG1vcmUgaW1tZWRpYXRlcylcbiAgICAgIGRyYWluVGlja1F1ZXVlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbW1lZGlhdGVRdWV1ZS5sZW5ndGg7XG59XG5wcm9jZXNzJDEubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGNhbGxiYWNrLCAnY2FsbGJhY2snLCAnZnVuY3Rpb24nKTtcbiAgdGlja1F1ZXVlLnB1c2gobmV3IENhbGxiYWNrV2l0aEFyZ3MoY2FsbGJhY2ssIGFyZ3MpKTtcbiAgaWYgKCFkcmFpblF1ZXVlc1RpbWVvdXQpIHtcbiAgICBkcmFpblF1ZXVlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGRyYWluUXVldWVzLCAwKTtcbiAgfVxufTtcbmdsb2JhbC5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGNhbGxiYWNrLCAnY2FsbGJhY2snLCAnZnVuY3Rpb24nKTtcbiAgY29uc3QgaW1tZWRpYXRlID0gbmV3IENhbGxiYWNrV2l0aEFyZ3MoY2FsbGJhY2ssIGFyZ3MpO1xuICBpbW1lZGlhdGVRdWV1ZS5wdXNoKGltbWVkaWF0ZSk7XG4gIGlmICghZHJhaW5RdWV1ZXNUaW1lb3V0KSB7XG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gc2V0VGltZW91dChkcmFpblF1ZXVlcywgMCk7XG4gIH1cbiAgcmV0dXJuIGltbWVkaWF0ZTtcbn07XG5nbG9iYWwuY2xlYXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XG4gIGNvbnN0IGluZGV4ID0gaW1tZWRpYXRlUXVldWUuaW5kZXhPZihpbW1lZGlhdGUpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgaW1tZWRpYXRlUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuY29uc3QgRk9SV0FSRF9TTEFTSCA9IDQ3OyAvLyAnLydcbmNvbnN0IEJBQ0tXQVJEX1NMQVNIID0gOTI7IC8vICdcXFxcJ1xuXG4vKipcbiAqIElzIHRoaXMgW2EtekEtWl0/XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBjaGFyQ29kZSB2YWx1ZSBmcm9tIFN0cmluZy5jaGFyQ29kZUF0KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3dzRGV2aWNlTmFtZShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gOTAgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTIyO1xufVxuXG4vKipcbiAqIFtpc0Fic29sdXRlIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gaXNQb3NpeCB3aGV0aGVyIHRoaXMgaW1wbCBpcyBmb3IgUE9TSVggb3Igbm90XG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGlzQWJzb2x1dGUoaXNQb3NpeCwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuICAvLyBlbXB0eSBzdHJpbmcgc3BlY2lhbCBjYXNlXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdCgwKTtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIHdlIGFscmVhZHkgZGlkIG91ciBjaGVja3MgZm9yIHBvc2l4XG4gIGlmIChpc1Bvc2l4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIHdpbjMyIGZyb20gaGVyZSBvbiBvdXRcbiAgaWYgKGZpcnN0Q2hhciA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobGVuZ3RoID4gMiAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKGZpcnN0Q2hhcikgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICBjb25zdCB0aGlyZENoYXIgPSBmaWxlcGF0aC5jaGFyQXQoMik7XG4gICAgcmV0dXJuIHRoaXJkQ2hhciA9PT0gJy8nIHx8IHRoaXJkQ2hhciA9PT0gJ1xcXFwnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBbZGlybmFtZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yICBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gZGlybmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIGNvbnN0IGxlbmd0aCA9IGZpbGVwYXRoLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnLic7XG4gIH1cblxuICAvLyBpZ25vcmUgdHJhaWxpbmcgc2VwYXJhdG9yXG4gIGxldCBmcm9tSW5kZXggPSBsZW5ndGggLSAxO1xuICBjb25zdCBoYWRUcmFpbGluZyA9IGZpbGVwYXRoLmVuZHNXaXRoKHNlcGFyYXRvcik7XG4gIGlmIChoYWRUcmFpbGluZykge1xuICAgIGZyb21JbmRleC0tO1xuICB9XG4gIGNvbnN0IGZvdW5kSW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZihzZXBhcmF0b3IsIGZyb21JbmRleCk7XG4gIC8vIG5vIHNlcGFyYXRvcnNcbiAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSB7XG4gICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiByb290IHdpbmRvd3MgcGF0aHNcbiAgICBpZiAobGVuZ3RoID49IDIgJiYgc2VwYXJhdG9yID09PSAnXFxcXCcgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXIpKSB7XG4gICAgICAgIHJldHVybiBmaWxlcGF0aDsgLy8gaXQncyBhIHJvb3Qgd2luZG93cyBwYXRoXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcuJztcbiAgfVxuICAvLyBvbmx5IGZvdW5kIHJvb3Qgc2VwYXJhdG9yXG4gIGlmIChmb3VuZEluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuIHNlcGFyYXRvcjsgLy8gaWYgaXQgd2FzICcvJywgcmV0dXJuIHRoYXRcbiAgfVxuICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIG9mICcvL3NvbWV0aGluZydcbiAgaWYgKGZvdW5kSW5kZXggPT09IDEgJiYgc2VwYXJhdG9yID09PSAnLycgJiYgZmlsZXBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gJy8vJztcbiAgfVxuICByZXR1cm4gZmlsZXBhdGguc2xpY2UoMCwgZm91bmRJbmRleCk7XG59XG5cbi8qKlxuICogW2V4dG5hbWUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGV4dG5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBjb25zdCBpbmRleCA9IGZpbGVwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gIGlmIChpbmRleCA9PT0gLTEgfHwgaW5kZXggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLy8gaWdub3JlIHRyYWlsaW5nIHNlcGFyYXRvclxuICBsZXQgZW5kSW5kZXggPSBmaWxlcGF0aC5sZW5ndGg7XG4gIGlmIChmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpKSB7XG4gICAgZW5kSW5kZXgtLTtcbiAgfVxuICByZXR1cm4gZmlsZXBhdGguc2xpY2UoaW5kZXgsIGVuZEluZGV4KTtcbn1cbmZ1bmN0aW9uIGxhc3RJbmRleFdpbjMyU2VwYXJhdG9yKGZpbGVwYXRoLCBpbmRleCkge1xuICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgY2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXIgPT09IEJBQ0tXQVJEX1NMQVNIIHx8IGNoYXIgPT09IEZPUldBUkRfU0xBU0gpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogW2Jhc2VuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtleHRdICAgICAgZmlsZSBleHRlbnNpb24gdG8gZHJvcCBpZiBpdCBleGlzdHNcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIGJhc2VuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgsIGV4dCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBpZiAoZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnRBcmd1bWVudFR5cGUoZXh0LCAnZXh0JywgJ3N0cmluZycpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IGZpbGVwYXRoLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBpc1Bvc2l4ID0gc2VwYXJhdG9yID09PSAnLyc7XG4gIGxldCBlbmRJbmRleCA9IGxlbmd0aDtcbiAgLy8gZHJvcCB0cmFpbGluZyBzZXBhcmF0b3IgKGlmIHRoZXJlIGlzIG9uZSlcbiAgY29uc3QgbGFzdENoYXJDb2RlID0gZmlsZXBhdGguY2hhckNvZGVBdChsZW5ndGggLSAxKTtcbiAgaWYgKGxhc3RDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCB8fCAhaXNQb3NpeCAmJiBsYXN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgZW5kSW5kZXgtLTtcbiAgfVxuXG4gIC8vIEZpbmQgbGFzdCBvY2N1cmVuY2Ugb2Ygc2VwYXJhdG9yXG4gIGxldCBsYXN0SW5kZXggPSAtMTtcbiAgaWYgKGlzUG9zaXgpIHtcbiAgICBsYXN0SW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZihzZXBhcmF0b3IsIGVuZEluZGV4IC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gT24gd2luMzIsIGhhbmRsZSAqZWl0aGVyKiBzZXBhcmF0b3IhXG4gICAgbGFzdEluZGV4ID0gbGFzdEluZGV4V2luMzJTZXBhcmF0b3IoZmlsZXBhdGgsIGVuZEluZGV4IC0gMSk7XG4gICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiByb290IHBhdGggbGlrZSAnQzonIG9yICdDOlxcXFwnXG4gICAgaWYgKChsYXN0SW5kZXggPT09IDIgfHwgbGFzdEluZGV4ID09PSAtMSkgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaWxlcGF0aC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRha2UgZnJvbSBsYXN0IG9jY3VycmVuY2Ugb2Ygc2VwYXJhdG9yIHRvIGVuZCBvZiBzdHJpbmcgKG9yIGJlZ2lubmluZyB0byBlbmQgaWYgbm90IGZvdW5kKVxuICBjb25zdCBiYXNlID0gZmlsZXBhdGguc2xpY2UobGFzdEluZGV4ICsgMSwgZW5kSW5kZXgpO1xuXG4gIC8vIGRyb3AgdHJhaWxpbmcgZXh0ZW5zaW9uIChpZiBzcGVjaWZpZWQpXG4gIGlmIChleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIHJldHVybiBiYXNlLmVuZHNXaXRoKGV4dCkgPyBiYXNlLnNsaWNlKDAsIGJhc2UubGVuZ3RoIC0gZXh0Lmxlbmd0aCkgOiBiYXNlO1xufVxuXG4vKipcbiAqIFRoZSBgcGF0aC5ub3JtYWxpemUoKWAgbWV0aG9kIG5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGgsIHJlc29sdmluZyAnLi4nIGFuZCAnLicgc2VnbWVudHMuXG4gKlxuICogV2hlbiBtdWx0aXBsZSwgc2VxdWVudGlhbCBwYXRoIHNlZ21lbnQgc2VwYXJhdGlvbiBjaGFyYWN0ZXJzIGFyZSBmb3VuZCAoZS5nLlxuICogLyBvbiBQT1NJWCBhbmQgZWl0aGVyIFxcIG9yIC8gb24gV2luZG93cyksIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IGEgc2luZ2xlXG4gKiBpbnN0YW5jZSBvZiB0aGUgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aCBzZWdtZW50IHNlcGFyYXRvciAoLyBvbiBQT1NJWCBhbmQgXFxcbiAqIG9uIFdpbmRvd3MpLiBUcmFpbGluZyBzZXBhcmF0b3JzIGFyZSBwcmVzZXJ2ZWQuXG4gKlxuICogSWYgdGhlIHBhdGggaXMgYSB6ZXJvLWxlbmd0aCBzdHJpbmcsICcuJyBpcyByZXR1cm5lZCwgcmVwcmVzZW50aW5nIHRoZVxuICogY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggIGlucHV0IGZpbGUgcGF0aFxuICogQHJldHVybiB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIGlmIChmaWxlcGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgLy8gV2luZG93cyBjYW4gaGFuZGxlICcvJyBvciAnXFxcXCcgYW5kIGJvdGggc2hvdWxkIGJlIHR1cm5lZCBpbnRvIHNlcGFyYXRvclxuICBjb25zdCBpc1dpbmRvd3MgPSBzZXBhcmF0b3IgPT09ICdcXFxcJztcbiAgaWYgKGlzV2luZG93cykge1xuICAgIGZpbGVwYXRoID0gZmlsZXBhdGgucmVwbGFjZSgvXFwvL2csIHNlcGFyYXRvcik7XG4gIH1cbiAgY29uc3QgaGFkTGVhZGluZyA9IGZpbGVwYXRoLnN0YXJ0c1dpdGgoc2VwYXJhdG9yKTtcbiAgLy8gT24gV2luZG93cywgbmVlZCB0byBoYW5kbGUgVU5DIHBhdGhzIChcXFxcaG9zdC1uYW1lXFxcXHJlc291cmNlXFxcXGRpcikgc3BlY2lhbCB0byByZXRhaW4gbGVhZGluZyBkb3VibGUgYmFja3NsYXNoXG4gIGNvbnN0IGlzVU5DID0gaGFkTGVhZGluZyAmJiBpc1dpbmRvd3MgJiYgZmlsZXBhdGgubGVuZ3RoID4gMiAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICdcXFxcJztcbiAgY29uc3QgaGFkVHJhaWxpbmcgPSBmaWxlcGF0aC5lbmRzV2l0aChzZXBhcmF0b3IpO1xuICBjb25zdCBwYXJ0cyA9IGZpbGVwYXRoLnNwbGl0KHNlcGFyYXRvcik7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGFydHMpIHtcbiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDAgJiYgc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgICByZXN1bHQucG9wKCk7IC8vIEZJWE1FOiBXaGF0IGlmIHRoaXMgZ29lcyBhYm92ZSByb290PyBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3I/XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IG5vcm1hbGl6ZWQgPSBoYWRMZWFkaW5nID8gc2VwYXJhdG9yIDogJyc7XG4gIG5vcm1hbGl6ZWQgKz0gcmVzdWx0LmpvaW4oc2VwYXJhdG9yKTtcbiAgaWYgKGhhZFRyYWlsaW5nKSB7XG4gICAgbm9ybWFsaXplZCArPSBzZXBhcmF0b3I7XG4gIH1cbiAgaWYgKGlzVU5DKSB7XG4gICAgbm9ybWFsaXplZCA9ICdcXFxcJyArIG5vcm1hbGl6ZWQ7XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8qKlxuICogW2Fzc2VydFNlZ21lbnQgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHsqfSBzZWdtZW50IFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3ZvaWR9ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBhc3NlcnRTZWdtZW50KHNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgJHtzZWdtZW50fWApO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGBwYXRoLmpvaW4oKWAgbWV0aG9kIGpvaW5zIGFsbCBnaXZlbiBwYXRoIHNlZ21lbnRzIHRvZ2V0aGVyIHVzaW5nIHRoZVxuICogcGxhdGZvcm0tc3BlY2lmaWMgc2VwYXJhdG9yIGFzIGEgZGVsaW1pdGVyLCB0aGVuIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdGluZyBwYXRoLlxuICogWmVyby1sZW5ndGggcGF0aCBzZWdtZW50cyBhcmUgaWdub3JlZC4gSWYgdGhlIGpvaW5lZCBwYXRoIHN0cmluZyBpcyBhIHplcm8tXG4gKiBsZW5ndGggc3RyaW5nIHRoZW4gJy4nIHdpbGwgYmUgcmV0dXJuZWQsIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmdbXX0gcGF0aHMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICBUaGUgam9pbmVkIGZpbGVwYXRoXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yLCBwYXRocykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgLy8gbmFpdmUgaW1wbDoganVzdCBqb2luIGFsbCB0aGUgcGF0aHMgd2l0aCBzZXBhcmF0b3JcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGhzKSB7XG4gICAgYXNzZXJ0U2VnbWVudChzZWdtZW50KTtcbiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplKHNlcGFyYXRvciwgcmVzdWx0LmpvaW4oc2VwYXJhdG9yKSk7XG59XG5cbi8qKlxuICogVGhlIGBwYXRoLnJlc29sdmUoKWAgbWV0aG9kIHJlc29sdmVzIGEgc2VxdWVuY2Ugb2YgcGF0aHMgb3IgcGF0aCBzZWdtZW50cyBpbnRvIGFuIGFic29sdXRlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSBwYXRocyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShzZXBhcmF0b3IsIHBhdGhzKSB7XG4gIGxldCByZXNvbHZlZCA9ICcnO1xuICBsZXQgaGl0Um9vdCA9IGZhbHNlO1xuICBjb25zdCBpc1Bvc2l4ID0gc2VwYXJhdG9yID09PSAnLyc7XG4gIC8vIGdvIGZyb20gcmlnaHQgdG8gbGVmdCB1bnRpbCB3ZSBoaXQgYWJzb2x1dGUgcGF0aC9yb290XG4gIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoc1tpXTtcbiAgICBhc3NlcnRTZWdtZW50KHNlZ21lbnQpO1xuICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7IC8vIHNraXAgZW1wdHlcbiAgICB9XG5cbiAgICByZXNvbHZlZCA9IHNlZ21lbnQgKyBzZXBhcmF0b3IgKyByZXNvbHZlZDsgLy8gcHJlcGVuZCBuZXcgc2VnbWVudFxuICAgIGlmIChpc0Fic29sdXRlKGlzUG9zaXgsIHNlZ21lbnQpKSB7XG4gICAgICAvLyBoYXZlIHdlIGJhY2tlZCBpbnRvIGFuIGFic29sdXRlIHBhdGg/XG4gICAgICBoaXRSb290ID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBpZiB3ZSBkaWRuJ3QgaGl0IHJvb3QsIHByZXBlbmQgY3dkXG4gIGlmICghaGl0Um9vdCkge1xuICAgIHJlc29sdmVkID0gKGdsb2JhbC5wcm9jZXNzID8gcHJvY2Vzcy5jd2QoKSA6ICcvJykgKyBzZXBhcmF0b3IgKyByZXNvbHZlZDtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplKHNlcGFyYXRvciwgcmVzb2x2ZWQpO1xuICBpZiAobm9ybWFsaXplZC5jaGFyQXQobm9ybWFsaXplZC5sZW5ndGggLSAxKSA9PT0gc2VwYXJhdG9yKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgb24gV2luZG93cyBhcyB3ZWxsLCBzbyB3ZSBkb24ndCB0cmltIHRyYWlsaW5nIHNlcGFyYXRvciBvbiBzb21ldGhpbmcgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcJ1xuICAgIC8vIERvbid0IHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3IgaWYgdGhpcyBpcyByb290IHBhdGggb24gd2luZG93cyFcbiAgICBpZiAoIWlzUG9zaXggJiYgbm9ybWFsaXplZC5sZW5ndGggPT09IDMgJiYgbm9ybWFsaXplZC5jaGFyQXQoMSkgPT09ICc6JyAmJiBpc1dpbmRvd3NEZXZpY2VOYW1lKG5vcm1hbGl6ZWQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgdHJpbSB0cmFpbGluZyBzZXBhcmF0b3JcbiAgICByZXR1cm4gbm9ybWFsaXplZC5zbGljZSgwLCBub3JtYWxpemVkLmxlbmd0aCAtIDEpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vKipcbiAqIFRoZSBgcGF0aC5yZWxhdGl2ZSgpYCBtZXRob2QgcmV0dXJucyB0aGUgcmVsYXRpdmUgcGF0aCBgZnJvbWAgZnJvbSB0byBgdG9gIGJhc2VkXG4gKiBvbiB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gSWYgZnJvbSBhbmQgdG8gZWFjaCByZXNvbHZlIHRvIHRoZSBzYW1lXG4gKiBwYXRoIChhZnRlciBjYWxsaW5nIGBwYXRoLnJlc29sdmUoKWAgb24gZWFjaCksIGEgemVyby1sZW5ndGggc3RyaW5nIGlzIHJldHVybmVkLlxuICpcbiAqIElmIGEgemVyby1sZW5ndGggc3RyaW5nIGlzIHBhc3NlZCBhcyBgZnJvbWAgb3IgYHRvYCwgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnlcbiAqIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSB6ZXJvLWxlbmd0aCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZyb20gW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSB0byAgIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKHNlcGFyYXRvciwgZnJvbSwgdG8pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZyb20sICdmcm9tJywgJ3N0cmluZycpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUodG8sICd0bycsICdzdHJpbmcnKTtcbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGZyb20gPSByZXNvbHZlKHNlcGFyYXRvciwgW2Zyb21dKTtcbiAgdG8gPSByZXNvbHZlKHNlcGFyYXRvciwgW3RvXSk7XG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIHdlIG5vdyBoYXZlIHR3byBhYnNvbHV0ZSBwYXRocyxcbiAgLy8gbGV0cyBcImdvIHVwXCIgZnJvbSBgZnJvbWAgdW50aWwgd2UgcmVhY2ggY29tbW9uIGJhc2UgZGlyIG9mIGB0b2BcbiAgLy8gY29uc3Qgb3JpZ2luYWxGcm9tID0gZnJvbTtcbiAgbGV0IHVwQ291bnQgPSAwO1xuICBsZXQgcmVtYWluaW5nUGF0aCA9ICcnO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh0by5zdGFydHNXaXRoKGZyb20pKSB7XG4gICAgICAvLyBtYXRjaCEgcmVjb3JkIHJlc3QuLi4/XG4gICAgICByZW1haW5pbmdQYXRoID0gdG8uc2xpY2UoZnJvbS5sZW5ndGgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIEZJWE1FOiBCcmVhay90aHJvdyBpZiB3ZSBoaXQgYmFkIGVkZ2UgY2FzZSBvZiBubyBjb21tb24gcm9vdCFcbiAgICBmcm9tID0gZGlybmFtZShzZXBhcmF0b3IsIGZyb20pO1xuICAgIHVwQ291bnQrKztcbiAgfVxuICAvLyByZW1vdmUgbGVhZGluZyBzZXBhcmF0b3IgZnJvbSByZW1haW5pbmdQYXRoIGlmIHRoZXJlIGlzIGFueVxuICBpZiAocmVtYWluaW5nUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgcmVtYWluaW5nUGF0aCA9IHJlbWFpbmluZ1BhdGguc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuICgnLi4nICsgc2VwYXJhdG9yKS5yZXBlYXQodXBDb3VudCkgKyByZW1haW5pbmdQYXRoO1xufVxuXG4vKipcbiAqIFRoZSBgcGF0aC5wYXJzZSgpYCBtZXRob2QgcmV0dXJucyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyByZXByZXNlbnRcbiAqIHNpZ25pZmljYW50IGVsZW1lbnRzIG9mIHRoZSBwYXRoLiBUcmFpbGluZyBkaXJlY3Rvcnkgc2VwYXJhdG9ycyBhcmUgaWdub3JlZCxcbiAqIHNlZSBgcGF0aC5zZXBgLlxuICpcbiAqIFRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIGRpciA8c3RyaW5nPlxuICogLSByb290IDxzdHJpbmc+XG4gKiAtIGJhc2UgPHN0cmluZz5cbiAqIC0gbmFtZSA8c3RyaW5nPlxuICogLSBleHQgPHN0cmluZz5cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc2VwYXJhdG9yLCBmaWxlcGF0aCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZmlsZXBhdGgsICdwYXRoJywgJ3N0cmluZycpO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcm9vdDogJycsXG4gICAgZGlyOiAnJyxcbiAgICBiYXNlOiAnJyxcbiAgICBleHQ6ICcnLFxuICAgIG5hbWU6ICcnXG4gIH07XG4gIGNvbnN0IGxlbmd0aCA9IGZpbGVwYXRoLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBDaGVhdCBhbmQganVzdCBjYWxsIG91ciBvdGhlciBtZXRob2RzIGZvciBkaXJuYW1lL2Jhc2VuYW1lL2V4dG5hbWU/XG4gIHJlc3VsdC5iYXNlID0gYmFzZW5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCk7XG4gIHJlc3VsdC5leHQgPSBleHRuYW1lKHNlcGFyYXRvciwgcmVzdWx0LmJhc2UpO1xuICBjb25zdCBiYXNlTGVuZ3RoID0gcmVzdWx0LmJhc2UubGVuZ3RoO1xuICByZXN1bHQubmFtZSA9IHJlc3VsdC5iYXNlLnNsaWNlKDAsIGJhc2VMZW5ndGggLSByZXN1bHQuZXh0Lmxlbmd0aCk7XG4gIGNvbnN0IHRvU3VidHJhY3QgPSBiYXNlTGVuZ3RoID09PSAwID8gMCA6IGJhc2VMZW5ndGggKyAxO1xuICByZXN1bHQuZGlyID0gZmlsZXBhdGguc2xpY2UoMCwgZmlsZXBhdGgubGVuZ3RoIC0gdG9TdWJ0cmFjdCk7IC8vIGRyb3AgdHJhaWxpbmcgc2VwYXJhdG9yIVxuICBjb25zdCBmaXJzdENoYXJDb2RlID0gZmlsZXBhdGguY2hhckNvZGVBdCgwKTtcbiAgLy8gYm90aCB3aW4zMiBhbmQgUE9TSVggcmV0dXJuICcvJyByb290XG4gIGlmIChmaXJzdENoYXJDb2RlID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgcmVzdWx0LnJvb3QgPSAnLyc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyB3ZSdyZSBkb25lIHdpdGggUE9TSVguLi5cbiAgaWYgKHNlcGFyYXRvciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyBmb3Igd2luMzIuLi5cbiAgaWYgKGZpcnN0Q2hhckNvZGUgPT09IEJBQ0tXQVJEX1NMQVNIKSB7XG4gICAgLy8gRklYTUU6IEhhbmRsZSBVTkMgcGF0aHMgbGlrZSAnXFxcXFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcZmlsZV9wYXRoJ1xuICAgIC8vIG5lZWQgdG8gcmV0YWluICdcXFxcXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFwnIGFzIHJvb3QgaW4gdGhhdCBjYXNlIVxuICAgIHJlc3VsdC5yb290ID0gJ1xcXFwnO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIEM6IHN0eWxlIHJvb3RcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXJDb2RlKSAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgIGlmIChsZW5ndGggPiAyKSB7XG4gICAgICAvLyBpcyBpdCBsaWtlIEM6XFxcXD9cbiAgICAgIGNvbnN0IHRoaXJkQ2hhckNvZGUgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkQ2hhckNvZGUgPT09IEZPUldBUkRfU0xBU0ggfHwgdGhpcmRDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgcmVzdWx0LnJvb3QgPSBmaWxlcGF0aC5zbGljZSgwLCAzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm9wZSwganVzdCBDOiwgbm8gdHJhaWxpbmcgc2VwYXJhdG9yXG4gICAgcmVzdWx0LnJvb3QgPSBmaWxlcGF0aC5zbGljZSgwLCAyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBgcGF0aC5mb3JtYXQoKWAgbWV0aG9kIHJldHVybnMgYSBwYXRoIHN0cmluZyBmcm9tIGFuIG9iamVjdC4gVGhpcyBpcyB0aGVcbiAqIG9wcG9zaXRlIG9mIGBwYXRoLnBhcnNlKClgLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBhdGhPYmplY3Qgb2JqZWN0IG9mIGZvcm1hdCByZXR1cm5lZCBieSBgcGF0aC5wYXJzZSgpYFxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LmRpciBkaXJlY3RvcnkgbmFtZVxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LnJvb3QgZmlsZSByb290IGRpciwgaWdub3JlZCBpZiBgcGF0aE9iamVjdC5kaXJgIGlzIHByb3ZpZGVkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QuYmFzZSBmaWxlIGJhc2VuYW1lXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QubmFtZSBiYXNlbmFtZSBtaW51cyBleHRlbnNpb24sIGlnbm9yZWQgaWYgYHBhdGhPYmplY3QuYmFzZWAgZXhpc3RzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGhPYmplY3QuZXh0IGZpbGUgZXh0ZW5zaW9uLCBpZ25vcmVkIGlmIGBwYXRoT2JqZWN0LmJhc2VgIGV4aXN0c1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmb3JtYXQoc2VwYXJhdG9yLCBwYXRoT2JqZWN0KSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShwYXRoT2JqZWN0LCAncGF0aE9iamVjdCcsICdvYmplY3QnKTtcbiAgY29uc3QgYmFzZSA9IHBhdGhPYmplY3QuYmFzZSB8fCBgJHtwYXRoT2JqZWN0Lm5hbWUgfHwgJyd9JHtwYXRoT2JqZWN0LmV4dCB8fCAnJ31gO1xuXG4gIC8vIGFwcGVuZCBiYXNlIHRvIHJvb3QgaWYgYGRpcmAgd2Fzbid0IHNwZWNpZmllZCwgb3IgaWZcbiAgLy8gZGlyIGlzIHRoZSByb290XG4gIGlmICghcGF0aE9iamVjdC5kaXIgfHwgcGF0aE9iamVjdC5kaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBgJHtwYXRoT2JqZWN0LnJvb3QgfHwgJyd9JHtiYXNlfWA7XG4gIH1cbiAgLy8gY29tYmluZSBkaXIgKyAvICsgYmFzZVxuICByZXR1cm4gYCR7cGF0aE9iamVjdC5kaXJ9JHtzZXBhcmF0b3J9JHtiYXNlfWA7XG59XG5cbi8qKlxuICogT24gV2luZG93cyBzeXN0ZW1zIG9ubHksIHJldHVybnMgYW4gZXF1aXZhbGVudCBuYW1lc3BhY2UtcHJlZml4ZWQgcGF0aCBmb3JcbiAqIHRoZSBnaXZlbiBwYXRoLiBJZiBwYXRoIGlzIG5vdCBhIHN0cmluZywgcGF0aCB3aWxsIGJlIHJldHVybmVkIHdpdGhvdXQgbW9kaWZpY2F0aW9ucy5cbiAqIFNlZSBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy93aW5kb3dzL2Rlc2t0b3AvRmlsZUlPL25hbWluZy1hLWZpbGUjbmFtZXNwYWNlc1xuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gdG9OYW1lc3BhY2VkUGF0aChmaWxlcGF0aCkge1xuICBpZiAodHlwZW9mIGZpbGVwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuICBpZiAoZmlsZXBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IHJlc29sdmUoJ1xcXFwnLCBbZmlsZXBhdGhdKTtcbiAgY29uc3QgbGVuZ3RoID0gcmVzb2x2ZWRQYXRoLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAvLyBuZWVkICdcXFxcXFxcXCcgb3IgJ0M6JyBtaW5pbXVtXG4gICAgcmV0dXJuIGZpbGVwYXRoO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgwKTtcbiAgLy8gaWYgc3RhcnQgd2l0aCAnXFxcXFxcXFwnLCBwcmVmaXggd2l0aCBVTkMgcm9vdCwgZHJvcCB0aGUgc2xhc2hlc1xuICBpZiAoZmlyc3RDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0ggJiYgcmVzb2x2ZWRQYXRoLmNoYXJBdCgxKSA9PT0gJ1xcXFwnKSB7XG4gICAgLy8gcmV0dXJuIGFzLWlzIGlmIGl0J3MgYW4gYXJlYWR5IGxvbmcgcGF0aCAoJ1xcXFxcXFxcP1xcXFwnIG9yICdcXFxcXFxcXC5cXFxcJyBwcmVmaXgpXG4gICAgaWYgKGxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zdCB0aGlyZENoYXIgPSByZXNvbHZlZFBhdGguY2hhckF0KDIpO1xuICAgICAgaWYgKHRoaXJkQ2hhciA9PT0gJz8nIHx8IHRoaXJkQ2hhciA9PT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBmaWxlcGF0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdcXFxcXFxcXD9cXFxcVU5DXFxcXCcgKyByZXNvbHZlZFBhdGguc2xpY2UoMik7XG4gIH0gZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXJDb2RlKSAmJiByZXNvbHZlZFBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICByZXR1cm4gJ1xcXFxcXFxcP1xcXFwnICsgcmVzb2x2ZWRQYXRoO1xuICB9XG4gIHJldHVybiBmaWxlcGF0aDtcbn1cbmNvbnN0IFdpbjMyUGF0aCA9IHtcbiAgc2VwOiAnXFxcXCcsXG4gIGRlbGltaXRlcjogJzsnLFxuICBiYXNlbmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUodGhpcy5zZXAsIGZpbGVwYXRoLCBleHQpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gKC4uLnBhdGhzKSB7XG4gICAgcmV0dXJuIGpvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUoZmFsc2UsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHBhdGhPYmplY3QpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMuc2VwLCBwYXRoT2JqZWN0KTtcbiAgfSxcbiAgdG9OYW1lc3BhY2VkUGF0aDogdG9OYW1lc3BhY2VkUGF0aFxufTtcbmNvbnN0IFBvc2l4UGF0aCA9IHtcbiAgc2VwOiAnLycsXG4gIGRlbGltaXRlcjogJzonLFxuICBiYXNlbmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoLCBleHQpIHtcbiAgICByZXR1cm4gYmFzZW5hbWUodGhpcy5zZXAsIGZpbGVwYXRoLCBleHQpO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBub3JtYWxpemUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24gKC4uLnBhdGhzKSB7XG4gICAgcmV0dXJuIGpvaW4odGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUodHJ1ZSwgZmlsZXBhdGgpO1xuICB9LFxuICByZWxhdGl2ZTogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlKHRoaXMuc2VwLCBmcm9tLCB0byk7XG4gIH0sXG4gIHJlc29sdmU6IGZ1bmN0aW9uICguLi5wYXRocykge1xuICAgIHJldHVybiByZXNvbHZlKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gcGFyc2UodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZm9ybWF0OiBmdW5jdGlvbiAocGF0aE9iamVjdCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7IC8vIG5vLW9wXG4gIH1cbn07XG5cbmNvbnN0IHBhdGggPSBQb3NpeFBhdGg7XG5wYXRoLndpbjMyID0gV2luMzJQYXRoO1xucGF0aC5wb3NpeCA9IFBvc2l4UGF0aDtcblxuY29uc3QgUG9zaXhDb25zdGFudHMgPSB7XG4gIFVWX1VEUF9SRVVTRUFERFI6IDQsXG4gIGRsb3Blbjoge30sXG4gIGVycm5vOiB7XG4gICAgRTJCSUc6IDcsXG4gICAgRUFDQ0VTOiAxMyxcbiAgICBFQUREUklOVVNFOiA0OCxcbiAgICBFQUREUk5PVEFWQUlMOiA0OSxcbiAgICBFQUZOT1NVUFBPUlQ6IDQ3LFxuICAgIEVBR0FJTjogMzUsXG4gICAgRUFMUkVBRFk6IDM3LFxuICAgIEVCQURGOiA5LFxuICAgIEVCQURNU0c6IDk0LFxuICAgIEVCVVNZOiAxNixcbiAgICBFQ0FOQ0VMRUQ6IDg5LFxuICAgIEVDSElMRDogMTAsXG4gICAgRUNPTk5BQk9SVEVEOiA1MyxcbiAgICBFQ09OTlJFRlVTRUQ6IDYxLFxuICAgIEVDT05OUkVTRVQ6IDU0LFxuICAgIEVERUFETEs6IDExLFxuICAgIEVERVNUQUREUlJFUTogMzksXG4gICAgRURPTTogMzMsXG4gICAgRURRVU9UOiA2OSxcbiAgICBFRVhJU1Q6IDE3LFxuICAgIEVGQVVMVDogMTQsXG4gICAgRUZCSUc6IDI3LFxuICAgIEVIT1NUVU5SRUFDSDogNjUsXG4gICAgRUlEUk06IDkwLFxuICAgIEVJTFNFUTogOTIsXG4gICAgRUlOUFJPR1JFU1M6IDM2LFxuICAgIEVJTlRSOiA0LFxuICAgIEVJTlZBTDogMjIsXG4gICAgRUlPOiA1LFxuICAgIEVJU0NPTk46IDU2LFxuICAgIEVJU0RJUjogMjEsXG4gICAgRUxPT1A6IDYyLFxuICAgIEVNRklMRTogMjQsXG4gICAgRU1MSU5LOiAzMSxcbiAgICBFTVNHU0laRTogNDAsXG4gICAgRU1VTFRJSE9QOiA5NSxcbiAgICBFTkFNRVRPT0xPTkc6IDYzLFxuICAgIEVORVRET1dOOiA1MCxcbiAgICBFTkVUUkVTRVQ6IDUyLFxuICAgIEVORVRVTlJFQUNIOiA1MSxcbiAgICBFTkZJTEU6IDIzLFxuICAgIEVOT0JVRlM6IDU1LFxuICAgIEVOT0RBVEE6IDk2LFxuICAgIEVOT0RFVjogMTksXG4gICAgRU5PRU5UOiAyLFxuICAgIEVOT0VYRUM6IDgsXG4gICAgRU5PTENLOiA3NyxcbiAgICBFTk9MSU5LOiA5NyxcbiAgICBFTk9NRU06IDEyLFxuICAgIEVOT01TRzogOTEsXG4gICAgRU5PUFJPVE9PUFQ6IDQyLFxuICAgIEVOT1NQQzogMjgsXG4gICAgRU5PU1I6IDk4LFxuICAgIEVOT1NUUjogOTksXG4gICAgRU5PU1lTOiA3OCxcbiAgICBFTk9UQ09OTjogNTcsXG4gICAgRU5PVERJUjogMjAsXG4gICAgRU5PVEVNUFRZOiA2NixcbiAgICBFTk9UU09DSzogMzgsXG4gICAgRU5PVFNVUDogNDUsXG4gICAgRU5PVFRZOiAyNSxcbiAgICBFTlhJTzogNixcbiAgICBFT1BOT1RTVVBQOiAxMDIsXG4gICAgRU9WRVJGTE9XOiA4NCxcbiAgICBFUEVSTTogMSxcbiAgICBFUElQRTogMzIsXG4gICAgRVBST1RPOiAxMDAsXG4gICAgRVBST1RPTk9TVVBQT1JUOiA0MyxcbiAgICBFUFJPVE9UWVBFOiA0MSxcbiAgICBFUkFOR0U6IDM0LFxuICAgIEVST0ZTOiAzMCxcbiAgICBFU1BJUEU6IDI5LFxuICAgIEVTUkNIOiAzLFxuICAgIEVTVEFMRTogNzAsXG4gICAgRVRJTUU6IDEwMSxcbiAgICBFVElNRURPVVQ6IDYwLFxuICAgIEVUWFRCU1k6IDI2LFxuICAgIEVXT1VMREJMT0NLOiAzNSxcbiAgICBFWERFVjogMThcbiAgfSxcbiAgc2lnbmFsczoge1xuICAgIFNJR0hVUDogMSxcbiAgICBTSUdJTlQ6IDIsXG4gICAgU0lHUVVJVDogMyxcbiAgICBTSUdJTEw6IDQsXG4gICAgU0lHVFJBUDogNSxcbiAgICBTSUdBQlJUOiA2LFxuICAgIFNJR0lPVDogNixcbiAgICBTSUdCVVM6IDEwLFxuICAgIFNJR0ZQRTogOCxcbiAgICBTSUdLSUxMOiA5LFxuICAgIFNJR1VTUjE6IDMwLFxuICAgIFNJR1NFR1Y6IDExLFxuICAgIFNJR1VTUjI6IDMxLFxuICAgIFNJR1BJUEU6IDEzLFxuICAgIFNJR0FMUk06IDE0LFxuICAgIFNJR1RFUk06IDE1LFxuICAgIFNJR0NITEQ6IDIwLFxuICAgIFNJR0NPTlQ6IDE5LFxuICAgIFNJR1NUT1A6IDE3LFxuICAgIFNJR1RTVFA6IDE4LFxuICAgIFNJR1RUSU46IDIxLFxuICAgIFNJR1RUT1U6IDIyLFxuICAgIFNJR1VSRzogMTYsXG4gICAgU0lHWENQVTogMjQsXG4gICAgU0lHWEZTWjogMjUsXG4gICAgU0lHVlRBTFJNOiAyNixcbiAgICBTSUdQUk9GOiAyNyxcbiAgICBTSUdXSU5DSDogMjgsXG4gICAgU0lHSU86IDIzLFxuICAgIFNJR0lORk86IDI5LFxuICAgIFNJR1NZUzogMTJcbiAgfSxcbiAgcHJpb3JpdHk6IHtcbiAgICBQUklPUklUWV9MT1c6IDE5LFxuICAgIFBSSU9SSVRZX0JFTE9XX05PUk1BTDogMTAsXG4gICAgUFJJT1JJVFlfTk9STUFMOiAwLFxuICAgIFBSSU9SSVRZX0FCT1ZFX05PUk1BTDogLTcsXG4gICAgUFJJT1JJVFlfSElHSDogLTE0LFxuICAgIFBSSU9SSVRZX0hJR0hFU1Q6IC0yMFxuICB9XG59O1xuXG4vLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uc1xuY29uc3QgT1MgPSB7XG4gIEVPTDogJ1xcbicsXG4gIGFyY2g6ICgpID0+IHByb2Nlc3MuYXJjaCxcbiAgY29uc3RhbnRzOiBQb3NpeENvbnN0YW50cyxcbiAgY3B1czogKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gVGkuUGxhdGZvcm0ucHJvY2Vzc29yQ291bnQ7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICBtb2RlbDogJ3Vua25vd24nLFxuICAgICAgICBzcGVlZDogMCxcbiAgICAgICAgdGltZXM6IHtcbiAgICAgICAgICB1c2VyOiAwLFxuICAgICAgICAgIG5pY2U6IDAsXG4gICAgICAgICAgc3lzOiAwLFxuICAgICAgICAgIGlkbGU6IDAsXG4gICAgICAgICAgaXJxOiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIGVuZGlhbm5lc3M6ICgpID0+IHtcbiAgICAvLyBUT0RPOiBDYWNoZSB0aGUgdmFsdWUhXG4gICAgY29uc3QgcmVzdWx0ID0gVGkuQ29kZWMuZ2V0TmF0aXZlQnl0ZU9yZGVyKCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gVGkuQ29kZWMuTElUVExFX0VORElBTikge1xuICAgICAgcmV0dXJuICdMRSc7XG4gICAgfVxuICAgIHJldHVybiAnQkUnO1xuICB9LFxuICBmcmVlbWVtOiAoKSA9PiBUaS5QbGF0Zm9ybS5hdmFpbGFibGVNZW1vcnksXG4gIGdldFByaW9yaXR5OiAoKSA9PiAwLFxuICAvLyBmYWtlIGl0XG4gIGhvbWVkaXI6ICgpID0+IFRpLkZpbGVzeXN0ZW0uYXBwbGljYXRpb25EYXRhRGlyZWN0b3J5LFxuICAvLyBmYWtlIGl0XG4gIGhvc3RuYW1lOiAoKSA9PiBUaS5QbGF0Zm9ybS5hZGRyZXNzLFxuICAvLyBmYWtlIGl0XG4gIGxvYWRhdmc6ICgpID0+IFswLCAwLCAwXSxcbiAgLy8gZmFrZSBpdFxuICBuZXR3b3JrSW50ZXJmYWNlczogKCkgPT4ge30sXG4gIC8vIEZJWE1FOiBXaGF0IGRvIHdlIGRvIGhlcmU/IFdlIG1pZ2h0IGJlIGFibGUgdG8gcGllY2Ugc29tZSBvZiB0aGlzIHRvZ2V0aGVyIHVzaW5nIFRpLlBsYXRmb3JtLm5ldG1hc2ssIFRpLlBsYXRmb3JtLmFkZHJlc3NcbiAgcGxhdGZvcm06ICgpID0+IHByb2Nlc3MucGxhdGZvcm0sXG4gIHJlbGVhc2U6ICgpID0+IFRpLlBsYXRmb3JtLnZlcnNpb24sXG4gIHNldFByaW9yaXR5OiAoKSA9PiB7fSxcbiAgLy8gbm8tb3AsIGZha2UgaXRcbiAgLyoqXG4gICAqIFRoZSBgb3MudG1wZGlyKClgIG1ldGhvZCByZXR1cm5zIGEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIG9wZXJhdGluZyBzeXN0ZW0ncyBkZWZhdWx0IGRpcmVjdG9yeSBmb3IgdGVtcG9yYXJ5IGZpbGVzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIHRtcGRpcjogKCkgPT4gVGkuRmlsZXN5c3RlbS50ZW1wRGlyZWN0b3J5LFxuICAvKipcbiAgICogVGhlIGBvcy50b3RhbG1lbSgpYCBtZXRob2QgcmV0dXJucyB0aGUgdG90YWwgYW1vdW50IG9mIHN5c3RlbSBtZW1vcnkgaW4gYnl0ZXMgYXMgYW4gaW50ZWdlci5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdG90YWxtZW06ICgpID0+IFRpLlBsYXRmb3JtLnRvdGFsTWVtb3J5LFxuICB0eXBlOiAoKSA9PiAnVW5rbm93bicsXG4gIC8vIG92ZXJyaWRkZW4gcGVyLXBsYXRmb3JtIGF0IGJvdHRvbVxuICAvKipcbiAgICogVGhlIGBvcy51cHRpbWUoKWAgbWV0aG9kIHJldHVybnMgdGhlIHN5c3RlbSB1cHRpbWUgaW4gbnVtYmVyIG9mIHNlY29uZHMuXG4gICAqIEByZXR1cm4ge2ludGVnZXJ9IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIHVwdGltZTogKCkgPT4gVGkuUGxhdGZvcm0udXB0aW1lLFxuICB1c2VySW5mbzogKCkgPT4ge1xuICAgIC8vIGZha2UgaXQhXG4gICAgcmV0dXJuIHtcbiAgICAgIHVpZDogLTEsXG4gICAgICBnaWQ6IC0xLFxuICAgICAgdXNlcm5hbWU6IFRpLlBsYXRmb3JtLnVzZXJuYW1lLFxuICAgICAgaG9tZWRpcjogVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gICAgICBzaGVsbDogbnVsbFxuICAgIH07XG4gIH1cbn07XG5cbi8vIE9uIHNwZWNpZmljIHBsYXRmb3Jtcywgb3ZlcnJpZGUgaW1wbGVtZW50YXRpb25zIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGVtXG4vLyB5ZXQgYW5kIG5lZWQgdG8gZmFrZSBpdCwgb3IgdG8gaGFjayB0aGVtXG4vLyBJJ20gYWxzbyBkb2luZyB0aGlzIGluIGJsb2NrcyB0byBhc3NpZ24gaW1wbGVtZW50YXRpb25zIHRoYXQgZG9uJ3QgbmVlZCB0byBjb25zdWx0IHBsYXRmb3JtXG4vLyB0eXBlIGF0IHJ1bnRpbWUgKGhvcGVmdWxseSBzcGVlZGluZyB1cCBleGVjdXRpb24gYXQgcnVudGltZSlcbntcbiAgT1MuY3B1cyA9ICgpID0+IFRpLlBsYXRmb3JtLmNwdXMoKTtcbiAgT1MudHlwZSA9ICgpID0+ICdMaW51eCc7XG59XG5cbmNvbnN0IHR0eSA9IHtcbiAgaXNhdHR5OiAoKSA9PiBmYWxzZSxcbiAgUmVhZFN0cmVhbTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcigndHR5LlJlYWRTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH0sXG4gIFdyaXRlU3RyZWFtOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0dHkuV3JpdGVTdHJlYW0gaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IE1PTlRIUyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnXTtcbmNvbnN0IHV0aWwgPSB7XG4gIGZvcm1hdDogZm9ybWF0JDEsXG4gIGZvcm1hdFdpdGhPcHRpb25zLFxuICBpbnNwZWN0LFxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICBpc0Jvb2xlYW46IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICBpc0J1ZmZlcjogQnVmZmVyTW9kdWxlLkJ1ZmZlci5pc0J1ZmZlcixcbiAgaXNGdW5jdGlvbjogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nLFxuICBpc051bGw6IHZhbHVlID0+IHZhbHVlID09PSBudWxsLFxuICBpc051bGxPclVuZGVmaW5lZDogdmFsdWUgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCxcbiAgaXNOdW1iZXI6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGlzT2JqZWN0OiB2YWx1ZSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnLFxuICBpc1ByaW1pdGl2ZTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGwsXG4gIGlzU3RyaW5nOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICBpc1N5bWJvbDogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyxcbiAgaXNVbmRlZmluZWQ6IHZhbHVlID0+IHZhbHVlID09PSB1bmRlZmluZWQsXG4gIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRXJyb3I6IGUgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcixcbiAgbG9nOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHRpbWUgPSBgJHtkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2RhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICAvLyBQcm9kdWNlcyBvdXRwdXQgbGlrZTogXCIyMSBGZWIgMTA6MDQ6MjMgLSBtZXNzYWdlXCJcbiAgICBjb25zb2xlLmxvZyhgJHtkYXRlLmdldERhdGUoKX0gJHtNT05USFNbZGF0ZS5nZXRNb250aCgpXX0gJHt0aW1lfSAtICR7c3RyaW5nfWApO1xuICB9LFxuICBwcmludDogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignJykpLFxuICAvLyBGSVhNRTogU2hvdWxkbid0IGFkZCB0cmFpbGluZyBuZXdsaW5lIGxpa2UgY29uc29sZS5sb2cgZG9lcyFcbiAgcHV0czogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignXFxuJykpLFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoYXJncy5qb2luKCdcXG4nKSksXG4gIGRlYnVnOiBzdHJpbmcgPT4gY29uc29sZS5lcnJvcihgREVCVUc6ICR7c3RyaW5nfWApLFxuICB0eXBlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBzdWJjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDb25zdHJ1Y3RvciBiYXNlIGNsYXNzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xudXRpbC5pbmhlcml0cyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcikge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY29uc3RydWN0b3IsICdjb25zdHJ1Y3RvcicsICdGdW5jdGlvbicpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUoc3VwZXJDb25zdHJ1Y3RvciwgJ3N1cGVyQ29uc3RydWN0b3InLCAnRnVuY3Rpb24nKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCAnc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUnLCAnT2JqZWN0Jyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyXycsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3RvclxuICB9KTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcmlnaW5hbCBvcmlnaW5hbCBmdW5jdGlvbiB0byB3cmFwIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBmaW5hbCBjYWxsYmFjayBhcmd1bWVudFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlXG4gKi9cbnV0aWwucHJvbWlzaWZ5ID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShvcmlnaW5hbCwgJ29yaWdpbmFsJywgJ0Z1bmN0aW9uJyk7XG4gIGZ1bmN0aW9uIHdyYXBwZWQoLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBvcmlnaW5hbC5jYWxsKHRoaXMsIC4uLmFyZ3MsIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBUT0RPOiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCB0byB3cmFwcGVkXG4gIC8vIFRPRE86IGhvb2sgcHJvdG90eXBlIGNoYWluIHVwIGZyb20gd3JhcHBlZCB0byBvcmlnaW5hbFxuICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSBwcm9taXNpZnkgaG9va3NcbiAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9yaWdpbmFsIG9yaWdpbmFsIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBhc3luYy9Qcm9taXNlIHJldHVybiB2YWx1ZSB0byBhIGNhbGxiYWNrIHN0eWxlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xudXRpbC5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgY29uc3QgcHJvbWlzZSA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHByb21pc2UudGhlbihyZXN1bHQgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL2Fsd2F5cy1yZXR1cm5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9uby1jYWxsYmFjay1pbi1wcm9taXNlXG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRFcnJvciA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBmYWxzeSB2YWx1ZScpO1xuICAgICAgICB3cmFwcGVkRXJyb3IucmVhc29uID0gZXJyO1xuICAgICAgICBlcnIgPSB3cmFwcGVkRXJyb3I7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2Uvbm8tY2FsbGJhY2staW4tcHJvbWlzZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgZnVuY3Rpb24gdG8gZGVwcmVjYXRlL3dyYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgbWVzc2FnZSB0byBnaXZlIHdoZW4gZGVwcmVjYXRpb24gd2FybmluZyBpcyBlbWl0dGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZSBkZXByZWNhdGlvbiBjb2RlIHRvIHVzZSB0byBncm91cCB3YXJuaW5nc1xuICogQHJldHVybnMge0Z1bmN0aW9ufSB3cmFwcGVkIGZ1bmN0aW9uXG4gKi9cbnV0aWwuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHN0cmluZywgY29kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4gZnVuYzsgLy8gc2tpcCB0aGUgd3JhcHBpbmchXG4gIH1cbiAgLy8gVE9ETzogU3VwcG9ydCBgY29kZWAgYXJndW1lbnQgYnkgdHJhY2tpbmcgYSBtYXAgb2YgY29kZXMgd2UndmUgd2FybmVkIGFib3V0XG4gIGZ1bmN0aW9uIHdyYXBwZWQoLi4uYXJncykge1xuICAgIGxldCB3YXJuZWQgPSBmYWxzZTtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhzdHJpbmcsICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8vIFRPRE86IFN1cHBvcnQgZGVidWdsb2c/IFdoYXQgaXMgb3VyIGVxdWl2YWxlbnQgb2YgcHJvY2Vzcy5lbnYoJ05PREVfREVCVUcnKT9cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbnV0aWwuZGVidWdsb2cgPSAoKSA9PiB7XG4gIHJldHVybiBub29wO1xufTtcblxuY29uc3QgREVGQVVMVF9NRVNTQUdFUyA9IHtcbiAgZGVlcFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWw6JyxcbiAgc3RyaWN0RXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgc3RyaWN0bHkgZXF1YWw6JyxcbiAgZGVlcEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbDonLFxuICBlcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGVxdWFsOicsXG4gIG5vdERlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIHN0cmljdGx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90U3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIHN0cmljdGx5IHVuZXF1YWwgdG86JyxcbiAgbm90RGVlcEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgbG9vc2VseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBsb29zZWx5IHVuZXF1YWwgdG86J1xufTtcblxuLy8gRmFrZSBlbnVtcyB0byB1c2UgaW50ZXJuYWxseVxuY29uc3QgQ09NUEFSRV9UWVBFID0ge1xuICBPYmplY3Q6IDAsXG4gIE1hcDogMSxcbiAgU2V0OiAyXG59O1xuY29uc3QgU1RSSUNUTkVTUyA9IHtcbiAgU3RyaWN0OiAwLFxuICBMb29zZTogMVxufTtcbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAvLyBGSVhNRTogR2VuZXJhdGUgdGhlIHJlc3Qgb2YgdGhlIG1lc3NhZ2Ugd2l0aCBkaWZmIG9mIGFjdHVhbC9leHBlY3RlZCFcbiAgICAgIG1lc3NhZ2UgPSBgJHtERUZBVUxUX01FU1NBR0VTW29wZXJhdG9yXX1cXG5cXG5gO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmFjdHVhbCA9IGFjdHVhbDtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nO1xuICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgfVxufVxuXG4vLyBUT0RPOiBDYW4gd2UgZGVmaW5lIEFzc2VydFN0cmljdCBhbmQgQXNzZXJ0TG9vc2UgYXMgc3ViY2xhc3NlcyBvZiBhIGJhc2UgQXNzZXJ0IGNsYXNzXG4vLyB0aGF0IGNsYXNzIGhvbGRzIGltcGxzIGZvciBzaGFyZWQgbWV0aG9kcywgc3ViY2xhc3NlcyBvdmVycmlkZSBzcGVjaWZpY1xuLy8gY29tcGFyaXNvbnMgdXNlZCAoT2JqZWN0LmlzIHZzID09PSk/XG5cbmNvbnN0IGFzc2VydCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTtcbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuYXNzZXJ0Lm9rID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgdmFsdWUgPSBhcmdzWzBdO1xuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBhcmdzWzFdO1xuICBsZXQgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gIC8vIENoZWNrIGlmIHZhbHVlICgxc3QgYXJnKSB3YXMgbm90IHN1cHBsaWVkIVxuICAvLyBIYXZlIHRvIHVzZSB1Z2x5IGhhY2sgb24gYXJncyBkZWZpbml0aW9uIHRvIGRvIHNvXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIG1lc3NhZ2UgPSAnTm8gdmFsdWUgYXJndW1lbnQgcGFzc2VkIHRvIGBhc3NlcnQub2soKWAnO1xuICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICAvLyBUT0RPOiBnZW5lcmF0ZSByZXN0IG9mIHRoZSBtZXNzYWdlLiBOb2RlIGFjdHVhbGx5IHJlYWRzIHRoZSBpbnB1dCBmaWxlISBUaGUgaGFja2VkIGJyb3dzZXJpZnkgZG9lcyBub3QgZG8gdGhpc1xuICAgIC8vIEl0IHRyZWF0ZXMgb2sgZmFpbGluZyBsaWtlIGB2YWx1ZSA9PSB0cnVlYCBmYWlsaW5nXG4gICAgbWVzc2FnZSA9ICdUaGUgZXhwcmVzc2lvbiBldmFsdWF0ZWQgdG8gYSBmYWxzeSB2YWx1ZTpcXG5cXG4nO1xuICAgIGdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHRocm93IG1lc3NhZ2U7XG4gIH1cbiAgY29uc3QgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICBhY3R1YWw6IHZhbHVlLFxuICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICc9PSdcbiAgfSk7XG4gIGVyci5nZW5lcmF0ZWRNZXNzYWdlID0gZ2VuZXJhdGVkTWVzc2FnZTtcbiAgdGhyb3cgZXJyO1xufTtcbmZ1bmN0aW9uIHRocm93RXJyb3Iob2JqKSB7XG4gIC8vIElmIG1lc3NhZ2UgaXMgYW4gRXJyb3Igb2JqZWN0LCB0aHJvdyB0aGF0IGluc3RlYWQhXG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIH1cbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5hc3NlcnQuZXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdlcXVhbCdcbiAgfSk7XG59O1xuYXNzZXJ0LnN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKE9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIC8vIHByb3ZpZGVzIFNhbWVWYWx1ZSBjb21wYXJpc29uIGZvciB1c1xuICAgIHJldHVybjtcbiAgfVxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ3N0cmljdEVxdWFsJ1xuICB9KTtcbn07XG5hc3NlcnQubm90RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdub3RFcXVhbCdcbiAgfSk7XG59O1xuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFPYmplY3QuaXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICAvLyBwcm92aWRlcyBTYW1lVmFsdWUgY29tcGFyaXNvbiBmb3IgdXNcbiAgICByZXR1cm47XG4gIH1cbiAgdGhyb3dFcnJvcih7XG4gICAgYWN0dWFsLFxuICAgIGV4cGVjdGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgb3BlcmF0b3I6ICdub3RTdHJpY3RFcXVhbCdcbiAgfSk7XG59O1xuY29uc3QgaXNQcmltaXRpdmUgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSA9PT0gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNYXB9IGFjdHVhbCBtYXAgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtNYXB9IGV4cGVjdGVkIG1hcCB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtTVFJJQ1RORVNTLkxvb3NlfHN0cmljdG5lc3MuU3RyaWN0fSBzdHJpY3RuZXNzIGhvdyB0byBjb21wYXJlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlcyBtZW1vaXplZCByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhlIGRlZXBFcXVhbCBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlTWFwcyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIGNvbnN0IGxvb3NlQ2hlY2tzID0gbmV3IFNldCgpOyAvLyBrZWVwIHRyYWNrIG9mIG9iamVjdHMgd2UgbmVlZCB0byB0ZXN0IG1vcmUgZXh0ZW5zaXZlbHkgdGhhbiB1c2luZyAjZ2V0KCkvI2hhcygpXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFjdHVhbCkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG5vbi1udWxsIG9iamVjdC4gV2UgbmVlZCB0byBkbyBvdXIgb3duIGNoZWNraW5nLCBub3QgdXNlIGdldCgpL2hhcygpXG4gICAgICBsb29zZUNoZWNrcy5hZGQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFuZGxlIFwicHJpbWl0aXZlc1wiXG4gICAgICBpZiAoZXhwZWN0ZWQuaGFzKGtleSkgJiYgZGVlcEVxdWFsKHZhbHVlLCBleHBlY3RlZC5nZXQoa2V5KSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykpIHtcbiAgICAgICAgLy8geWF5ISBhIG5pY2UgZWFzeSBtYXRjaCAtIGJvdGgga2V5IGFuZCB2YWx1ZSBtYXRjaGVkIGV4YWN0bHkgLSBtb3ZlIG9uXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBtYXRjaCBrZXkvdmFsdWUgcGVyZmVjdGx5IGluIHN0cmljdCBtb2RlLCBmYWlsIHJpZ2h0IGF3YXlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBvaywgc28gaXQgZGlkbid0IG1hdGNoIGtleS92YWx1ZSBwZXJmZWN0bHkgLSBidXQgd2UncmUgaW4gbG9vc2UgbW9kZSwgc28gZmFsbCBiYWNrIHRvIHRyeSBhZ2FpblxuICAgICAgbG9vc2VDaGVja3MuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChsb29zZUNoZWNrcy5zaXplID09PSAwKSB7XG4gICAgLy8gbm8gbG9vc2UgZW5kcyB0byB0aWUgdXAsIGV2ZXJ5dGhpbmcgbWF0Y2hlZFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gb25seSBnbyB0aHJvdWdoIHRoZSBzZWNvbmQgTWFwIG9uY2UhXG4gIGZvciAoY29uc3QgW2V4cGVjdGVkS2V5LCBleHBlY3RlZFZhbHVlXSBvZiBleHBlY3RlZCkge1xuICAgIC8vIGlmIGl0J3Mgbm90IGEgbm9uLW51bGwgb2JqZWN0IGluIHN0cmljdCBtb2RlLCBmYWlsIVxuICAgIC8vIChpLmUuIGlmIGl0J3MgYSBwcmltaXRpdmUgdGhhdCBmYWlsZWQgYSBtYXRjaCwgZG9uJ3QgZmFsbCBiYWNrIHRvIG1vcmUgbG9vc2VseSBtYXRjaCBpdClcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGRuJ3QgZXZlciBoYXBwZW4gc2luY2Ugd2Ugc2hvdWxkIGJlIHJldHVybmluZyBmYWxzZSBpbW1lZGlhdGVseSBhYm92ZVxuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCAmJiAhKHR5cGVvZiBleHBlY3RlZEtleSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWRLZXkgIT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCB0ZXN0IGl0IC8vIFRPRE86IFdpc2ggd2UgY291bGQgdXNlICNmaW5kKCkgbGlrZSBvbiBhbiBBcnJheSwgYnV0IFNldCBkb2Vzbid0IGhhdmUgaXQhXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbG9vc2VDaGVja3MpIHtcbiAgICAgIC8vIGlmIGJvdGgga2V5IGFuZCB2YWx1ZSBtYXRjaGVzXG4gICAgICBpZiAoZGVlcEVxdWFsKGtleSwgZXhwZWN0ZWRLZXksIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpICYmIGRlZXBFcXVhbChhY3R1YWwuZ2V0KGtleSksIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKGtleSk7IC8vIHJlbW92ZSBmcm9tIG91ciBsb29zZUNoZWNrcyBTZXQgc2luY2Ugd2UgYWxyZWFkeSBtYXRjaGVkIGl0XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBub3QgZm91bmQsIHdlIGZhaWxlZCB0byBtYXRjaFxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gZGlkIHdlIGxlYXZlIHVuLW1hdGNoZWQga2V5cz8gaWYgc28sIGZhaWxcbiAgcmV0dXJuIGxvb3NlQ2hlY2tzLnNpemUgPT09IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTZXR9IGFjdHVhbCBtYXAgd2UgYXJlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtTZXR9IGV4cGVjdGVkIG1hcCB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtzdHJpY3RuZXNzLkxvb3NlfHN0cmljdG5lc3MuU3RyaWN0fSBzdHJpY3RuZXNzIGhvdyB0byBjb21wYXJlXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlcyBtZW1vaXplZCByZWZlcmVuY2VzIHRvIG9iamVjdHMgaW4gdGhlIGRlZXBFcXVhbCBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlU2V0cyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIGNvbnN0IGxvb3NlQ2hlY2tzID0gbmV3IFNldCgpOyAvLyBrZWVwIHRyYWNrIG9mIHZhbHVlcyB3ZSBuZWVkIHRvIHRlc3QgbW9yZSBleHRlbnNpdmVseSB0aGFuIHVzaW5nICNoYXMoKVxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFjdHVhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBub24tbnVsbCBvYmplY3QuIFdlIG5lZWQgdG8gZG8gb3VyIG93biBjaGVja2luZywgbm90IHVzZSBoYXMoKVxuICAgICAgbG9vc2VDaGVja3MuYWRkKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCFleHBlY3RlZC5oYXModmFsdWUpKSB7XG4gICAgICAvLyBGSVhNRTogaGFzIGRvZXMgXCJzYW1lLXZhbHVlLXplcm9cIiBjaGVjaywgd2hpY2ggaXMgbGlrZSBPYmplY3QuaXMgZXhjZXB0IGZvciAtMC8rMCBiZWluZyBjb25zaWRlcmVkIGVxdWFsXG4gICAgICAvLyBzbyBtYXkgbmVlZCB0byBzcGVjaWFsIGNhc2UgdGhhdCBoZXJlLCB0aGF0J2QgaGF2ZSB0byBiZSBpbiBhbiBlbHNlIGJlbG93IChzaW5jZSBoYXMgd2lsbCByZXR1cm4gdHJ1ZSBoZXJlKVxuXG4gICAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgICAgLy8gZmFpbGVkIFwic2FtZS12YWx1ZVwiIG1hdGNoIGZvciBwcmltaXRpdmUgaW4gc3RyaWN0IG1vZGUsIHNvIGZhaWwgcmlnaHQgYXdheVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gZG9pbmcgbG9vc2UgY2hlY2ssIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIGxvb3NlciBjaGVjayB0aGFuICNoYXMoKSwgc28gd2UgY2FuJ3QganVzdCByZXR1cm4gZmFsc2UgaW1tZWRpYXRlbHkgaGVyZVxuICAgICAgLy8gYWRkIHRvIHNldCBvZiB2YWx1ZXMgdG8gY2hlY2sgbW9yZSB0aG9yb3VnaGx5XG4gICAgICBsb29zZUNoZWNrcy5hZGQodmFsdWUpO1xuICAgIH1cbiAgfVxuICBpZiAobG9vc2VDaGVja3Muc2l6ZSA9PT0gMCkge1xuICAgIC8vIG5vIGxvb3NlIGVuZHMgdG8gdGllIHVwLCBldmVyeXRoaW5nIG1hdGNoZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRyeSB0byB3aGl0dGxlIGRvd24gdGhlIGxvb3NlIGNoZWNrcyBzZXQgdG8gYmUgZW1wdHkuLi5cbiAgLy8gb25seSBnbyB0aHJvdWdoIHRoZSBzZWNvbmQgU2V0IG9uY2UhXG4gIGZvciAoY29uc3QgZXhwZWN0ZWRWYWx1ZSBvZiBleHBlY3RlZCkge1xuICAgIC8vIGlmIGl0J3Mgbm90IGEgbm9uLW51bGwgb2JqZWN0IGluIHN0cmljdCBtb2RlLCBmYWlsIVxuICAgIC8vIChpLmUuIGlmIGl0J3MgYSBwcmltaXRpdmUgdGhhdCBmYWlsZWQgYSBtYXRjaCwgZG9uJ3QgZmFsbCBiYWNrIHRvIG1vcmUgbG9vc2VseSBtYXRjaCBpdClcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGRuJ3QgZXZlciBoYXBwZW4gc2luY2Ugd2Ugc2hvdWxkIGJlIHJldHVybmluZyBmYWxzZSBpbW1lZGlhdGVseSBhYm92ZVxuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCAmJiAhKHR5cGVvZiBleHBlY3RlZFZhbHVlID09PSAnb2JqZWN0JyAmJiBleHBlY3RlZFZhbHVlICE9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBsb29zZUNoZWNrcykge1xuICAgICAgaWYgKGRlZXBFcXVhbChvYmplY3QsIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgLy8gZm91bmQgYSBtYXRjaCFcbiAgICAgICAgbG9vc2VDaGVja3MuZGVsZXRlKG9iamVjdCk7IC8vIHJlbW92ZSBmcm9tIG91ciBsb29zZUNoZWNrcyBTZXQgc2luY2Ugd2UgbWF0Y2hlZCBpdFxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm90IGZvdW5kLCB3ZSBmYWlsZWQgdG8gbWF0Y2hcbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gZGlkIHdlIGxlYXZlIHVuLW1hdGNoZWQgdmFsdWVzPyBpZiBzbywgZmFpbFxuICByZXR1cm4gbG9vc2VDaGVja3Muc2l6ZSA9PT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyp9IGFjdHVhbCB2YWx1ZSB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0geyp9IGV4cGVjdGVkIHZhbHVlcyB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtTVFJJQ1RORVNTLlN0cmljdHxTVFJJQ1RORVNTLkxvb3NlfSBzdHJpY3RuZXNzIGhvdyBzdHJpY3QgYSBjb21wYXJpc29uIHRvIGRvXG4gKiBAcGFyYW0ge29iamVjdH0gW3JlZmVyZW5jZXNdIG9wdGlvbmFsIG9iamVjdCB0byBrZWVwIHRyYWNrIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gdGhlIGhpZXJhcmNoeVxuICogQHBhcmFtIHtNYXA8b2JqZWN0LG51bWJlcj59IFtyZWZlcmVuY2VzLmFjdHVhbF0gbWFwcGluZyBmcm9tIG9iamVjdHMgdmlzaXRlZCAob24gYGFjdHVhbGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge01hcDxvYmplY3QsbnVtYmVyPn0gW3JlZmVyZW5jZXMuZXhwZWN0ZWRdIG1hcHBpbmcgZnJvbSBvYmplY3RzIHZpc2l0ZWQgKG9uIGBleHBlY3RlZGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge251bWJlcn0gW3JlZmVyZW5jZXMuZGVwdGhdIFRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykge1xuICAvLyBpZiBwcmltaXRpdmVzLCBjb21wYXJlIHVzaW5nIE9iamVjdC5pc1xuICAvLyBUaGlzIGhhbmRsZXM6IG51bGwsIHVuZGVmaW5lZCwgbnVtYmVyLCBzdHJpbmcsIGJvb2xlYW5cbiAgaWYgKGlzUHJpbWl0aXZlKGFjdHVhbCkgJiYgaXNQcmltaXRpdmUoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmlzKGFjdHVhbCwgZXhwZWN0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyB3ZSBoYXZlIHZhcmlvdXMgb2JqZWN0cy9mdW5jdGlvbnM6XG4gIC8vIERhdGUsIEVycm9yLCBSZWdFeHAsIEFycmF5LCBNYXAsIFNldCwgT2JqZWN0LCBGdW5jdGlvbiwgQXJyb3cgZnVuY3Rpb25zLCBXZWFrTWFwLCBEYXRhVmlldywgQXJyYXlCdWZmZXIsIFdlYWtTZXQsIHR5cGVkIGFycmF5c1xuICAvLyBub3RhYmx5LCB0aGlzIGluY2x1ZGVzIFwiYm94ZWRcIiBwcmltaXRpdmVzIGNyZWF0ZWQgYnkgbmV3IEJvb2xlYW4oZmFsc2UpLCBuZXcgU3RyaW5nKCd2YWx1ZScpLCBTeW1ib2woJ3doYXRldmVyJyksIGV0Y1xuXG4gIC8vIFR5cGUgdGFncyBvZiBvYmplY3RzIHNob3VsZCBiZSB0aGUgc2FtZVxuICBjb25zdCBhY3R1YWxUYWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYWN0dWFsKTtcbiAgY29uc3QgZXhwZWN0ZWRUYWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpO1xuICBpZiAoYWN0dWFsVGFnICE9PSBleHBlY3RlZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFtbUHJvdG90eXBlXV0gb2Ygb2JqZWN0cyBhcmUgY29tcGFyZWQgdXNpbmcgdGhlIFN0cmljdCBFcXVhbGl0eSBDb21wYXJpc29uLlxuICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAvLyBkb24ndCBjaGVjayBwcm90b3R5cGUgd2hlbiBkb2luZyBcImxvb3NlXCJcbiAgICBjb25zdCBhY3R1YWxQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYWN0dWFsKTtcbiAgICBjb25zdCBleHBlY3RlZFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihleHBlY3RlZCk7XG4gICAgaWYgKGFjdHVhbFByb3RvdHlwZSAhPT0gZXhwZWN0ZWRQcm90b3R5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvbXBhcmlzb24gPSBDT01QQVJFX1RZUEUuT2JqZWN0O1xuICBpZiAodXRpbC50eXBlcy5pc1JlZ0V4cChhY3R1YWwpKSB7XG4gICAgLy8gUmVnRXhwIHNvdXJjZSBhbmQgZmxhZ3Mgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzUmVnRXhwKGV4cGVjdGVkKSB8fCBhY3R1YWwuZmxhZ3MgIT09IGV4cGVjdGVkLmZsYWdzIHx8IGFjdHVhbC5zb3VyY2UgIT09IGV4cGVjdGVkLnNvdXJjZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0RhdGUoYWN0dWFsKSkge1xuICAgIC8vIERhdGUncyB1bmRlcmx5aW5nIHRpbWUgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzRGF0ZShleHBlY3RlZCkgfHwgYWN0dWFsLmdldFRpbWUoKSAhPT0gZXhwZWN0ZWQuZ2V0VGltZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIEVycm9yJ3MgbmFtZSBhbmQgbWVzc2FnZSBtdXN0IG1hdGNoXG4gICAgaWYgKCEoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikgfHwgYWN0dWFsLm5hbWUgIT09IGV4cGVjdGVkLm5hbWUgfHwgYWN0dWFsLm1lc3NhZ2UgIT09IGV4cGVjdGVkLm1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWN0dWFsKSkge1xuICAgIC8vIGlmIGFycmF5IGxlbmd0aHMgZGlmZmVyLCBxdWljayBmYWlsXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSB8fCBhY3R1YWwubGVuZ3RoICE9PSBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShhY3R1YWwpKSB7XG4gICAgaWYgKCF1dGlsLnR5cGVzLmlzQm94ZWRQcmltaXRpdmUoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNoZWNrIHRoYXQgdGhleSdyZSB0aGUgc2FtZSB0eXBlIG9mIHdyYXBwZWQgcHJpbWl0aXZlIGFuZCB0aGVuIGNhbGwgdGhlIHJlbGV2YW50IHZhbHVlT2YoKSBmb3IgdGhhdCB0eXBlIHRvIGNvbXBhcmUgdGhlbSFcbiAgICBpZiAodXRpbC50eXBlcy5pc051bWJlck9iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc051bWJlck9iamVjdChleHBlY3RlZCkgfHwgIU9iamVjdC5pcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpLCBOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc1N0cmluZ09iamVjdChhY3R1YWwpICYmICghdXRpbC50eXBlcy5pc1N0cmluZ09iamVjdChleHBlY3RlZCkgfHwgU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSAhPT0gU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0Jvb2xlYW5PYmplY3QoYWN0dWFsKSAmJiAoIXV0aWwudHlwZXMuaXNCb29sZWFuT2JqZWN0KGV4cGVjdGVkKSB8fCBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSAhPT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIEZJWE1FOiBVbmNvbW1lbnQgd2hlbiB3ZSBzdXBwb3J0IEJpZ0ludCBjcm9zcy1wbGF0Zm9ybSFcbiAgICAgIC8vIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0JpZ0ludE9iamVjdChhY3R1YWwpXG4gICAgICAvLyBcdCYmICghdXRpbC50eXBlcy5pc0JpZ0ludE9iamVjdChleHBlY3RlZClcbiAgICAgIC8vIFx0XHR8fCBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICAvLyBcdHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNTeW1ib2xPYmplY3QoYWN0dWFsKSAmJiAoIXV0aWwudHlwZXMuaXNTeW1ib2xPYmplY3QoZXhwZWN0ZWQpIHx8IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCkgIT09IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNTZXQoYWN0dWFsKSkge1xuICAgIGlmICghdXRpbC50eXBlcy5pc1NldChleHBlY3RlZCkgfHwgYWN0dWFsLnNpemUgIT09IGV4cGVjdGVkLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5TZXQ7XG4gICAgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNNYXAoYWN0dWFsKSkge1xuICAgIGlmICghdXRpbC50eXBlcy5pc01hcChleHBlY3RlZCkgfHwgYWN0dWFsLnNpemUgIT09IGV4cGVjdGVkLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29tcGFyaXNvbiA9IENPTVBBUkVfVFlQRS5NYXA7XG4gICAgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9XG5cbiAgLy8gTm93IGl0ZXJhdGUgb3ZlciBwcm9wZXJ0aWVzIGFuZCBjb21wYXJlIHRoZW0hXG4gIGNvbnN0IGFjdHVhbEtleXMgPSBPYmplY3Qua2V5cyhhY3R1YWwpOyAvLyBmb3IgYW4gYXJyYXksIHRoaXMgd2lsbCByZXR1cm4gdGhlIGluZGljZXMgdGhhdCBoYXZlIHZhbHVlc1xuICBjb25zdCBleHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIGFuZCBpdCBqdXN0IG1hZ2ljYWxseSB3b3Jrc1xuICAvLyBNdXN0IGhhdmUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICBpZiAoYWN0dWFsS2V5cy5sZW5ndGggIT09IGV4cGVjdGVkS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBBcmUgdGhleSB0aGUgc2FtZSBrZXlzPyBJZiBvbmUgaXMgbWlzc2luZywgdGhlbiBubywgZmFpbCByaWdodCBhd2F5XG4gIGlmICghYWN0dWFsS2V5cy5ldmVyeShrZXkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cGVjdGVkLCBrZXkpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIERvbid0IGNoZWNrIG93biBzeW1ib2xzIHdoZW4gZG9pbmcgXCJsb29zZVwiXG4gIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgIGNvbnN0IGFjdHVhbFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGFjdHVhbCk7XG4gICAgY29uc3QgZXhwZWN0ZWRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhleHBlY3RlZCk7XG5cbiAgICAvLyBNdXN0IGhhdmUgc2FtZSBudW1iZXIgb2Ygc3ltYm9sc1xuICAgIGlmIChhY3R1YWxTeW1ib2xzLmxlbmd0aCAhPT0gZXhwZWN0ZWRTeW1ib2xzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWN0dWFsU3ltYm9scy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBIYXZlIHRvIGZpbHRlciB0aGVtIGRvd24gdG8gZW51bWVyYWJsZSBzeW1ib2xzIVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWN0dWFsU3ltYm9scykge1xuICAgICAgICBjb25zdCBhY3R1YWxJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoYWN0dWFsLCBrZXkpO1xuICAgICAgICBjb25zdCBleHBlY3RlZElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChleHBlY3RlZCwga2V5KTtcbiAgICAgICAgaWYgKGFjdHVhbElzRW51bWVyYWJsZSAhPT0gZXhwZWN0ZWRJc0VudW1lcmFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHRoZXkgZGlmZmVyIG9uIHdoZXRlaHIgc3ltYm9sIGlzIGVudW1lcmFibGUsIGZhaWwhXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsSXNFbnVtZXJhYmxlKSB7XG4gICAgICAgICAgLy8gaXQncyBlbnVtZXJhYmxlLCBhZGQgdG8ga2V5cyB0byBjaGVja1xuICAgICAgICAgIGFjdHVhbEtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGV4cGVjdGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIVxuICAvLyBSZWNvcmQgbWFwIGZyb20gb2JqZWN0cyB0byBkZXB0aCBpbiB0aGUgaGllcmFyY2h5XG4gIGlmIChyZWZlcmVuY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICByZWZlcmVuY2VzID0ge1xuICAgICAgYWN0dWFsOiBuZXcgTWFwKCksXG4gICAgICBleHBlY3RlZDogbmV3IE1hcCgpLFxuICAgICAgZGVwdGg6IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHJlY29yZGVkIHRoZXNlIG9iamVjdHMuXG4gICAgLy8gaWYgc28sIG1ha2Ugc3VyZSB0aGV5IHJlZmVyIHRvIHNhbWUgZGVwdGggaW4gb2JqZWN0IGhpZXJhcmNoeVxuICAgIGNvbnN0IG1lbW9pemVkQWN0dWFsID0gcmVmZXJlbmNlcy5hY3R1YWwuZ2V0KGFjdHVhbCk7XG4gICAgaWYgKG1lbW9pemVkQWN0dWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG1lbW9pemVkRXhwZWN0ZWQgPSByZWZlcmVuY2VzLmV4cGVjdGVkLmdldChleHBlY3RlZCk7XG4gICAgICBpZiAobWVtb2l6ZWRFeHBlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtZW1vaXplZEFjdHVhbCA9PT0gbWVtb2l6ZWRFeHBlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVmZXJlbmNlcy5kZXB0aCsrO1xuICB9XG4gIC8vIHN0b3JlIHRoZSBvYmplY3QgLT4gZGVwdGggbWFwcGluZ1xuICByZWZlcmVuY2VzLmFjdHVhbC5zZXQoYWN0dWFsLCByZWZlcmVuY2VzLmRlcHRoKTtcbiAgcmVmZXJlbmNlcy5leHBlY3RlZC5zZXQoZXhwZWN0ZWQsIHJlZmVyZW5jZXMuZGVwdGgpO1xuXG4gIC8vIFdoZW4gY29tcGFyaW5nIE1hcHMvU2V0cywgY29tcGFyZSBlbGVtZW50cyBiZWZvcmUgY3VzdG9tIHByb3BlcnRpZXNcbiAgbGV0IHJlc3VsdCA9IHRydWU7XG4gIGlmIChjb21wYXJpc29uID09PSBDT01QQVJFX1RZUEUuU2V0KSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZVNldHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcyk7XG4gIH0gZWxzZSBpZiAoY29tcGFyaXNvbiA9PT0gQ09NUEFSRV9UWVBFLk1hcCkge1xuICAgIHJlc3VsdCA9IGNvbXBhcmVNYXBzKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpO1xuICB9XG4gIGlmIChyZXN1bHQpIHtcbiAgICAvLyBOb3cgbG9vcCBvdmVyIGtleXMgYW5kIGNvbXBhcmUgdGhlbSB0byBlYWNoIG90aGVyIVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGFjdHVhbEtleXMpIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGFjdHVhbFtrZXldLCBleHBlY3RlZFtrZXldLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHdpcGUgdGhlIG9iamVjdCB0byBkZXB0aCBtYXBwaW5nIGZvciB0aGVzZSBvYmplY3RzIG5vd1xuICByZWZlcmVuY2VzLmFjdHVhbC5kZWxldGUoYWN0dWFsKTtcbiAgcmVmZXJlbmNlcy5leHBlY3RlZC5kZWxldGUoZXhwZWN0ZWQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuU3RyaWN0KSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgfSk7XG4gIH1cbn07XG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBTVFJJQ1RORVNTLlN0cmljdCkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcFN0cmljdEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuYXNzZXJ0LmRlZXBFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuTG9vc2UpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ2RlZXBFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcbmFzc2VydC5ub3REZWVwRXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuTG9vc2UpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcbmFzc2VydC5mYWlsID0gKG1lc3NhZ2UgPSAnRmFpbGVkJykgPT4gdGhyb3dFcnJvcih7XG4gIG1lc3NhZ2Vcbn0pO1xuY29uc3QgTk9fRVhDRVBUSU9OID0ge307XG5mdW5jdGlvbiBleGVjdXRlKGZuKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmbiwgJ2ZuJywgJ0Z1bmN0aW9uJyk7XG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiBOT19FWENFUFRJT047XG59XG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKGZuKSB7XG4gIHJldHVybiB1dGlsLnR5cGVzLmlzUHJvbWlzZShmbikgfHwgZm4gJiYgdHlwZW9mIGZuID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZm4udGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlKGZuKSB7XG4gIGxldCBwcm9taXNlO1xuICBjb25zdCBmblR5cGUgPSB0eXBlb2YgZm47XG4gIGlmIChmblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9taXNlID0gZm4oKTtcbiAgICBpZiAoIWlzUHJvbWlzZUxpa2UocHJvbWlzZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGluc3RhbmNlb2YgUHJvbWlzZSB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcImZuXCIgZnVuY3Rpb24gYnV0IGdvdCAke3R5cGVvZiBwcm9taXNlfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzUHJvbWlzZUxpa2UoZm4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJmblwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbiBvciBQcm9taXNlLiBSZWNlaXZlZCB0eXBlICR7Zm5UeXBlfWApO1xuICAgIH1cbiAgICBwcm9taXNlID0gZm47XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIE5PX0VYQ0VQVElPTjtcbn1cbmFzc2VydC50aHJvd3MgPSAoZm4sIGVycm9yLCBtZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGV4ZWN1dGUoZm4pO1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAvLyBGSVhNRTogYXBwZW5kIG1lc3NhZ2UgaWYgbm90IG51bGxcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgbWVzc2FnZTogJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uLicsXG4gICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByb2xsIHdpdGggaXRcbiAgaWYgKCFlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkpIHtcbiAgICB0aHJvdyBhY3R1YWw7IC8vIHRocm93IHRoZSBFcnJvciBpdCBkaWQgZ2VuZXJhdGVcbiAgfVxufTtcblxuYXNzZXJ0LnJlamVjdHMgPSBhc3luYyBmdW5jdGlvbiAoYXN5bmNGbiwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgY29uc3QgYWN0dWFsID0gYXdhaXQgZXhlY3V0ZVByb21pc2UoYXN5bmNGbik7XG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIC8vIEZJWE1FOiBhcHBlbmQgbWVzc2FnZSBpZiBub3QgbnVsbFxuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24uJyxcbiAgICAgIG9wZXJhdG9yOiAncmVqZWN0cydcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByb2xsIHdpdGggaXRcbiAgaWYgKCFlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkpIHtcbiAgICB0aHJvdyBhY3R1YWw7IC8vIHRocm93IHRoZSBFcnJvciBpdCBkaWQgZ2VuZXJhdGVcbiAgfVxufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IChmbiwgZXJyb3IsIG1lc3NhZ2UpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gZXhlY3V0ZShmbik7XG4gIC8vIG5vIEVycm9yLCBqdXN0IHJldHVyblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByZS10aHJvd1xuICBpZiAoIWVycm9yKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG5cbiAgLy8gSWYgZXJyb3IgbWF0Y2hlcyBleHBlY3RlZCwgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcbiAgaWYgKGNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvcikpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiAnZG9lc05vdFRocm93JyxcbiAgICAgIG1lc3NhZ2U6IGBHb3QgdW53YW50ZWQgZXhjZXB0aW9uJHttZXNzYWdlID8gJzogJyArIG1lc3NhZ2UgOiAnLid9YFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBkb2Vzbid0IG1hdGNoLCByZS10aHJvd1xuICB0aHJvdyBhY3R1YWw7XG59O1xuYXNzZXJ0LmRvZXNOb3RSZWplY3QgPSBhc3luYyBmdW5jdGlvbiAoZm4sIGVycm9yLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGFjdHVhbCA9IGF3YWl0IGV4ZWN1dGVQcm9taXNlKGZuKTtcbiAgLy8gbm8gRXJyb3IsIGp1c3QgcmV0dXJuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXkgZGlkbid0IHNwZWNpZnkgaG93IHRvIHZhbGlkYXRlLCBzbyBqdXN0IHJlLXRocm93XG4gIGlmICghZXJyb3IpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cblxuICAvLyBJZiBlcnJvciBtYXRjaGVzIGV4cGVjdGVkLCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuICBpZiAoY2hlY2tFcnJvcihhY3R1YWwsIGVycm9yKSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6ICdkb2VzTm90VGhyb3cnLFxuICAgICAgbWVzc2FnZTogYEdvdCB1bndhbnRlZCBleGNlcHRpb24ke21lc3NhZ2UgPyAnOiAnICsgbWVzc2FnZSA6ICcuJ31gXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGRvZXNuJ3QgbWF0Y2gsIHJlLXRocm93XG4gIHRocm93IGFjdHVhbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gYWN0dWFsIHRoZSBhY3R1YWwgRXJyb3IgZ2VuZXJhdGVkIGJ5IHRoZSB3cmFwcGVkIGZ1bmN0aW9uL2Jsb2NrXG4gKiBAcGFyYW0ge29iamVjdHxSZWdFeHB8RnVuY3Rpb258RXJyb3J8Q2xhc3N9IGV4cGVjdGVkIFRoZSB2YWx1ZSB0byB0ZXN0IGFnYWluc3QgdGhlIEVycm9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW21lc3NhZ2VdIGN1c3RvbSBtZXNzYWdlIHRvIGFwcGVuZFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIEVycm9yIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHZhbHVlL29iamVjdFxuICovXG5mdW5jdGlvbiBjaGVja0Vycm9yKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgLy8gV2hhdCB3ZSBkbyBoZXJlIGRlcGVuZHMgb24gd2hhdCBgZXhwZWN0ZWRgIGlzOlxuICAvLyBmdW5jdGlvbiAtIGNhbGwgaXQgdG8gdmFsaWRhdGVcbiAgLy8gb2JqZWN0IC0gdGVzdCBwcm9wZXJ0aWVzIGFnYWluc3QgYWN0dWFsXG4gIC8vIFJlZ2V4cCAtIHRlc3QgYWdhaW5zdCBhY3R1YWwudG9TdHJpbmcoKVxuICAvLyBFcnJvciB0eXBlIC0gY2hlY2sgdHlwZSBtYXRjaGVzXG4gIC8vIEVycm9yIGluc3RhbmNlIC0gY29tcGFyZSBwcm9wZXJ0aWVzXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHV0aWwudHlwZXMuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBkb2VzIHRoZSBlcnJvciBtYXRjaCB0aGUgUmVnRXhwIGV4cHJlc3Npb24/IGlmIHNvLCBwYXNzXG4gICAgfVxuXG4gICAgLy8gVGVzdCBwcm9wZXJ0aWVzIChgZXhwZWN0ZWRgIGlzIGVpdGhlciBhIGdlbmVyaWMgT2JqZWN0IG9yIGFuIEVycm9yIGluc3RhbmNlKVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7XG4gICAgLy8gSWYgd2UncmUgdGVzdGluZyBhZ2FpbnN0IGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLCB3ZSBuZWVkIHRvIGhhY2sgaW4gbmFtZS9tZXNzYWdlIHByb3BlcnRpZXMuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMudW5zaGlmdCgnbmFtZScsICdtZXNzYWdlJyk7IC8vIHdlIHdhbnQgdG8gY29tcGFyZSBuYW1lIGFuZCBtZXNzYWdlLCBidXQgdGhleSdyZSBub3Qgc2V0IGFzIGVudW1lcmFibGUgb24gRXJyb3JcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIC8vIGdlbmVyYXRlIGEgbWVhbmluZ2Z1bCBtZXNzYWdlISBDaGVhdCBieSB0cmVhdGluZyBsaWtlIGVxdWFsaXR5IGNoZWNrIG9mIHZhbHVlc1xuICAgICAgICAgIC8vIHRoZW4gc3RlYWwgdGhlIG1lc3NhZ2UgaXQgZ2VuZXJhdGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe1xuICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFtrZXldLFxuICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRba2V5XSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFcnJvcih7XG4gICAgICAgICAgYWN0dWFsLFxuICAgICAgICAgIGV4cGVjdGVkLFxuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgb3BlcmF0b3I6ICd0aHJvd3MnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlOyAvLyBUaGV5IGFsbCBtYXRjaGVkLCBwYXNzIVxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGlmIGBleHBlY3RlZGAgaXMgYSBcInR5cGVcIiBhbmQgYWN0dWFsIGlzIGFuIGluc3RhbmNlIG9mIHRoYXQgdHlwZSwgdGhlbiBwYXNzXG4gICAgaWYgKGV4cGVjdGVkLnByb3RvdHlwZSAhPSBudWxsICYmIGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgZXhwZWN0ZWRgIGlzIGEgc3ViY2xhc3Mgb2YgRXJyb3IgYnV0IGBhY3R1YWxgIHdhc24ndCBhbiBpbnN0YW5jZSBvZiBpdCAoYWJvdmUpLCBmYWlsXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKEVycm9yLCBleHBlY3RlZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvaywgbGV0J3MgYXNzdW1lIHdoYXQncyBsZWZ0IGlzIHRoYXQgYGV4cGVjdGVkYCB3YXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLFxuICAgIC8vIHNvIGNhbGwgaXQgd2l0aCBlbXB0eSBgdGhpc2AgYW5kIHNpbmdsZSBhcmd1bWVudCBvZiB0aGUgYWN0dWFsIGVycm9yIHdlIHJlY2VpdmVkXG4gICAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuYXNzZXJ0LmlmRXJyb3IgPSB2YWx1ZSA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbDogdmFsdWUsXG4gICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgbWVzc2FnZTogYGlmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJHt2YWx1ZX1gLFxuICAgIG9wZXJhdG9yOiAnaWZFcnJvcidcbiAgfSk7XG59O1xuXG4vLyBDcmVhdGUgXCJzdHJpY3RcIiBjb3B5IHdoaWNoIG92ZXJyaWRlcyBcImxvb3NlXCIgbWV0aG9kcyB0byBjYWxsIHN0cmljdCBlcXVpdmFsZW50c1xuYXNzZXJ0LnN0cmljdCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0Lm9rKHZhbHVlLCBtZXNzYWdlKTtcbi8vIFwiQ29weVwiIG1ldGhvZHMgZnJvbSBhc3NlcnQgdG8gYXNzZXJ0LnN0cmljdCFcbk9iamVjdC5hc3NpZ24oYXNzZXJ0LnN0cmljdCwgYXNzZXJ0KTtcbi8vIE92ZXJyaWRlIHRoZSBcImxvb3NlXCIgbWV0aG9kcyB0byBwb2ludCB0byB0aGUgc3RyaWN0IG9uZXNcbmFzc2VydC5zdHJpY3QuZGVlcEVxdWFsID0gYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbDtcbmFzc2VydC5zdHJpY3Qubm90RGVlcEVxdWFsID0gYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbDtcbmFzc2VydC5zdHJpY3QuZXF1YWwgPSBhc3NlcnQuc3RyaWN0RXF1YWw7XG5hc3NlcnQuc3RyaWN0Lm5vdEVxdWFsID0gYXNzZXJ0Lm5vdFN0cmljdEVxdWFsO1xuLy8gaGFuZyBzdHJpY3Qgb2ZmIGl0c2VsZlxuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIHRoZSBgU3RyaW5nRGVjb2RlcmAgd2lsbCB1c2UuXG4gKi9cbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgVXRmOFN0cmluZ0RlY29kZXIoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNi1sZSc6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IFV0ZjE2U3RyaW5nRGVjb2RlcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgQmFzZTY0U3RyaW5nRGVjb2RlcigpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgU3RyaW5nRGVjb2RlckltcGwodGhpcy5lbmNvZGluZyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW55IHJlbWFpbmluZyBpbnB1dCBzdG9yZWQgaW4gdGhlIGludGVybmFsIGJ1ZmZlciBhcyBhIHN0cmluZy5cbiAqIEJ5dGVzIHJlcHJlc2VudGluZyBpbmNvbXBsZXRlIFVURi04IGFuZCBVVEYtMTYgY2hhcmFjdGVycyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggc3Vic3RpdHV0aW9uXG4gKiBjaGFyYWN0ZXJzIGFwcHJvcHJpYXRlIGZvciB0aGUgY2hhcmFjdGVyIGVuY29kaW5nLlxuICpcbiAqIElmIHRoZSBidWZmZXIgYXJndW1lbnQgaXMgcHJvdmlkZWQsIG9uZSBmaW5hbCBjYWxsIHRvIHN0cmluZ0RlY29kZXIud3JpdGUoKSBpcyBwZXJmb3JtZWQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVtYWluaW5nIGlucHV0LlxuICogQHBhcmFtIHtCdWZmZXJ9IFtidWZmZXJdIGNvbnRhaW5pbmcgdGhlIGJ5dGVzIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMuX2ltcGwuZW5kKGJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBkZWNvZGVkIHN0cmluZywgZW5zdXJpbmcgdGhhdCBhbnkgaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVycyBhdCB0aGUgZW5kIG9mIHRoZSBCdWZmZXIsIG9yXG4gKiBUeXBlZEFycmF5LCBvciBEYXRhVmlldyBhcmUgb21pdHRlZCBmcm9tIHRoZSByZXR1cm5lZCBzdHJpbmcgYW5kIHN0b3JlZCBpbiBhbiBpbnRlcm5hbCBidWZmZXIgZm9yIHRoZVxuICogbmV4dCBjYWxsIHRvIHN0cmluZ0RlY29kZXIud3JpdGUoKSBvciBzdHJpbmdEZWNvZGVyLmVuZCgpLlxuICogQHBhcmFtIHtCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld30gYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGJ5dGVzIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbiAgLy8gZW1wdHkgc3RyaW5nIGZvciBlbXB0eSBidWZmZXJcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ltcGwud3JpdGUoYnVmZmVyKTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcy4gV2Ugb3ZlcnJpZGUgcGFydHMgb2YgaXQgZm9yIGNlcnRhaW4gZW5jb2RpbmdzLiBGb3IgYXNjaWkvaGV4L2JpbmFyeS9sYXRpbjEgdGhlIGltcGwgaXMgc3VwZXItZWFzeVxuICovXG5jbGFzcyBTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAxO1xuICB9XG5cbiAgLy8gdGhlIGFjdHVhbCB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uIVxuICBlbmQoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZShidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgd3JpdGUoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBzaW5nbGUgYnl0ZSBjaGFyYWN0ZXIgZW5jb2RpbmdzIGFyZSBhIGNpbmNoXG4gICAgfVxuXG4gICAgcmV0dXJuICcnOyAvLyBubyBidWZmZXIsIG9yIGVtcHR5XG4gIH1cbn1cblxuLy8gRm9yIG11bHRpLWJ5dGUgZW5jb2RpbmdzLCBsZXQncyBpbXBsZW1lbnQgc29tZSBiYXNlIGxvZ2ljLi4uXG5jbGFzcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCBleHRlbmRzIFN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoZW5jb2RpbmcsIGJ5dGVzUGVyQ2hhcikge1xuICAgIHN1cGVyKGVuY29kaW5nKTtcbiAgICB0aGlzLmluY29tcGxldGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXNQZXJDaGFyKTsgLy8gdGVtcG9yYXJ5IGluY29tcGxldGUgY2hhcmFjdGVyIGJ1ZmZlclxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEluY29tcGxldGVDaGFyT2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gYnl0ZXNOZWVkZWQgYnl0ZXMgbWlzc2luZyB0byBjb21wbGV0ZSB0aGUgY2hhcmFjdGVyXG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gY2hhckxlbmd0aCBieXRlcyBleHBlY3RlZCB0byBjb21wbGV0ZSB0aGUgY2hhcmFjdGVyXG4gICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXggbG9jYXRpb24gaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgY2hhcmFjdGVyIHN0YXJ0c1xuICAgKi9cblxuICAvKipcbiAgICogR2l2ZW4gYSBCdWZmZXIsIHNlZXMgaWYgd2UgaGF2ZSBhbiBpbmNvbXBsZXRlIFwiY2hhcmFjdGVyXCIgYXQgdGhlIGVuZCBvZiBpdC5cbiAgICogUmV0dXJucyBpbmZvIG9uIHRoYXQ6XG4gICAqIC0gYnl0ZXNOZWVkZWQ6IDAtMywgbnVtYmVyIG9mIGJ5dGVzIHN0aWxsIHJlbWFpbmluZ1xuICAgKiAtIGNoYXJMZW5ndGg6IGV4cGVjdGVkIG51bWJlciBvZiBieXRlcyBmb3IgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAqIC0gaW5kZXg6IGluZGV4IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJlZ2luc1xuICAgKiBAcGFyYW0ge0J1ZmZlcn0gX2J1ZmZlciBCdWZmZXIgd2UgYXJlIGNoZWNraW5nIHRvIHNlZSBpZiBpdCBoYXMgYW4gaW5jb21wZWx0ZSBcImNoYXJhY3RlclwiIGF0IHRoZSBlbmRcbiAgICovXG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhfYnVmZmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cbiAgX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCkge1xuICAgIC8vIHR5cGljYWxseSB3ZSByZXNldCBieXRlIGNvdW50IGJhY2sgdG8gMCBhbmQgY2hhcmFjdGVyIGxlbmd0aCB0byAxXG4gICAgdGhpcy5ieXRlQ291bnQgPSAwO1xuICAgIHRoaXMuY2hhckxlbmd0aCA9IDE7XG4gIH1cbiAgZW5kKGJ1ZmZlcikge1xuICAgIGxldCByZXN1bHQgPSBzdXBlci5lbmQoYnVmZmVyKTtcbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIGhhdmUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJzIVxuICAgICAgcmVzdWx0ICs9IHRoaXMuX2luY29tcGxldGVFbmQoKTtcbiAgICB9XG4gICAgdGhpcy5faW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQoKTsgLy8gcmVzZXQgb3VyIGludGVybmFscyB0byBcIndpcGVcIiB0aGUgaW5jb21wbGV0ZSBidWZmZXJcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHdyaXRlKGJ1ZmZlcikge1xuICAgIC8vIGZpcnN0IGxldCdzIHNlZSBpZiB3ZSBoYWQgc29tZSBtdWx0aS1ieXRlIGNoYXJhY3RlciB3ZSBkaWRuJ3QgZmluaXNoLi4uXG4gICAgbGV0IGNoYXIgPSAnJztcbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIHN0aWxsIG5lZWRlZCBzb21lIGJ5dGVzIHRvIGZpbmlzaCB0aGUgY2hhcmFjdGVyXG4gICAgICAvLyBIb3cgbWFueSBieXRlcyBkbyB3ZSBzdGlsbCBuZWVkPyBjaGFyTGVuZ3RoIC0gYnl0ZXMgd2UgcmVjZWl2ZWRcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmJ5dGVDb3VudDsgLy8gbmVlZCA0LCBoYXZlIDE/IHRoZW4gd2UgaGF2ZSAzIFwibGVmdFwiXG5cbiAgICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gTWF0aC5taW4obGVmdCwgYnVmZmVyLmxlbmd0aCk7IC8vIGNvcHkgdXAgdG8gdGhhdCBtYW55IGJ5dGVzXG4gICAgICAvLyBjb3B5IGJ5dGVzIGZyb20gYGJ1ZmZlcmAgdG8gb3VyIGluY29tcGxldGUgYnVmZmVyXG4gICAgICBidWZmZXIuY29weSh0aGlzLmluY29tcGxldGUsIHRoaXMuYnl0ZUNvdW50LCAwLCBieXRlc0NvcGllZCk7XG4gICAgICB0aGlzLmJ5dGVDb3VudCArPSBieXRlc0NvcGllZDsgLy8gcmVjb3JkIGhvdyBtYW55IG1vcmUgYnl0ZXMgd2UgY29waWVkLi4uXG5cbiAgICAgIGlmIChieXRlc0NvcGllZCA8IGxlZnQpIHtcbiAgICAgICAgLy8gc3RpbGwgbmVlZCBtb3JlIGJ5dGVzIHRvIGNvbXBsZXRlIVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIHdlcmUgYWJsZSB0byBjb21wbGV0ZSwgeWF5IVxuICAgICAgLy8gZ3JhYiB0aGUgY2hhcmFjdGVyIHdlIGNvbXBsZXRlZFxuICAgICAgY2hhciA9IHRoaXMuaW5jb21wbGV0ZS5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuICAgICAgLy8gcmVzZXQgb3VyIGNvdW50ZXJzXG4gICAgICB0aGlzLl9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpO1xuICAgICAgLy8gZG8gd2UgaGF2ZSBhbnkgYnl0ZXMgbGVmdCBpbiB0aGlzIGJ1ZmZlcj9cbiAgICAgIGlmIChieXRlc0NvcGllZCA9PT0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2hhcjsgLy8gaWYgbm90LCByZXR1cm4gdGhlIGNoYXJhY3RlciB3ZSBmaW5pc2hlZCFcbiAgICAgIH1cbiAgICAgIC8vIHdlIHN0aWxsIGhhdmUgbW9yZSBieXRlcywgc28gc2xpY2UgdGhlIGJ1ZmZlciB1cFxuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGJ5dGVzQ29waWVkLCBidWZmZXIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0aGlzIGJ1ZmZlciB0byBzZWUgaWYgaXQgaW5kaWNhdGVzIHdlIG5lZWQgbW9yZSBieXRlcz9cbiAgICBjb25zdCBpbmNvbXBsZXRlQ2hhckRhdGEgPSB0aGlzLl9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpO1xuICAgIGlmIChpbmNvbXBsZXRlQ2hhckRhdGEuYnl0ZXNOZWVkZWQgPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyICsgYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBubyBpbmNvbXBsZXRlIGJ5dGVzLCByZXR1cm4gYW55IGNoYXJhY3RlciB3ZSBjb21wbGV0ZWQgcGx1cyB0aGUgYnVmZmVyXG4gICAgfVxuXG4gICAgLy8gb2sgc28gdGhlIGJ1ZmZlciBob2xkcyBhbiBpbmNvbXBsZXRlIGNoYXJhY3RlciBhdCBpdCdzIGVuZFxuICAgIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGVDaGFyRGF0YS5jaGFyTGVuZ3RoOyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgbmVlZCBmb3IgdGhlICdjaGFyYWN0ZXInXG4gICAgY29uc3QgaW5jb21wbGV0ZUNoYXJJbmRleCA9IGluY29tcGxldGVDaGFyRGF0YS5pbmRleDsgLy8gdGhpcyBpcyB0aGUgaW5kZXggb2YgdGhlIG11bHRpYnl0ZSBjaGFyYWN0ZXIgdGhhdCBpcyBpbmNvbXBsZXRlXG5cbiAgICAvLyBjb3B5IGZyb20gaW5kZXggb2YgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgdG8gZW5kIG9mIGJ1ZmZlclxuICAgIGNvbnN0IGJ5dGVzVG9Db3B5ID0gYnVmZmVyLmxlbmd0aCAtIGluY29tcGxldGVDaGFySW5kZXg7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5pbmNvbXBsZXRlLCAwLCBpbmNvbXBsZXRlQ2hhckluZGV4LCBidWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLmJ5dGVDb3VudCA9IGJ5dGVzVG9Db3B5OyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgYWN0dWFsbHkgY29waWVkXG5cbiAgICBpZiAoYnl0ZXNUb0NvcHkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAvLyBidWZmZXIgaGFkIGJ5dGVzIGJlZm9yZSB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICAgIC8vIHNvIHNtdXNoIGFueSBjaGFyYWN0ZXIgd2UgbWF5IGhhdmUgY29tcGxldGVkIHdpdGggYW55IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gdGhlIGJ1ZmZlclxuICAgICAgcmV0dXJuIGNoYXIgKyBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgaW5jb21wbGV0ZUNoYXJJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyOyAvLyBhbnkgbm93LWNvbXBsZXRlZCBjaGFyYWN0ZXIgdGhhdCB3YXMgcHJldmlvdXNseSBpbmNvbXBsZXRlLCBwb3NzaWJseSBlbXB0eVxuICB9XG59XG5cbmNsYXNzIFV0ZjhTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigndXRmOCcsIDQpO1xuICB9XG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIC8vIEZJWE1FOiBJbiBOb2RlLCB0aGV5IGNoZWNrIHRoZSBsYXN0IGNoYXJhY3RlciBmaXJzdCFcbiAgICAvLyBBbmQgdGhleSByZWx5IG9uIEJ1ZmZlciN0b1N0cmluZygpIHRvIGhhbmRsZSBpbmplY3RpbmcgdGhlICdcXHVmZmZkJyBjaGFyYWN0ZXIgZm9yIGJ1c3RlZCBtdWx0aS1ieXRlIHNlcXVlbmNlcyFcbiAgICAvLyBpT1MgYXBwYXJlbnRseSBqdXN0IHJldHVybnMgdW5kZWZpbmVkIGluIHRoYXQgc3BlY2lhbCBjYXNlIGFuZFxuICAgIC8vIEFuZHJvaWQgZGlmZmVycyBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd29yayBiYWNrd2FyZHMgZnJvbSB0aGUgbGFzdCBjaGFyXG4gICAgLy8gQ2FuIHdlIGNoZWF0IGhlcmUgYW5kLi4uXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvc3RyaW5nX2RlY29kZXIvYmxvYi9tYXN0ZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzI0wxNzMtTDE5OFxuICAgIC8vIC0gaWYgd2Ugc2VlIGEgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgc3RhcnQsIHZhbGlkYXRlIHRoZSBuZXh0IGNoYXJhY3RlcnMgYXJlIGNvbnRpbnVhdGlvbiBjaGFyc1xuICAgIC8vIC0gaWYgdGhleSdyZSBub3QgcmVwbGFjZSB0aGUgc2VxdWVuY2Ugd2l0aCAnXFx1ZmZmZCcsIHRyZWF0IGxpa2UgdGhhdCBtdWx0aS1ieXRlIGNoYXJhY3RlciB3YXMgXCJjb21wbGV0ZWRcIlxuXG4gICAgLy8gTm90ZSB0aGF0IGV2ZW4gaWYgd2UgZG8gaGFjayB0aGlzLCBpZiB0aGVyZSdzIHNvbWUgaW52YWxpZCBtdWx0aS1ieXRlIFVURi04IGluIHRoZSBidWZmZXIgdGhhdCBpc24ndCBhdCB0aGUgbGFzdCAzIGJ5dGVzXG4gICAgLy8gdGhlbiB3ZSdyZSBhdCB0aGUgbWVyY3kgb2YgdGhlIEpTIGVuZ2luZS9wbGF0Zm9ybSBjb2RlIGZvciBoYW5kbGluZyB0aGF0XG4gICAgLy8gSGVyZSdzIHNvbWVvbmUncyBoYWNrIHRoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9vbGVnYW56YS85OTcxNTVcblxuICAgIC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMywgY2hlY2sgM3JkIHRvIGxhc3QgYnl0ZVxuICAgIGlmIChsZW5ndGggPj0gMykge1xuICAgICAgbGV0IGNoYXJMZW5ndGggPSBjaGVja0NoYXJMZW5ndGhGb3JVVEY4KGJ1ZmZlcltsZW5ndGggLSAzXSk7XG4gICAgICBpZiAoY2hhckxlbmd0aCA9PT0gNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiAxLFxuICAgICAgICAgIC8vIHdlIGhhdmUgMyBsYXN0IGJ5dGVzLCBuZWVkIDR0aFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAzLFxuICAgICAgICAgIGNoYXJMZW5ndGg6IDRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgYnVmZmVyLmxlbmd0aCA+PSAyLCBjaGVjayAybmQgdG8gbGFzdCBieXRlXG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDJdKTtcbiAgICAgIGlmIChjaGFyTGVuZ3RoID49IDMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieXRlc05lZWRlZDogY2hhckxlbmd0aCAtIDIsXG4gICAgICAgICAgLy8gd2UgaGF2ZSAyIGJ5dGVzIG9mIHdoYXRldmVyIHdlIG5lZWRcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMixcbiAgICAgICAgICBjaGFyTGVuZ3RoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMSwgY2hlY2sgbGFzdCBieXRlXG4gICAgaWYgKGxlbmd0aCA+PSAxKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDFdKTtcbiAgICAgIGlmIChjaGFyTGVuZ3RoID49IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieXRlc05lZWRlZDogY2hhckxlbmd0aCAtIDEsXG4gICAgICAgICAgLy8gd2UgaGF2ZSAxIGJ5dGUgb2Ygd2hhdGV2ZXIgd2UgbmVlZFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgICAgIGNoYXJMZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSBjYXNlLCBubyBieXRlcyBuZWVkZWQgLSBlbmRzIG9uIGNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHJldHVybiB7XG4gICAgICBieXRlc05lZWRlZDogMCxcbiAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgY2hhckxlbmd0aDogMVxuICAgIH07XG4gIH1cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgcmV0dXJuICdcXHVmZmZkJzsgLy8gd2UgcmVwbGFjZSB0aGUgbWlzc2luZyBjaGFyYWN0ZXIgd2l0aCBhIHNwZWNpYWwgdXRmOCBjaGFyXG4gIH1cbn1cblxuY2xhc3MgVXRmMTZTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigndXRmMTZsZScsIDQpO1xuICB9XG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIGNvbnN0IG1vZHVsbyA9IGxlbmd0aCAlIDI7XG4gICAgLy8gb2ssIHdlIGhhdmUgYSBtdWx0aXBsZSBvZiAyIGJ5dGVzXG4gICAgaWYgKG1vZHVsbyA9PT0gMCkge1xuICAgICAgLy8gaXMgdGhlIGxhc3QgYnl0ZSBhIGxlYWRpbmcvaGlnaCBzdXJyb2dhdGU/XG4gICAgICBjb25zdCBieXRlID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChieXRlID49IDB4RDggJiYgYnl0ZSA8PSAweERCKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYnl0ZXNOZWVkZWQ6IDIsXG4gICAgICAgICAgY2hhckxlbmd0aDogNCxcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSdyZSBnb29kLCBub3QgYSBzdXJyb2dhdGUsIHNvIHdlIGhhdmUgb3VyIG5lZWRlZCAyIGJ5dGVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBieXRlc05lZWRlZDogMCxcbiAgICAgICAgY2hhckxlbmd0aDogMlxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBvayB3ZSBoYXZlIDEgYnl0ZSBsZWZ0IG92ZXIsIGFzc3VtZSB3ZSBuZWVkIDIgdG8gZm9ybSB0aGUgY2hhcmFjdGVyXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzTmVlZGVkOiAxLFxuICAgICAgaW5kZXg6IGxlbmd0aCAtIDEsXG4gICAgICBjaGFyTGVuZ3RoOiAyXG4gICAgfTtcbiAgfVxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICAvLyBKdXN0IHdyaXRlIG91dCB0aGUgbGFzdCBOIGJ5dGVzLCBob3BlZnVsbHkgdGhlIGVuZ2luZSBjYW4gaGFuZGxlIGl0IGZvciB1cz9cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgdGhpcy5ieXRlQ291bnQpO1xuICB9XG59XG5jbGFzcyBCYXNlNjRTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignYmFzZTY0JywgMyk7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gMzsgLy8gYWx3YXlzIDMhXG4gIH1cblxuICBfY2hlY2tJbmNvbXBsZXRlQnl0ZXMoYnVmZmVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCBtb2R1bG8gPSBsZW5ndGggJSAzO1xuICAgIC8vIGJhc2U2NCBuZWVkcyAzIGJ5dGVzIGFsd2F5cywgc28gaWYgd2UgaGF2ZSB0aGF0IG1hbnkgKG9yIGEgbXVsdGlwbGUpLCB3ZSBoYXZlIGEgY29tcGxldGUgYnVmZmVyXG4gICAgaWYgKG1vZHVsbyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnl0ZXNOZWVkZWQ6IDAsXG4gICAgICAgIGNoYXJMZW5ndGg6IDNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gb2sgd2UgaGF2ZSAxIG9yIDIgYnl0ZXMgbGVmdCBvdmVyXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzTmVlZGVkOiAzIC0gbW9kdWxvLFxuICAgICAgLy8gYWx3YXlzIG5lZWQgMywgc28gaWYgd2UgaGF2ZSAxIGxlZnQgb3ZlciAtPiBuZWVkIDJcbiAgICAgIGluZGV4OiBsZW5ndGggLSBtb2R1bG8sXG4gICAgICBjaGFyTGVuZ3RoOiAzIC8vIGFsd2F5cyBuZWVkIDNcbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCkge1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAzOyAvLyBhbHdheXMgMyFcbiAgfVxuXG4gIF9pbmNvbXBsZXRlRW5kKCkge1xuICAgIC8vIEp1c3Qgd3JpdGUgb3V0IHRoZSBsYXN0IE4gYnl0ZXMsIGl0IHNob3VsZCBpbnNlcnQgdGhlICc9JyBwbGFjZWhvbGRlcnNcbiAgICAvLyBpdCdzIG5vdCByZWFsbHkgJ21pc3NpbmcnLydpbmNvbXBsZXRlJywganVzdCBuZWVkcyBwbGFjZWhvbGRlciBpbnNlcnRpb25cbiAgICByZXR1cm4gdGhpcy5pbmNvbXBsZXRlLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCB0aGlzLmJ5dGVDb3VudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnl0ZSkge1xuICAvLyAxMTExMFhYWCA9PiAxMTEwID0+IDB4MUVcbiAgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkge1xuICAgIHJldHVybiA0O1xuICB9XG5cbiAgLy8gMTExMFhYWFggPT4gMTExMCA9PiAweDFFXG4gIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHtcbiAgICByZXR1cm4gMztcbiAgfVxuXG4gIC8vIDExMFhYWFhYID0+IDExMCA9PiAweDA2XG4gIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gMTtcbn1cbnZhciBTdHJpbmdEZWNvZGVyJDEgPSB7XG4gIFN0cmluZ0RlY29kZXJcbn07XG5cbi8vIEtlZXAgdHJhY2sgb2YgcHJpbnRpbmcgb3V0IG9uZS10aW1lIHdhcm5pbmcgbWVzc2FnZXMgZm9yIHVuc3VwcG9ydGVkIG9wZXJhdGlvbnMvb3B0aW9ucy9hcmd1bWVudHNcbmNvbnN0IHByaW50ZWRXYXJuaW5ncyA9IHt9O1xuZnVuY3Rpb24gb25lVGltZVdhcm5pbmcoa2V5LCBtc2cpIHtcbiAgaWYgKCFwcmludGVkV2FybmluZ3Nba2V5XSkge1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIHByaW50ZWRXYXJuaW5nc1trZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBQcmludHMgYSBvbmUtdGltZSB3YXJuaW5nIG1lc3NhZ2UgdGhhdCB3ZSBkbyBub3Qgc3VwcG9ydCB0aGUgZ2l2ZW4gQVBJIGFuZCBwZXJmb3JtcyBhbiBlZmZlY3RpdmUgbm8tb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIG5hbWUgb2YgdGhlIG1vZHVsZS9vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLnByb3BlcnR5IHdlIGRvbid0IHN1cHBvcnRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gbm8tb3AgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWROb29wKG1vZHVsZU5hbWUsIG5hbWUpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBmcW4gPSBgJHttb2R1bGVOYW1lfS4ke25hbWV9YDtcbiAgICBvbmVUaW1lV2FybmluZyhmcW4sIGBcIiR7ZnFufVwiIGlzIG5vdCBzdXBwb3J0ZWQgeWV0IG9uIFRpdGFuaXVtIGFuZCB1c2VzIGEgbm8tb3AgZmFsbGJhY2suYCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBuYW1lIG9mIHRoZSBtb2R1bGUvb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5wcm9wZXJ0eSB3ZSBkb24ndCBzdXBwb3J0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhc3luYyBjYWxsYmFjayB3ZSBjYWxsIGluIGEgcXVpY2sgc2V0VGltZW91dFxuICovXG5mdW5jdGlvbiBhc3luY1Vuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spOyAvLyBlbmZvcmNlIHdlIGhhdmUgYSB2YWxpZCBjYWxsYmFja1xuICB1bnN1cHBvcnRlZE5vb3AobW9kdWxlTmFtZSwgbmFtZSkoKTtcbiAgc2V0VGltZW91dChjYWxsYmFjaywgMSk7XG59XG5cbi8vIFVzZWQgdG8gY2hvb3NlIHRoZSBidWZmZXIvY2h1bmsgc2l6ZSB3aGVuIHB1bXBpbmcgYnl0ZXMgZHVyaW5nIGNvcGllc1xuY29uc3QgQ09QWV9GSUxFX0NIVU5LX1NJWkUgPSA4MDkyOyAvLyB3aGF0IHNob3VsZCB3ZSB1c2UgaGVyZT9cblxuLy8gS2VlcCB0cmFjayBvZiBpbnRlZ2VyIC0+IEZpbGVTdHJlYW0gbWFwcGluZ3NcbmNvbnN0IGZpbGVEZXNjcmlwdG9ycyA9IG5ldyBNYXAoKTtcbmxldCBmaWxlRGVzY3JpcHRvckNvdW50ID0gNDsgLy8gZ2xvYmFsIGNvdW50ZXIgdXNlZCB0byByZXBvcnQgZmlsZSBkZXNjcmlwdG9yIGludGVnZXJzXG5cbi8vIE1hcCBmaWxlIHN5c3RlbSBhY2Nlc3MgZmxhZ3MgdG8gVGkuRmlsZXN5c3RlbS5NT0RFXyogY29uc3RhbnRzXG5jb25zdCBGTEFHU19UT19USV9NT0RFID0gbmV3IE1hcCgpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2EnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdheCcsIFRpLkZpbGVzeXN0ZW0uTU9ERV9BUFBFTkQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2ErJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYXgrJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYXMrJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgncicsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdyKycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdycysnLCBUaS5GaWxlc3lzdGVtLk1PREVfUkVBRCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgndycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnd3gnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3crJywgVGkuRmlsZXN5c3RlbS5NT0RFX1dSSVRFKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3eCsnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuXG4vLyBDb21tb24gZXJyb3JzXG5jb25zdCBwZXJtaXNzaW9uRGVuaWVkID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUFDQ0VTJywgJ3Blcm1pc3Npb24gZGVuaWVkJywgLTEzLCBzeXNjYWxsLCBwYXRoKTtcbmNvbnN0IG5vU3VjaEZpbGUgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFTk9FTlQnLCAnbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScsIC0yLCBzeXNjYWxsLCBwYXRoKTtcbmNvbnN0IGZpbGVBbHJlYWR5RXhpc3RzID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUVYSVNUJywgJ2ZpbGUgYWxyZWFkeSBleGlzdHMnLCAtMTcsIHN5c2NhbGwsIHBhdGgpO1xuY29uc3Qgbm90QURpcmVjdG9yeSA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VOT1RESVInLCAnbm90IGEgZGlyZWN0b3J5JywgLTIwLCBzeXNjYWxsLCBwYXRoKTtcbmNvbnN0IGRpcmVjdG9yeU5vdEVtcHR5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRU5PVEVNUFRZJywgJ2RpcmVjdG9yeSBub3QgZW1wdHknLCAtNjYsIHN5c2NhbGwsIHBhdGgpO1xuY29uc3QgaWxsZWdhbE9wZXJhdGlvbk9uQURpcmVjdG9yeSA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VJU0RJUicsICdpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeScsIC0yMSwgc3lzY2FsbCwgcGF0aCk7XG5jb25zdCBmcyA9IHtcbiAgY29uc3RhbnRzOiB7XG4gICAgT19SRE9OTFk6IDAsXG4gICAgT19XUk9OTFk6IDEsXG4gICAgT19SRFdSOiAyLFxuICAgIFNfSUZNVDogNjE0NDAsXG4gICAgU19JRlJFRzogMzI3NjgsXG4gICAgU19JRkRJUjogMTYzODQsXG4gICAgU19JRkNIUjogODE5MixcbiAgICBTX0lGQkxLOiAyNDU3NixcbiAgICBTX0lGSUZPOiA0MDk2LFxuICAgIFNfSUZMTks6IDQwOTYwLFxuICAgIFNfSUZTT0NLOiA0OTE1MixcbiAgICBPX0NSRUFUOiA1MTIsXG4gICAgT19FWENMOiAyMDQ4LFxuICAgIE9fTk9DVFRZOiAxMzEwNzIsXG4gICAgT19UUlVOQzogMTAyNCxcbiAgICBPX0FQUEVORDogOCxcbiAgICBPX0RJUkVDVE9SWTogMTA0ODU3NixcbiAgICBPX05PRk9MTE9XOiAyNTYsXG4gICAgT19TWU5DOiAxMjgsXG4gICAgT19EU1lOQzogNDE5NDMwNCxcbiAgICBPX1NZTUxJTks6IDIwOTcxNTIsXG4gICAgT19OT05CTE9DSzogNCxcbiAgICBTX0lSV1hVOiA0NDgsXG4gICAgU19JUlVTUjogMjU2LFxuICAgIFNfSVdVU1I6IDEyOCxcbiAgICBTX0lYVVNSOiA2NCxcbiAgICBTX0lSV1hHOiA1NixcbiAgICBTX0lSR1JQOiAzMixcbiAgICBTX0lXR1JQOiAxNixcbiAgICBTX0lYR1JQOiA4LFxuICAgIFNfSVJXWE86IDcsXG4gICAgU19JUk9USDogNCxcbiAgICBTX0lXT1RIOiAyLFxuICAgIFNfSVhPVEg6IDEsXG4gICAgRl9PSzogMCxcbiAgICBSX09LOiA0LFxuICAgIFdfT0s6IDIsXG4gICAgWF9PSzogMSxcbiAgICBVVl9GU19DT1BZRklMRV9FWENMOiAxLFxuICAgIENPUFlGSUxFX0VYQ0w6IDFcbiAgfVxufTtcbmNsYXNzIFN0YXRzIHtcbiAgY29uc3RydWN0b3IocGF0aCkge1xuICAgIHRoaXMuX2ZpbGUgPSBudWxsO1xuICAgIHRoaXMuZGV2ID0gMDtcbiAgICB0aGlzLmlubyA9IDA7XG4gICAgdGhpcy5tb2RlID0gMDtcbiAgICB0aGlzLm5saW5rID0gMDtcbiAgICB0aGlzLnVpZCA9IDA7XG4gICAgdGhpcy5naWQgPSAwO1xuICAgIHRoaXMucmRldiA9IDA7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmJsa3NpemUgPSA0MDk2OyAvLyBGSVhNRTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMxNTMxMS93aGF0LWlzLXRoZS1ibG9jay1zaXplLW9mLXRoZS1pcGhvbmUtZmlsZXN5c3RlbVxuICAgIHRoaXMuYmxvY2tzID0gMDtcbiAgICB0aGlzLmF0aW1lTXMgPSB0aGlzLm10aW1lTXMgPSB0aGlzLmN0aW1lTXMgPSB0aGlzLmJpcnRodGltZU1zID0gMDtcbiAgICB0aGlzLmF0aW1lID0gdGhpcy5tdGltZSA9IHRoaXMuY3RpbWUgPSB0aGlzLmJpcnRodGltZSA9IG5ldyBEYXRlKDApO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICB0aGlzLl9maWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgICAgIC8vIFRPRE86IHVzZSBsYXp5IGdldHRlcnMgaGVyZT9cbiAgICAgIHRoaXMuY3RpbWUgPSB0aGlzLmJpcnRodGltZSA9IHRoaXMuX2ZpbGUuY3JlYXRlZEF0KCk7XG4gICAgICB0aGlzLmF0aW1lID0gdGhpcy5tdGltZSA9IHRoaXMuX2ZpbGUubW9kaWZpZWRBdCgpO1xuICAgICAgdGhpcy5hdGltZU1zID0gdGhpcy5hdGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLmJpcnRodGltZU1zID0gdGhpcy5iaXJ0aHRpbWUuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5jdGltZU1zID0gdGhpcy5jdGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLm10aW1lTXMgPSB0aGlzLm10aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2ZpbGUuc2l6ZTtcbiAgICAgIHRoaXMuYmxvY2tzID0gTWF0aC5jZWlsKHRoaXMuc2l6ZSAvIHRoaXMuYmxrc2l6ZSk7XG4gICAgICAvLyBUT0RPOiBDYW4gd2UgZmFrZSBvdXQgdGhlIG1vZGUgYmFzZWQgb24gdGhlIHJlYWRvbmx5L3dyaXRhYmxlL2V4ZWN1dGFibGUgcHJvcGVydGllcz9cbiAgICB9XG4gIH1cblxuICBpc0ZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUuaXNGaWxlKCk7XG4gIH1cbiAgaXNEaXJlY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUuaXNEaXJlY3RvcnkoKTtcbiAgfVxuICBpc0Jsb2NrRGV2aWNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0NoYXJhY3RlckRldmljZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNTeW1ib2xpY0xpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUuc3ltYm9saWNMaW5rO1xuICB9XG4gIGlzRklGTygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNTb2NrZXQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mcy5TdGF0cyA9IFN0YXRzO1xuY2xhc3MgUmVhZFN0cmVhbSB7fVxuZnMuUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW07XG5jbGFzcyBXcml0ZVN0cmVhbSB7fVxuZnMuV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgc3RhdHNDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ZzLlN0YXRzfSBzdGF0cyAtIGZpbGUgc3RhdHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTHxCdWZmZXJ9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFttb2RlPWZzLmNvbnN0YW50cy5GX09LXSBhY2Nlc3NpYmlsaXR5IG1vZGUvY2hlY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLmFjY2VzcyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG1vZGU7XG4gICAgbW9kZSA9IGZzLmNvbnN0YW50cy5GX09LO1xuICB9XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5hY2Nlc3NTeW5jKHBhdGgsIG1vZGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8VVJMfEJ1ZmZlcn0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW21vZGU9ZnMuY29uc3RhbnRzLkZfT0tdIGFjY2Vzc2liaWxpdHkgbW9kZS9jaGVja1xuICovXG5mcy5hY2Nlc3NTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUgPSBmcy5jb25zdGFudHMuRl9PSykge1xuICAvLyBGX09LIGlzIGp1c3Qgd2hldGhlciBmaWxlIGV4aXN0cyBvciBub3QsIG5vIHBlcm1pc3Npb25zIGNoZWNrXG4gIC8vIFJfT0sgaXMgcmVhZCBjaGVja1xuICAvLyBXX09LIGlzIHdyaXRlIGNoZWNrXG4gIC8vIFhfT0sgaXMgZXhlY3V0ZSBjaGVjayAoYWN0cyBsaWtlIEZfT0sgb24gV2luZG93cylcbiAgY29uc3QgZmlsZUhhbmRsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuICBpZiAoIWZpbGVIYW5kbGUuZXhpc3RzKCkpIHtcbiAgICB0aHJvdyBub1N1Y2hGaWxlKCdhY2Nlc3MnLCBwYXRoKTtcbiAgfVxuXG4gIC8vIFRPRE86IFdlIGhhdmUgbm8gbWVhbnMgb2YgdGVzdGluZyBpZiBhIGZpbGUgaXMgcmVhZGFibGUuIEl0J3MgYXNzdW1lZCBhbGwgZmlsZXMgdGhhdCBleGlzdCB1bmRlciB0aGUgYXBwIGFyZT9cbiAgaWYgKG1vZGUgJiBmcy5jb25zdGFudHMuV19PSyAmJiAhZmlsZUhhbmRsZS53cml0YWJsZSkge1xuICAgIHRocm93IHBlcm1pc3Npb25EZW5pZWQoJ2FjY2VzcycsIHBhdGgpO1xuICB9XG4gIGlmIChtb2RlICYgZnMuY29uc3RhbnRzLlhfT0sgJiYgIWZpbGVIYW5kbGUuZXhlY3V0YWJsZSAmJiBmaWxlSGFuZGxlLmlzRmlsZSgpKSB7XG4gICAgdGhyb3cgcGVybWlzc2lvbkRlbmllZCgnYWNjZXNzJywgcGF0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuIGRhdGEgY2FuIGJlIGEgc3RyaW5nIG9yIGEgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxGaWxlU3RyZWFtfSBmaWxlIGZpbGVwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSBkYXRhIHRvIGFwcGVuZCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzY2Nl0gbW9kZSB0byBjcmVhdGUgZmlsZSwgaWYgbm90IGNyZWF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdhJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBiYWNrIHdpdGggZXJyb3IgaWYgZmFpbGVkXG4gKi9cbmZzLmFwcGVuZEZpbGUgPSAoZmlsZSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrIHx8IG9wdGlvbnMpO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiAwbzY2NixcbiAgICBmbGFnOiAnYSdcbiAgfSk7XG4gIGZzLndyaXRlRmlsZShmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuIGRhdGEgY2FuIGJlIGEgc3RyaW5nIG9yIGEgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxGaWxlU3RyZWFtfSBmaWxlIGZpbGVwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSBkYXRhIHRvIGFwcGVuZCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzY2Nl0gbW9kZSB0byBjcmVhdGUgZmlsZSwgaWYgbm90IGNyZWF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdhJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICovXG5mcy5hcHBlbmRGaWxlU3luYyA9IChmaWxlLCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICdhJ1xuICB9KTtcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCBkYXRhLCBvcHRpb25zKTtcbiAgLy8gVE9ETzogVXNlIFRpLkZpbGVzeXN0ZW0uRmlsZS5hcHBlbmQoKSBpbnN0ZWFkP1xufTtcblxuZnMuY2htb2QgPSAocGF0aCwgbW9kZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG1vZCcsIGNhbGxiYWNrKTtcbmZzLmNobW9kU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2htb2RTeW5jJyk7XG5mcy5jaG93biA9IChwYXRoLCB1aWQsIGdpZCwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdjaG93bicsIGNhbGxiYWNrKTtcbmZzLmNob3duU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2hvd25TeW5jJyk7XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZ1bmN0aW9ucyB0aGF0IGNhbiBvbmx5IHRocm93IGVycm9yc1xuICpcbiAqIEBjYWxsYmFjayBlcnJvckNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyXSAtIEVycm9yIHRocm93blxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuZnMuY2xvc2UgPSAoZmQsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuZnMuY2xvc2VTeW5jID0gZmQgPT4ge1xuICBjb25zdCBzdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcbiAgc3RyZWFtLmNsb3NlKCk7XG59O1xuXG4vLyBSYXRoZXIgdGhhbiB1c2UgYSBoYWNrIHRvIHdyYXAgc3luYyB2ZXJzaW9uIGluIHNldFRpbWVvdXQsIHVzZSBhY3R1YWwgYXN5bmMgQVBJcyFcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gc3JjIHNvdXJjZSBmaWxlbmFtZSB0byBjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBkZXN0IGRlc3RpbmF0aW9uIGZpbGVuYW1lIG9mIHRoZSBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFncz0wXSBtb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGNhbGxlZCBhdCBlbmQgb2Ygb3BlcmF0aW9uXG4gKi9cbmZzLmNvcHlGaWxlID0gZnVuY3Rpb24gKHNyYywgZGVzdCwgZmxhZ3MsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGZsYWdzO1xuICAgIGZsYWdzID0gMDtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuXG4gIC8vIEZJWE1FOiBJIGRvbid0IGtub3cgd2h5LCBidXQgY2hhbmdpbmcgdGhpcyB0byB1c2UgVGkuRmlsZXN5c3RlbS5vcGVuU3RyZWFtKG1vZGUsIHBhdGgpIGZhaWxzIChhdCBsZWFzdCBvbiBpT1MpXG4gIGNvbnN0IHNyY0ZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoc3JjKTtcbiAgY29uc3Qgc3JjU3RyZWFtID0gc3JjRmlsZS5vcGVuKFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbiAgY29uc3QgZGVzdEZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoZGVzdCk7XG4gIGNvbnN0IGRlc3RTdHJlYW0gPSBkZXN0RmlsZS5vcGVuKFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG4gIHBpcGUoc3JjU3RyZWFtLCBkZXN0U3RyZWFtLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHNyYyBzb3VyY2UgZmlsZW5hbWUgdG8gY29weVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gZGVzdCBkZXN0aW5hdGlvbiBmaWxlbmFtZSBvZiB0aGUgY29weSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZmxhZ3M9MF0gbW9kaWZpZXJzIGZvciBjb3B5IG9wZXJhdGlvblxuICovXG5mcy5jb3B5RmlsZVN5bmMgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBmbGFncyA9IDApIHtcbiAgY29uc3Qgc3JjRmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShzcmMpO1xuICBpZiAoZmxhZ3MgPT09IGZzLmNvbnN0YW50cy5DT1BZRklMRV9FWENMICYmIGZzLmV4aXN0c1N5bmMoZGVzdCkpIHtcbiAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnY29weUZpbGUnLCBkZXN0KTtcbiAgfVxuICBpZiAoIXNyY0ZpbGUuY29weShkZXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvcHkgJHtzcmN9IHRvICR7ZGVzdH1gKTsgLy8gRklYTUU6IFdoYXQgZXJyb3Igc2hvdWxkIHdlIGdpdmU/XG4gIH1cbn07XG5cbi8vIFRPRE86IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucylcbi8vIC8qKlxuLy8gICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBwYXRoIGxpa2Vcbi8vICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMsIGlmIGEgc3RyaW5nLCBpdCdzIHRoZSBlbmNvZGluZ1xuLy8gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWdzPSdyJ10gU2VlIHN1cHBvcnQgb2YgZmlsZSBzeXN0ZW0gZmxhZ3MuXG4vLyAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gZW5jb2Rpbmdcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuZmQ9bnVsbF0gZmlsZSBkZXNjcmlwdG9yLCBpZiBzcGVjaWZpZWQsIGBwYXRoYCBpcyBpZ25vcmVkXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG82NjZdIHBlcm1pc3Npb25zIHRvIHNldCBpZiBmaWxlIGlzIGNyZWF0ZWRcbi8vICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0Nsb3NlPXRydWVdIGlmIGZhbHNlLCBmaWxlIGRlc2NyaXB0b3Igd2lsbCBub3QgYmUgY2xvc2VkOyBpZiB0cnVlIGV2ZW4gb24gZXJyb3IgaXQgd2lsbCBiZSBjbG9zZWRcbi8vICAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuc3RhcnRdIHN0YXJ0IGluZGV4IG9mIHJhbmdlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBmaWxlXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmVuZD1JbmZpbml0eV0gZW5kIGluZGV4IG9mIHJhbmdlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBmaWxlXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmhpZ2hXYXRlck1hcms9NjQgKiAxMDI0XVxuLy8gICogQHJldHVybnMge2ZzLlJlYWRTdHJlYW19XG4vLyAgKi9cbi8vIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuLy8gXHRvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7IGZsYWdzOiAncicsIGVuY29kaW5nOiBudWxsLCBmZDogbnVsbCwgbW9kZTogMG82NjYsIGF1dG9DbG9zZTogdHJ1ZSwgZW5kOiBJbmZpbml0eSwgaGlnaFdhdGVyTWFyazogNjQgKiAxMDI0IH0pO1xuXG4vLyBcdC8vIEZJWE1FOiBJZiBvcHRpb25zLmZkLCB1c2UgdGhhdCBpbiBwbGFjZSBvZiBwYXRoIVxuLy8gXHRjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcbi8vIH07XG4vLyBUT0RPOiBmcy5jcmVhdGVXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKVxuXG4vKipcbiAqIEBjYWxsYmFjayBleGlzdHNDYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFufSBleGlzdHMgLSB3aGV0aGVyIHBhdGggZXhpc3RzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIHRvIGNoZWNrXG4gKiBAcGFyYW0ge2V4aXN0c0NhbGxiYWNrfSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZzLmV4aXN0cyA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjYWxsYmFjayhmcy5leGlzdHNTeW5jKHBhdGgpKTtcbiAgfSwgMSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGEgZmlsZSBvciBkaXJlY3RvcnkgZXhpc3RzIGF0IHRoYXQgcGF0aFxuICovXG5mcy5leGlzdHNTeW5jID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgdHJ5IHtcbiAgICBmcy5hY2Nlc3NTeW5jKHBhdGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuZnMuZmNobW9kID0gKGZkLCBtb2RlLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG1vZCcsIGNhbGxiYWNrKTtcbmZzLmZjaG1vZFN5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG1vZFN5bmMnKTtcbmZzLmZjaG93biA9IChmZCwgdWlkLCBnaWQsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNob3duJywgY2FsbGJhY2spO1xuZnMuZmNob3duU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmNob3duU3luYycpO1xuZnMuZmRhdGFzeW5jID0gKGZkLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZkYXRhc3luYycsIGNhbGxiYWNrKTtcbmZzLmZkYXRhc3luY1N5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZkYXRhc3luY1N5bmMnKTtcblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBhc3luYyBjYWxsYmFjayBmdW5jdGlvblxuICovXG5mcy5mc3RhdCA9IChmZCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsZXQgc3RhdHM7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXRzID0gZnMuZnN0YXRTeW5jKGZkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgc3RhdHMpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW19vcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHJldHVybnMge2ZzLlN0YXRzfSBzdGF0cyBmb3IgZmlsZSBkZXNjcmlwdG9yXG4gKi9cbmZzLmZzdGF0U3luYyA9IChmZCwgX29wdGlvbnMpID0+IHtcbiAgY29uc3QgcGF0aCA9IHBhdGhGb3JGaWxlRGVzY3JpcHRvcihmZCk7XG4gIHJldHVybiBmcy5zdGF0U3luYyhwYXRoKTtcbn07XG5cbi8vIFRPRE86IEFkZCB2ZXJzaW9ucyBvZiB0aGVzZSBBUElzOlxuLy8gZnMuZnN5bmMoZmQsIGNhbGxiYWNrKVxuLy8gZnMuZnN5bmNTeW5jKGZkKVxuLy8gZnMuZnRydW5jYXRlKGZkWywgbGVuXSwgY2FsbGJhY2spXG4vLyBmcy5mdHJ1bmNhdGVTeW5jKGZkWywgbGVuXSlcbi8vIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spXG4vLyBmcy5mdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKVxuLy8gZnMubGNobW9kKHBhdGgsIG1vZGUsIGNhbGxiYWNrKVxuLy8gZnMubGNobW9kU3luYyhwYXRoLCBtb2RlKVxuLy8gZnMubGNob3duKHBhdGgsIHVpZCwgZ2lkLCBjYWxsYmFjaylcbi8vIGZzLmxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG4vLyBmcy5saW5rKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spXG4vLyBmcy5saW5rU3luYyhleGlzdGluZ1BhdGgsIG5ld1BhdGgpXG5cbi8vIEZJWE1FOiBJZiBzeW1ib2xpYyBsaW5rIHdlIG5lZWQgdG8gZm9sbG93IGxpbmsgdG8gdGFyZ2V0IHRvIGdldCBzdGF0cyEgT3VyIEFQSSBkb2Vzbid0IHN1cHBvcnQgdGhhdCFcbmZzLmxzdGF0ID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiBmcy5zdGF0KHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbmZzLmxzdGF0U3luYyA9IChwYXRoLCBvcHRpb25zKSA9PiBmcy5zdGF0U3luYyhwYXRoLCBvcHRpb25zKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNpdmU9ZmFsc2VdIHJlY3Vyc2l2bGV5IGNyZWF0ZSBkaXJzP1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNzc3XSBwZXJtaXNzaW9uc1xuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5ta2RpciA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICBtb2RlOiAwbzc3N1xuICAgIH07XG4gIH1cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCk7XG4gIH0sIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNpdmU9ZmFsc2VdIHJlY3Vyc2l2bGV5IGNyZWF0ZSBkaXJzP1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNzc3XSBwZXJtaXNzaW9uc1xuICovXG5mcy5ta2RpclN5bmMgPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICByZWN1cnNpdmU6IGZhbHNlLFxuICAgICAgbW9kZTogb3B0aW9uc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICAgIG1vZGU6IDBvNzc3XG4gICAgfSk7XG4gIH1cbiAgaWYgKCF0aUZpbGUuY3JlYXRlRGlyZWN0b3J5KG9wdGlvbnMucmVjdXJzaXZlKSAmJiAhb3B0aW9ucy5yZWN1cnNpdmUpIHtcbiAgICBpZiAodGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICAvLyBhbHJlYWR5IGV4aXN0ZWQhXG4gICAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnbWtkaXInLCBwYXRoKTtcbiAgICB9XG4gICAgLy8gV2UgZmFpbGVkLCBwcm9iYWJseSBiZWNhdXNlIHdlIGRpZG4ndCBhc2sgZm9yIHJlY3Vyc2l2ZSBhbmQgcGFyZW50IGRvZXNuJ3QgZXhpc3QsIHNvIHJlcHJvZHVjZSBub2RlJ3MgZXJyb3JcbiAgICB0aHJvdyBub1N1Y2hGaWxlKCdta2RpcicsIHBhdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayB0ZW1wRGlyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIGdlbmVyYXRlZCBmb2xkZXIgbmFtZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBkaXJlY3RvcnkgbmFtZSBwcmVmaXhcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBwcmVmaXggZW5jb2RpbmdcbiAqIEBwYXJhbSB7dGVtcERpckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5ta2R0ZW1wID0gKHByZWZpeCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHByZWZpeCwgJ3ByZWZpeCcsICdzdHJpbmcnKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGYtOCdcbiAgfSk7XG5cbiAgLy8gdHJ5IHRvIGJlIGFsbCBhc3luY1xuICBjb25zdCB0cnlNa2R0ZW1wID0gKCkgPT4ge1xuICAgIGNvbnN0IGdlbmVyYXRlZCA9IHJhbmRvbUNoYXJhY3RlcnMoNiwgb3B0aW9ucy5lbmNvZGluZyk7IC8vIGdlbmVyYXRlIHNpeCByYW5kb20gY2hhcmFjdGVyc1xuICAgIGNvbnN0IHBhdGggPSBgJHtwcmVmaXh9JHtnZW5lcmF0ZWR9YDtcbiAgICBmcy5ta2RpcihwYXRoLCAwbzcwMCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRUVYSVNUJykge1xuICAgICAgICAgIC8vIHJldHJ5IVxuICAgICAgICAgIHNldFRpbWVvdXQodHJ5TWtkdGVtcCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1YmJsZSB1cCBlcnJvclxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBzdWNjZWVkZWQhIEh1cnJheSFcbiAgICAgIGNhbGxiYWNrKG51bGwsIHBhdGgpO1xuICAgIH0pO1xuICB9O1xuICBzZXRUaW1lb3V0KHRyeU1rZHRlbXAsIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5pcXVlIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IGRpcmVjdG9yeSBuYW1lIHByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIHByZWZpeCBlbmNvZGluZ1xuICogQHJldHVybnMge3N0cmluZ30gcGF0aCB0byBjcmVhdGVkIGRpcmVjdG9yeVxuICovXG5mcy5ta2R0ZW1wU3luYyA9IChwcmVmaXgsIG9wdGlvbnMpID0+IHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHByZWZpeCwgJ3ByZWZpeCcsICdzdHJpbmcnKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmLTgnXG4gIH0pO1xuICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gIGNvbnN0IE1BWF9SRVRSSUVTID0gMTAwO1xuICB3aGlsZSAocmV0cnlDb3VudCA8IE1BWF9SRVRSSUVTKSB7XG4gICAgY29uc3QgZ2VuZXJhdGVkID0gcmFuZG9tQ2hhcmFjdGVycyg2LCBvcHRpb25zLmVuY29kaW5nKTsgLy8gZ2VuZXJhdGUgc2l4IHJhbmRvbSBjaGFyYWN0ZXJzXG4gICAgY29uc3QgcGF0aCA9IGAke3ByZWZpeH0ke2dlbmVyYXRlZH1gO1xuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGF0aCwgMG83MDApOyAvLyBkb24ndCB0cnkgcmVjdXJzaXZlXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnRUVYSVNUJykge1xuICAgICAgICB0aHJvdyBlOyAvLyBidWJibGUgdXAgZXJyb3JcbiAgICAgIH1cbiAgICAgIC8vIG5hbWUgd2FzIG5vdCB1bmlxdWUsIHNvIHJldHJ5XG4gICAgICByZXRyeUNvdW50Kys7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBhIHVuaXF1ZSBkaXJlY3RvcnkgbmFtZSB3aXRoIHByZWZpeCAke3ByZWZpeH1gKTtcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbGVEZXNjcmlwdG9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSBmaWxlRGVzY3JpcHRvciAtIGdlbmVyYXRlZCBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggcGF0aCB0byBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzPSdyJ10gZmlsZSBzeXN0ZW0gYWNjZXNzIGZsYWdzXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFttb2RlPTBvNjY2XSBmaWxlIG1vZGUgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZmlsZVxuICogQHBhcmFtIHtmaWxlRGVzY3JpcHRvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5vcGVuID0gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYWxsYmFjaykgPT4ge1xuICAvLyBmbGFncyBhbmQgbW9kZSBhcmUgb3B0aW9uYWwsIHdlIG5lZWQgdG8gaGFuZGxlIGlmIG5vdCBzdXBwbGllZCFcbiAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgZmxhZ3MgPSAncic7XG4gICAgbW9kZSA9IDBvNjY2O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtb2RlO1xuICAgIG1vZGUgPSAwbzY2NjtcbiAgfVxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsZXQgZmlsZURlc2NyaXB0b3I7XG4gICAgdHJ5IHtcbiAgICAgIGZpbGVEZXNjcmlwdG9yID0gZnMub3BlblN5bmMocGF0aCwgZmxhZ3MsIG1vZGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCBmaWxlRGVzY3JpcHRvcik7XG4gIH0sIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIHBhdGggdG8gZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtmbGFncz0nciddIGZpbGUgc3lzdGVtIGFjY2VzcyBmbGFnc1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbX21vZGU9MG82NjZdIGZpbGUgbW9kZSB0byB1c2Ugd2hlbiBjcmVhdGluZyBmaWxlXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuZnMub3BlblN5bmMgPSAocGF0aCwgZmxhZ3MgPSAncicsIF9tb2RlID0gMG82NjYpID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG4gIGlmICghdGlGaWxlLmV4aXN0cygpKSB7XG4gICAgLy8gVE9ETzogU3VwcG9ydCBjcmVhdGluZyBmaWxlIHdpdGggc3BlY2lmaWMgbW9kZVxuICAgIG9uZVRpbWVXYXJuaW5nKCdmcy5vcGVuU3luYy5tb2RlJywgJ2ZzLm9wZW5TeW5jXFwncyBtb2RlIHBhcmFtZXRlciBpcyB1bnN1cHBvcnRlZCBpbiBUaXRhbml1bSBhbmQgd2lsbCBiZSBpZ25vcmVkJyk7XG4gICAgaWYgKCF0aUZpbGUuY3JlYXRlRmlsZSgpKSB7XG4gICAgICAvLyBPaCBjcmFwLCB3ZSBmYWlsZWQgdG8gY3JlYXRlIHRoZSBmaWxlLiB3aHk/XG4gICAgICBpZiAoIXRpRmlsZS5wYXJlbnQuZXhpc3RzKCkpIHtcbiAgICAgICAgLy8gcGFyZW50IGRvZXMgbm90IGV4aXN0IVxuICAgICAgICB0aHJvdyBub1N1Y2hGaWxlKCdvcGVuJywgcGF0aCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBjcmVhdGUgZmlsZSBhdCBwYXRoICR7cGF0aH1gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmxhZ3MpIHtcbiAgICAvLyBmaWxlL2RpciBleGlzdHMuLi5cbiAgICBpZiAoKGZsYWdzLmNoYXJBdCgwKSA9PT0gJ3cnIHx8IGZsYWdzLmNoYXJBdCgwKSA9PT0gJ2EnKSAmJiB0aUZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgLy8gSWYgdXNlciBpcyB0cnlpbmcgdG8gd3JpdGUgb3IgYXBwZW5kIGFuZCBpdCdzIGEgZGlyZWN0b3J5LCBmYWlsXG4gICAgICB0aHJvdyBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5KCdvcGVuJywgcGF0aCk7XG4gICAgfVxuICAgIGlmIChmbGFncy5sZW5ndGggPiAxICYmIGZsYWdzLmNoYXJBdCgxKSA9PT0gJ3gnKSB7XG4gICAgICAvLyBJZiB1c2VyIGhhcyBcImV4Y2x1c2l2ZVwiIGZsYWcgb24sIGZhaWwgaWYgZmlsZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgdGhyb3cgZmlsZUFscmVhZHlFeGlzdHMoJ29wZW4nLCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGlNb2RlID0gRkxBR1NfVE9fVElfTU9ERS5nZXQoZmxhZ3MpO1xuICBpZiAodGlNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBNYWtlIHVzZSBvZiBjb21tb24gZXJyb3IgdHlwZS9jb2RlIGZvciB0aGlzIG9uY2Ugd2UgaGF2ZSBpbnRlcm5hbC9lcnJvcnMuanNcbiAgICBjb25zdCBlcnIgPSBuZXcgVHlwZUVycm9yKGBUaGUgdmFsdWUgXCIke1N0cmluZyhmbGFncyl9XCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiZmxhZ3NcImApO1xuICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX09QVF9WQUxVRSc7XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHJldHVybiBjcmVhdGVGaWxlRGVzY3JpcHRvcihwYXRoLCB0aUZpbGUub3Blbih0aU1vZGUpKTtcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIHJlYWRDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVzUmVhZCAtIG51bWJlciBvZiBieXRlcyByZWFkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfFRpLkJ1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byByZWFkIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGF0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gcG9zaXRpb24gd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tIGluIHRoZSBmaWxlXG4gKiBAcGFyYW0ge3JlYWRDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMucmVhZCA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgfVxuICAvLyBGSVhNRTogQWxsb3cgdXNpbmcgcG9zaXRpb24gYXJndW1lbnQhXG4gIGlmIChwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgIG9uZVRpbWVXYXJuaW5nKCdmcy5yZWFkU3luYy5wb3NpdGlvbicsICdmcy5yZWFkU3luY1xcJ3MgcG9zaXRpb24gYXJndW1lbnQgaXMgdW5zdXBwb3J0ZWQgYnkgVGl0YW5pdW0gYW5kIHdpbGwgYmUgdHJlYXRlZCBhcyBudWxsJyk7XG4gIH1cbiAgdGlGaWxlU3RyZWFtLnJlYWQoYnVmZmVyLnRvVGlCdWZmZXIoKSwgb2Zmc2V0LCBsZW5ndGgsIHJlYWRPYmogPT4ge1xuICAgIGlmICghcmVhZE9iai5zdWNjZXNzKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IocmVhZE9iai5lcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCByZWFkT2JqLmJ5dGVzUHJvY2Vzc2VkLCBidWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfFRpLkJ1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byByZWFkIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGF0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gX3Bvc2l0aW9uIHdoZXJlIHRvIGJlZ2luIHJlYWRpbmcgZnJvbSBpbiB0aGUgZmlsZVxuICogQHJldHVybnMge2ludGVnZXJ9IGJ5dGVzIHJlYWRcbiAqL1xuZnMucmVhZFN5bmMgPSAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIF9wb3NpdGlvbikgPT4ge1xuICBjb25zdCBmaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICB9XG5cbiAgLy8gRklYTUU6IEFsbG93IHVzaW5nIHBvc2l0aW9uIGFyZ3VtZW50IVxuICBpZiAoX3Bvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLnJlYWRTeW5jLnBvc2l0aW9uJywgJ2ZzLnJlYWRTeW5jXFwncyBwb3NpdGlvbiBhcmd1bWVudCBpcyB1bnN1cHBvcnRlZCBieSBUaXRhbml1bSBhbmQgd2lsbCBiZSB0cmVhdGVkIGFzIG51bGwnKTtcbiAgfVxuICByZXR1cm4gZmlsZVN0cmVhbS5yZWFkKGJ1ZmZlci50b1RpQnVmZmVyKCksIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbGVzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmdbXXxCdWZmZXJbXXxmcy5EaXJlbnRbXX0gZmlsZXMgLSBmaWxlIGxpc3RpbmdcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGRpcmVjdG9yeSB0byBsaXN0XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2UgZm9yIGZpbGVuYW1lcywgaWYgYCdidWZmZXInYCwgcmV0dXJucyBgQnVmZmVyYCBvYmplY3RzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndpdGhGaWxlVHlwZXM9ZmFsc2VdIGlmIHRydWUsIHJldHVybnMgYGZzLkRpcmVudGAgb2JqZWN0c1xuICogQHBhcmFtIHtmaWxlc0NhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5yZWFkZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZnMucmVhZGRpclN5bmMocGF0aCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gIH0sIDEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggZGlyZWN0b3J5IHRvIGxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZSBmb3IgZmlsZW5hbWVzLCBpZiBgJ2J1ZmZlcidgLCByZXR1cm5zIGBCdWZmZXJgIG9iamVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2l0aEZpbGVUeXBlcz1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJucyBgZnMuRGlyZW50YCBvYmplY3RzXG4gKiBAcmV0dXJucyB7c3RyaW5nW118QnVmZmVyW118ZnMuRGlyZW50W119XG4gKi9cbmZzLnJlYWRkaXJTeW5jID0gKGZpbGVwYXRoLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShmaWxlcGF0aCk7XG4gIGlmICghZmlsZS5leGlzdHMoKSkge1xuICAgIHRocm93IG5vU3VjaEZpbGUoJ3NjYW5kaXInLCBmaWxlcGF0aCk7XG4gIH1cbiAgaWYgKCFmaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICB0aHJvdyBub3RBRGlyZWN0b3J5KCdzY2FuZGlyJywgZmlsZXBhdGgpO1xuICB9XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04JyxcbiAgICB3aXRoRmlsZVR5cGVzOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgbGlzdGluZyA9IGZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuICBpZiAob3B0aW9ucy53aXRoRmlsZVR5cGVzID09PSB0cnVlKSB7XG4gICAgLy8gVE9ETzogaWYgb3B0aW9ucy53aXRoRmlsZVR5cGVzID09PSB0cnVlLCByZXR1cm4gZnMuRGlyZW50IG9iamVjdHNcbiAgICBvbmVUaW1lV2FybmluZygnZnMucmVhZGRpclxcJ3Mgb3B0aW9ucy53aXRoRmlsZVR5cGVzIGlzIHVuc3VwcG9ydGVkIGJ5IFRpdGFuaXVtIGFuZCBzdHJpbmdzIHdpbGwgYmUgcmV0dXJuZWQnKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgIHJldHVybiBsaXN0aW5nLm1hcChuYW1lID0+IEJ1ZmZlci5mcm9tKG5hbWUpKTtcbiAgfVxuICByZXR1cm4gbGlzdGluZztcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIHJlYWRGaWxlUG9zdE9wZW5DYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gYnVmZmVyXG4gKi9cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmaWxlRGVzY3JpcHRvciBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7cmVhZEZpbGVQb3N0T3BlbkNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mdW5jdGlvbiByZWFkRmlsZVBvc3RPcGVuKGZpbGVEZXNjcmlwdG9yLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBmcy5mc3RhdChmaWxlRGVzY3JpcHRvciwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmaWxlU2l6ZSA9IHN0YXRzLnNpemU7XG5cbiAgICAvLyBDcmVhdGUgYSBUaS5CdWZmZXIgdG8gcmVhZCBpbnRvXG4gICAgY29uc3QgYnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICAgIGxlbmd0aDogZmlsZVNpemVcbiAgICB9KTtcblxuICAgIC8vIFVzZSBUaS5TdHJlYW0ucmVhZEFsbChzb3VyY2VTdHJlYW0sIGJ1ZmZlciwgY2FsbGJhY2spIHdoaWNoIHNwaW5zIG9mZiBhIHNlcGFyYXRlIHRocmVhZCB0byByZWFkIGluIHdoaWxlIGxvb3AhXG4gICAgY29uc3Qgc291cmNlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvcik7XG4gICAgVGkuU3RyZWFtLnJlYWRBbGwoc291cmNlU3RyZWFtLCBidWZmZXIsIHJlYWRBbGxPYmogPT4ge1xuICAgICAgaWYgKCFyZWFkQWxsT2JqLnN1Y2Nlc3MpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKHJlYWRBbGxPYmouZXJyb3IpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgYnVmZmVyKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHJlYWRGaWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gKi9cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVhZCBlbnRpcmUgY29udGVudHMgb2YgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBwYXRoIGZpbGVuYW1lIG9yIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPW51bGxdIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J3InXSBmaWxlIHN5c3RlbSBmbGFnXG4gKiBAcGFyYW0ge3JlYWRGaWxlQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLnJlYWRGaWxlID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge1xuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBmbGFnOiAncidcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgZmxhZzogJ3InXG4gICAgfSk7XG4gIH1cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgY29uc3Qgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgcGF0aCA9PT0gJ251bWJlcic7XG4gIGxldCBmaWxlRGVzY3JpcHRvciA9IHBhdGg7IC8vIG1heSBiZSBvdmVycmlkZW4gbGF0ZXJcbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciBwb3NzaWJsZSBFcnJvclxuICAgKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gYnVmZmVyIFRpLkJ1ZmZlciBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlQnVmZmVyID0gKGVyciwgYnVmZmVyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBmcy5jbG9zZVN5bmMgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG4gICAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgICAgZnMuY2xvc2VTeW5jKGZpbGVEZXNjcmlwdG9yKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0cmltIGJ1ZmZlciBpZiB3ZSBkaWRuJ3QgcmVhZCBmdWxsIHNpemU/XG5cbiAgICBjYWxsYmFjayhudWxsLCBlbmNvZGVCdWZmZXIob3B0aW9ucy5lbmNvZGluZywgYnVmZmVyKSk7XG4gIH07XG4gIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICBmcy5vcGVuKHBhdGgsIG9wdGlvbnMuZmxhZywgKGVyciwgZmQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmZDtcbiAgICAgIHJlYWRGaWxlUG9zdE9wZW4oZmQsIGhhbmRsZUJ1ZmZlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVhZEZpbGVQb3N0T3BlbihwYXRoLCBoYW5kbGVCdWZmZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRlbnRzIG9mIHRoZSBwYXRoLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBwYXRoIHBhdGggdG8gZmlsZVxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPW51bGxdIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZsYWc9J3InXSBmaWxlIHN5c3RlbSBmbGFnXG4gKiBAcmV0dXJucyB7c3RyaW5nfEJ1ZmZlcn0gc3RyaW5nIGlmIGVuY29kaW5nIGlzIHNwZWNpZmllZCwgb3RoZXJ3aXNlIEJ1ZmZlclxuICovXG5mcy5yZWFkRmlsZVN5bmMgPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgZmxhZzogJ3InXG4gIH0pO1xuICBjb25zdCB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJztcbiAgY29uc3QgZmlsZURlc2NyaXB0b3IgPSB3YXNGaWxlRGVzY3JpcHRvciA/IHBhdGggOiBmcy5vcGVuU3luYyhwYXRoLCBvcHRpb25zLmZsYWcpOyAvLyB1c2UgZGVmYXVsdCBtb2RlXG5cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvcik7XG4gIC8vIEp1c3QgdXNlIG91ciBvd24gQVBJIHRoYXQgcmVhZHMgZnVsbCBzdHJlYW0gaW5cbiAgY29uc3QgYnVmZmVyID0gVGkuU3RyZWFtLnJlYWRBbGwodGlGaWxlU3RyZWFtKTtcblxuICAvLyBmcy5jbG9zZVN5bmMgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG4gIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICBmcy5jbG9zZVN5bmMoZmlsZURlc2NyaXB0b3IpO1xuICB9XG5cbiAgLy8gVE9ETzogdHJpbSBidWZmZXIgaWYgd2UgZGlkbid0IHJlYWQgZnVsbCBzaXplP1xuXG4gIHJldHVybiBlbmNvZGVCdWZmZXIob3B0aW9ucy5lbmNvZGluZywgYnVmZmVyKTtcbn07XG5cbi8vIFRPRE86IGZzLnJlYWRsaW5rKHBhdGhbLCBvcHRpb25zXSwgY2FsbGJhY2spXG4vLyBUT0RPOiBmcy5yZWFkbGlua1N5bmMocGF0aFssIG9wdGlvbnNdKVxuXG4vKipcbiAqIEBjYWxsYmFjayByZWFscGF0aENhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gcmVzb2x2ZWRQYXRoIHRoZSByZXNvbHZlZCBwYXRoXG4gKi9cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gZmlsZXBhdGggb3JpZ2luYWwgZmlsZXBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9zbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHVzZWQgZm9yIHJldHVybmVkIG9iamVjdC4gSWYgJ2J1ZmZlclwiLCB3ZSdsbCByZXR1cm4gYSBCdWZmZXIgaW4gcGFsY2Ugb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7cmVhbHBhdGhDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMucmVhbHBhdGggPSAoZmlsZXBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayB8fCBvcHRpb25zKTtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCdcbiAgfSk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgbm8gc3ltbGlua3MsIHdoaWNoIHdlIHJlYWxseSBkb24ndCBoYXZlIGZ1bGwgc3VwcG9ydCBmb3IgaW4gb3VyIFNESyBhbnl3YXlzLlxuICAgIGNvbnN0IHJlc3VsdCA9IHBhdGgubm9ybWFsaXplKGZpbGVwYXRoKTtcbiAgICBmcy5leGlzdHMocmVzdWx0LCByZXN1bHRFeGlzdHMgPT4ge1xuICAgICAgaWYgKHJlc3VsdEV4aXN0cykge1xuICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgQnVmZmVyLmZyb20ocmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoaXMgcGF0aCBkb2Vzbid0IGV4aXN0LCB0cnkgZWFjaCBzZWdtZW50IHVudGlsIHdlIGZpbmQgZmlyc3QgdGhhdCBkb2Vzbid0XG4gICAgICBjb25zdCBzZWdtZW50cyA9IHJlc3VsdC5zcGxpdChwYXRoLnNlcCk7IC8vIEZJWE1FOiBEcm9wIGxhc3Qgc2VnbWVudCBhcyB3ZSBhbHJlYWR5IGtub3cgdGhlIGZ1bGwgcGF0aCBkb2Vzbid0IGV4aXN0P1xuICAgICAgbGV0IHBhcnRpYWxGaWxlUGF0aCA9ICcnO1xuICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgIC8vIGhhbmRsZSB0eXBpY2FsIGNhc2Ugb2YgZW1wdHkgZmlyc3Qgc2VnbWVudCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFuIGFzeW5jIHNldFRpbWVvdXQgdG8gZ2V0IHRvIGZpcnN0IHJlYWwgY2FzZVxuICAgICAgaWYgKHNlZ21lbnRzW2luZGV4XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQodHJ5UGF0aCwgMSk7XG4gICAgICBmdW5jdGlvbiB0cnlQYXRoKCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgcnVuIHBhc3QgZW5kIG9mIHNlZ21lbnRzLCB0aHJvdyBlcnJvciBmb3IgcmVzb2x2ZWQgcGF0aFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhub1N1Y2hGaWxlKHJlc3VsdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ3JhYiBuZXh0IHNlZ21lbnRcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4KytdO1xuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBpZiBpdCdzIGFuIGVtcHR5IHNlZ21lbnQuLi5cbiAgICAgICAgICAvLyB0cnkgYWdhaW4gYXQgbmV4dCBpbmRleFxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHRyeVBhdGgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9ybWFsIGNhc2VcbiAgICAgICAgcGFydGlhbEZpbGVQYXRoICs9IHBhdGguc2VwICsgc2VnbWVudDtcbiAgICAgICAgLy8gY2hlY2sgaWYgcGF0aCB1cCB0byB0aGlzIHBvaW50IGV4aXN0cy4uLlxuICAgICAgICBmcy5leGlzdHMocGFydGlhbEZpbGVQYXRoLCBwYXJ0aWFsRXhpc3RzID0+IHtcbiAgICAgICAgICBpZiAoIXBhcnRpYWxFeGlzdHMpIHtcbiAgICAgICAgICAgIC8vIG5vcGUsIHRocm93IHRoZSBFcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5vU3VjaEZpbGUoJ2xzdGF0JywgcGFydGlhbEZpbGVQYXRoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHRyeSBhZ2FpbiBhdCBuZXh0IGRlcHRoIG9mIGRpciB0cmVlXG4gICAgICAgICAgc2V0VGltZW91dCh0cnlQYXRoLCAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIDEpO1xufTtcbmZzLnJlYWxwYXRoLm5hdGl2ZSA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBmcy5yZWFscGF0aChwYXRoLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGZpbGVwYXRoIG9yaWdpbmFsIGZpbGVwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB1c2VkIGZvciByZXR1cm5lZCBvYmplY3QuIElmICdidWZmZXJcIiwgd2UnbGwgcmV0dXJuIGEgQnVmZmVyIGluIHBhbGNlIG9mIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfEJ1ZmZlcn1cbiAqL1xuZnMucmVhbHBhdGhTeW5jID0gKGZpbGVwYXRoLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnXG4gIH0pO1xuICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIG5vIHN5bWxpbmtzLCB3aGljaCB3ZSByZWFsbHkgZG9uJ3QgaGF2ZSBmdWxsIHN1cHBvcnQgZm9yIGluIG91ciBTREsgYW55d2F5cy5cbiAgY29uc3QgcmVzdWx0ID0gcGF0aC5ub3JtYWxpemUoZmlsZXBhdGgpO1xuICBpZiAoIWZzLmV4aXN0c1N5bmMocmVzdWx0KSkge1xuICAgIC8vIHRoaXMgcGF0aCBkb2Vzbid0IGV4aXN0LCB0cnkgZWFjaCBzZWdtZW50IHVudGlsIHdlIGZpbmQgZmlyc3QgdGhhdCBkb2Vzbid0XG4gICAgY29uc3Qgc2VnbWVudHMgPSByZXN1bHQuc3BsaXQocGF0aC5zZXApO1xuICAgIGxldCBwYXJ0aWFsRmlsZVBhdGggPSAnJztcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxGaWxlUGF0aCArPSBwYXRoLnNlcCArIHNlZ21lbnQ7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGFydGlhbEZpbGVQYXRoKSkge1xuICAgICAgICB0aHJvdyBub1N1Y2hGaWxlKCdsc3RhdCcsIHBhcnRpYWxGaWxlUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZnMucmVhbHBhdGhTeW5jLm5hdGl2ZSA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIGZzLnJlYWxwYXRoU3luYyhwYXRoLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gb2xkUGF0aCBzb3VyY2UgZmlsZXBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG5ld1BhdGggZGVzdGluYXRpb24gZmlsZXBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMucmVuYW1lID0gKG9sZFBhdGgsIG5ld1BhdGgsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5yZW5hbWVTeW5jKG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gb2xkUGF0aCBzb3VyY2UgZmlsZXBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG5ld1BhdGggZGVzdGluYXRpb24gZmlsZXBhdGhcbiAqL1xuZnMucmVuYW1lU3luYyA9IChvbGRQYXRoLCBuZXdQYXRoKSA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKG9sZFBhdGgpO1xuICAvLyBzcmMgZG9lc24ndCBhY3R1YWxseSBleGlzdD9cbiAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICBjb25zdCBlcnIgPSBub1N1Y2hGaWxlKCdyZW5hbWUnLCBvbGRQYXRoKTtcbiAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAtPiAnJHtuZXdQYXRofSdgO1xuICAgIGVyci5kZXN0ID0gbmV3UGF0aDtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY29uc3QgZGVzdEZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShuZXdQYXRoKTtcbiAgaWYgKGRlc3RGaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAvLyBkZXN0IGlzIGEgZGlyZWN0b3J5IHRoYXQgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCBlcnIgPSBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5KCdyZW5hbWUnLCBvbGRQYXRoKTtcbiAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAtPiAnJHtuZXdQYXRofSdgO1xuICAgIGVyci5kZXN0ID0gbmV3UGF0aDtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgbGV0IHRlbXBQYXRoO1xuICBpZiAoZGVzdEZpbGUuaXNGaWxlKCkpIHtcbiAgICAvLyBkZXN0aW5hdGlvbiBmaWxlIGV4aXN0cywgd2Ugc2hvdWxkIG92ZXJ3cml0ZVxuICAgIC8vIE91ciBBUElzIHdpbGwgZmFpbCBpZiB3ZSB0cnksIHNvIGZpcnN0IGxldCdzIG1ha2UgYSBiYWNrdXAgY29weSBhbmQgZGVsZXRlIHRoZSB0aGUgb3JpZ2luYWxcbiAgICB0ZW1wUGF0aCA9IHBhdGguam9pbihmcy5ta2R0ZW1wU3luYyhwYXRoLmpvaW4oVGkuRmlsZXN5c3RlbS50ZW1wRGlyZWN0b3J5LCAncmVuYW1lLScpKSwgcGF0aC5iYXNlbmFtZShuZXdQYXRoKSk7XG4gICAgZGVzdEZpbGUubW92ZSh0ZW1wUGF0aCk7XG4gIH1cbiAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBzdWNjZXNzID0gdGlGaWxlLm1vdmUobmV3UGF0aCk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHRlbXBQYXRoKSB7XG4gICAgICAvLyB3ZSB0ZW1wb3JhcmlseSBjb3BpZWQgdGhlIGV4aXN0aW5nIGRlc3RpbmF0aW9uIHRvIGJhY2sgaXQgdXAuLi5cbiAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgIC8vIG1vdmUgd29ya2VkLCBzbyB3ZSBjYW4gd2lwZSBpdCBhd2F5IHdoZW5ldmVyLi4uXG4gICAgICAgIGZzLnVubGluayh0ZW1wUGF0aCwgX2VyciA9PiB7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3ZlIGl0IGJhY2ssIGJlY2F1c2Ugd2UgZmFpbGVkIVxuICAgICAgICBjb25zdCB0bXBGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUodGVtcFBhdGgpO1xuICAgICAgICB0bXBGaWxlLm1vdmUobmV3UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLnJtZGlyID0gKHBhdGgsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy5ybWRpclN5bmMocGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqL1xuZnMucm1kaXJTeW5jID0gcGF0aCA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuICBpZiAoIXRpRmlsZS5kZWxldGVEaXJlY3RvcnkoZmFsc2UpKSB7XG4gICAgLy8gZG8gbm90IGRlbGV0ZSBjb250ZW50cyFcbiAgICAvLyB3ZSBmYWlsZWQgdG8gZGVsZXRlLCBidXQgd2h5P1xuICAgIC8vIGRvZXMgaXQgZXhpc3Q/XG4gICAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5vU3VjaEZpbGUoJ3JtZGlyJywgcGF0aCk7XG4gICAgfVxuICAgIC8vIGlzIGl0IGEgZmlsZT9cbiAgICBpZiAodGlGaWxlLmlzRmlsZSgpKSB7XG4gICAgICB0aHJvdyBub3RBRGlyZWN0b3J5KCdybWRpcicsIHBhdGgpO1xuICAgIH1cbiAgICAvLyBpcyBpdCBub3QgZW1wdHk/XG4gICAgY29uc3Qgc3ViRmlsZXMgPSB0aUZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuICAgIGlmIChzdWJGaWxlcyAmJiBzdWJGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBkaXJlY3RvcnlOb3RFbXB0eSgncm1kaXInLCBwYXRoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHBhcmFtIHtzdGF0c0NhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5mcy5zdGF0ID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY2FsbGJhY2sobnVsbCwgbmV3IGZzLlN0YXRzKHBhdGgpKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IHBhdGggZmlsZXBhdGggb3IgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW19vcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtfb3B0aW9ucy5iaWdpbnRdIHdoZXRoZXIgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGJpZ2ludFxuICogQHJldHVybnMge2ZzLlN0YXRzfVxuICovXG5mcy5zdGF0U3luYyA9IChwYXRoLCBfb3B0aW9ucykgPT4gbmV3IGZzLlN0YXRzKHBhdGgpO1xuZnMuc3ltbGluayA9ICh0YXJnZXQsIHBhdGgsIHR5cGUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnc3ltbGluaycsIGNhbGxiYWNrKTtcbmZzLnN5bWxpbmtTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdzeW1saW5rU3luYycpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuPTBdIGJ5dGVzIHRvIHRyaW0gdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMudHJ1bmNhdGUgPSAocGF0aCwgbGVuLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgbGVuKTtcbiAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSB7XG4gICAgbGVuID0gMDtcbiAgfVxuICBpZiAobGVuIDw9IDApIHtcbiAgICBmcy53cml0ZUZpbGUocGF0aCwgJycsIGNhbGxiYWNrKTsgLy8gZW1wdHkgdGhlIGZpbGVcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB3ZSBoYXZlIHRvIHJldGFpbiBzb21lIG9mIHRoZSBmaWxlIVxuICAvLyB5dWNrLCBzbyBsZXQncyByZWFkIHdoYXQgd2UgbmVlZCB0byByZXRhaW4sIHRoZW4gb3ZlcndyaXRlIGZpbGUgd2l0aCBpdFxuICBmcy5vcGVuKHBhdGgsIChlcnIsIGZkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuICAgIGZzLnJlYWQoZmQsIGJ1ZmZlciwgMCwgbGVuLCBudWxsLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGZzLmNsb3NlKGZkLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZnMud3JpdGVGaWxlKHBhdGgsIGJ1ZmZlciwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSBieXRlcyB0byB0cmltIHRvXG4gKi9cbmZzLnRydW5jYXRlU3luYyA9IChwYXRoLCBsZW4gPSAwKSA9PiB7XG4gIGlmIChsZW4gPD0gMCkge1xuICAgIC8vIGVtcHR5IHRoZSBmaWxlXG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXRoLCAnJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gd2UgaGF2ZSB0byByZXRhaW4gc29tZSBvZiB0aGUgZmlsZSFcbiAgLy8geXVjaywgc28gbGV0J3MgcmVhZCB3aGF0IHdlIG5lZWQgdG8gcmV0YWluLCB0aGVuIG92ZXJ3cml0ZSBmaWxlIHdpdGggaXRcbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyhwYXRoKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGxlbik7XG4gIGZzLnJlYWRTeW5jKGZkLCBidWZmZXIsIDAsIGxlbiwgbnVsbCk7XG4gIGZzLmNsb3NlU3luYyhmZCk7XG4gIGZzLndyaXRlRmlsZVN5bmMocGF0aCwgYnVmZmVyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnMudW5saW5rID0gKHBhdGgsIGNhbGxiYWNrKSA9PiB7XG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmcy51bmxpbmtTeW5jKHBhdGgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnMudW5saW5rU3luYyA9IHBhdGggPT4ge1xuICBjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcbiAgaWYgKCF0aUZpbGUuZGVsZXRlRmlsZSgpKSB7XG4gICAgLy8gd2UgZmFpbGVkLCBidXQgd2h5P1xuICAgIGlmICghdGlGaWxlLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBub1N1Y2hGaWxlKCd1bmxpbmsnLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHRpRmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5KCd1bmxpbmsnLCBwYXRoKTtcbiAgICB9XG4gIH1cbn07XG5mcy51bndhdGNoRmlsZSA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAndW53YXRjaEZpbGUnKTtcbmZzLnV0aW1lcyA9IChwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAndXRpbWVzJywgY2FsbGJhY2spO1xuZnMudXRpbWVzU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAndXRpbWVzU3luYycpO1xuZnMud2F0Y2ggPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3dhdGNoJyk7XG5mcy53YXRjaEZpbGUgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3dhdGNoRmlsZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gZmlsZSBmaWxlIHBhdGggb3IgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFR5cGVkQXJyYXl8RGF0YVZpZXd9IGRhdGEgZGF0YSB0byB3cml0ZVxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9ucywgZW5jb2RpbmcgaWYgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubW9kZT0wbzY2Nl0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZsYWc9J3cnXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZzLndyaXRlRmlsZSA9IChmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICd3J1xuICB9KTtcblxuICAvLyBUdXJuIGludG8gZmlsZSBkZXNjcmlwdG9yXG4gIGNvbnN0IHdhc0ZpbGVEZXNjcmlwdG9yID0gdHlwZW9mIGZpbGUgPT09ICdudW1iZXInO1xuICBsZXQgZmlsZURlc2NyaXB0b3IgPSBmaWxlOyAvLyBtYXkgYmUgb3ZlcnJpZGVuIGxhdGVyXG4gIGNvbnN0IGZpbmlzaCA9IGVyciA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZzLmNsb3NlIGlmIGl0IHdhcyBub3Qgb3JpZ2luYWxseSBhIGZpbGUgZGVzY3JpcHRvclxuICAgIGZzLmNsb3NlKGZpbGVEZXNjcmlwdG9yLCBjYWxsYmFjayk7XG4gIH07XG4gIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICBmcy5vcGVuKGZpbGUsIG9wdGlvbnMuZmxhZywgb3B0aW9ucy5tb2RlLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWxlRGVzY3JpcHRvciA9IGZkO1xuICAgICAgZnMud3JpdGUoZmlsZURlc2NyaXB0b3IsIGRhdGEsIGZpbmlzaCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZnMud3JpdGUoZmlsZURlc2NyaXB0b3IsIGRhdGEsIGZpbmlzaCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBmaWxlIGZpbGUgcGF0aCBvciBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld30gZGF0YSBkYXRhIHRvIHdyaXRlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zLCBlbmNvZGluZyBpZiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubW9kZT0wbzY2Nl0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZsYWc9J3cnXSBvcHRpb25zXG4gKi9cbmZzLndyaXRlRmlsZVN5bmMgPSAoZmlsZSwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiAwbzY2NixcbiAgICBmbGFnOiAndydcbiAgfSk7XG5cbiAgLy8gVHVybiBpbnRvIGZpbGUgZGVzY3JpcHRvclxuICBjb25zdCB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBmaWxlID09PSAnbnVtYmVyJztcbiAgY29uc3QgZmlsZURlc2NyaXB0b3IgPSB3YXNGaWxlRGVzY3JpcHRvciA/IGZpbGUgOiBmcy5vcGVuU3luYyhmaWxlLCBvcHRpb25zLmZsYWcsIG9wdGlvbnMubW9kZSk7XG5cbiAgLy8gaWYgZGF0YSBpcyBhIHN0cmluZywgbWFrZSBpdCBhIGJ1ZmZlciBmaXJzdFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbSgnJyArIGRhdGEsIG9wdGlvbnMuZW5jb2RpbmcpOyAvLyBmb3JjZSBkYXRhIHRvIGJlIGEgc3RyaW5nLCBoYW5kbGVzIGNhc2Ugd2hlcmUgaXQncyB1bmRlZmluZWQgYW5kIHdyaXRlcyAndW5kZWZpbmVkJyB0byBmaWxlIVxuICB9XG5cbiAgZnMud3JpdGVTeW5jKGZpbGVEZXNjcmlwdG9yLCBkYXRhKTtcblxuICAvLyBjbG9zZSBpZiB1c2VyIGRpZG4ndCBnaXZlIHVzIGZpbGUgZGVzY3JpcHRvclxuICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgZnMuY2xvc2VTeW5jKGZpbGVEZXNjcmlwdG9yKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgd3JpdGVUaUZpbGVTdHJlYW1DYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdyaXR0ZW4gLSBieXRlcyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1RpLkZpbGVzeXN0ZW0uRmlsZVN0cmVhbX0gdGlGaWxlU3RyZWFtIGZpbGUgc3RyZWFtXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB3ZSdyZSB3cml0aW5nXG4gKiBAcGFyYW0ge3dyaXRlVGlGaWxlU3RyZWFtQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVGlGaWxlU3RyZWFtKHRpRmlsZVN0cmVhbSwgYnVmZmVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBUaS5TdHJlYW0ud3JpdGUodGlGaWxlU3RyZWFtLCBidWZmZXIudG9UaUJ1ZmZlcigpLCB3cml0ZU9iaiA9PiB7XG4gICAgaWYgKCF3cml0ZU9iai5zdWNjZXNzKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3Iod3JpdGVPYmouZXJyb3IpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgd3JpdGVPYmouYnl0ZXNQcm9jZXNzZWQpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBidWZmZXIgY29udGVudHMgdG8gd3JpdGU6IEJ1ZmZlciBvciBzdHJpbmdcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldF0gb2Zmc2V0IHdpdGhpbiBCdWZmZXIgdG8gd3JpdGU7IE9SIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuIChpZiBzdHJpbmcpXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyOyBPUiBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEBwYXJhbSB7d3JpdGVDYWxsYmFja3xpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuIChpZiBCdWZmZXIpOyBPUiBhc3luYyBjYWxsYmFjayBpZiBzdHJpbmdcbiAqIEBwYXJhbSB7d3JpdGVDYWxsYmFja30gW2NhbGxiYWNrXSBhc3luYyBjYWxsYmFjayAoaWYgQnVmZmVyKVxuICovXG5mcy53cml0ZSA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcik7XG4gIGlmIChpc0J1ZmZlcikge1xuICAgIHdyaXRlQnVmZmVyKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlU3RyaW5nKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbbGVuZ3RoXSAgZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gcG9zaXRpb25cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mcy53cml0ZVN5bmMgPSAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSA9PiB7XG4gIGNvbnN0IGlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcik7XG4gIGlmIChpc0J1ZmZlcikge1xuICAgIHJldHVybiB3cml0ZUJ1ZmZlclN5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIHJldHVybiB3cml0ZVN0cmluZ1N5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuLy8gVE9ETzogQWRkIEZpbGVIYW5kbGUgY2xhc3MgdG8gbWF0Y2ggTm9kZSdzIHdyYXBwZXIgZm9yIGZpbGUgZGVzY3JpcHRvcnMuIFJlLXB1cnBvc2Ugb3VyIG93biB3cmFwcGVyP1xuLy8gVE9ETzogQWRkIHRoZSBmcy5wcm9taXNlcyBBUEkhXG5cbi8vIFRPRE86IERlZmluZSBmcy5EaXJlbnQgY2xhc3MsIHdoaWNoIGNhbiBzaW1wbHkgd3JhcCBhIFRpLkZpbGVzeXN0ZW0uRmlsZSAoYW5kIGlzIHZlcnkgc2ltaWxhciB0byBmcy5TdGF0cyEpXG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVHJhY2tzIHRoZSBwYWlyaW5nIG9mIHRoZSBudW1iZXIgd2UgdXNlIHRvIHJlcHJlc2VudCB0aGUgZmlsZSBleHRlcm5hbGx5LCB0aGUgZmlsZXBhdGggaXQncyBwb2ludGluZyBhdCwgYW5kIHRoZSBzdHJlYW0gcG9pbnRpbmcgYXQgaXQuXG4gKi9cbmNsYXNzIEZpbGVEZXNjcmlwdG9yIHtcbiAgY29uc3RydWN0b3IobnVtYmVyLCBwYXRoLCBzdHJlYW0pIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gc3JjU3RyZWFtIGlucHV0IHN0cmVhbSB3ZSdyZSByZWFkaW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuSU9TdHJlYW19IGRlc3RTdHJlYW0gb3V0cHV0IHN0cmVhbSB3ZSdyZSB3cml0aW5nIHRvXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHBpcGUoc3JjU3RyZWFtLCBkZXN0U3RyZWFtLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gQW5kcm9pZCBpcyBwcm9iYWJseSBiZXR0ZXIgb2ZmIHdpdGggVGkuU3RyZWFtLndyaXRlU3RyZWFtLCBsZXNzIG92ZXJoZWFkIGJhY2sgYW5kIGZvcnRoIHRoZSBicmlkZ2VcbiAgICAvLyBUaG91Z2ggQW5kcm9pZCBkb2VzIHN1cHBvcnQgdGhlIFRpLlN0cmVhbS5wdW1wL1RpLlN0cmVhbS53cml0ZSBwYXR0ZXJuIHVzaW5nIGJvdGggQVBJcyBhc3luY1xuICAgIHBpcGVWaWFXcml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gcGlwZVZpYVdyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgVGkuU3RyZWFtLndyaXRlU3RyZWFtKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgQ09QWV9GSUxFX0NIVU5LX1NJWkUsIHJlc3VsdCA9PiB7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpKTtcbiAgICB9XG5cbiAgICAvLyBBbmRyb2lkIHdpbGwgb25seSBjYWxsIHRoaXMgYXQgdGhlIGVuZCBvciBlcnJvciwgc28gd2UgY2FuIHNhZmVseSBhc3N1bWUgd2UncmUgZG9uZSBoZXJlLlxuICAgIC8vIGlPUyB3aWxsIGNhbGwgcGVyIGxvb3AgaXRlcmF0aW9uLCBzZWUgaHR0cHM6Ly9qaXJhLWFyY2hpdmUudGl0YW5pdW1zZGsuY29tL1RJTU9CLTI3MzIwXG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7VGkuRmlsZXN5c3RlbS5GaWxlU3RyZWFtfSBmaWxlU3RyZWFtIGZpbGUgc3RyZWFtXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gZmlsZSBkZXNjcmlwdG9yXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVEZXNjcmlwdG9yKHBhdGgsIGZpbGVTdHJlYW0pIHtcbiAgY29uc3QgcG9pbnRlciA9IGZpbGVEZXNjcmlwdG9yQ291bnQrKzsgLy8gaW5jcmVtZW50IGdsb2JhbCBjb3VudGVyXG4gIGNvbnN0IGZkID0gbmV3IEZpbGVEZXNjcmlwdG9yKHBvaW50ZXIsIHBhdGgsIGZpbGVTdHJlYW0pO1xuICBmaWxlRGVzY3JpcHRvcnMuc2V0KHBvaW50ZXIsIGZkKTsgLy8gdXNlIGl0IHRvIHJlZmVyIHRvIHRoaXMgZmlsZSBzdHJlYW0gYXMgdGhlIFwiZGVzY3JpcHRvclwiXG4gIHJldHVybiBwb2ludGVyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7VGkuRmlsZXN5c3RlbS5GaWxlU3RyZWFtfSBtYXRjaGluZyBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCkge1xuICBjb25zdCB3cmFwcGVyID0gZmlsZURlc2NyaXB0b3JzLmdldChmZCk7XG4gIHJldHVybiB3cmFwcGVyLnN0cmVhbTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge3N0cmluZ30gbWF0Y2hpbmcgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIHBhdGhGb3JGaWxlRGVzY3JpcHRvcihmZCkge1xuICBjb25zdCB3cmFwcGVyID0gZmlsZURlc2NyaXB0b3JzLmdldChmZCk7XG4gIHJldHVybiB3cmFwcGVyLnBhdGg7XG59XG5cbi8qKlxuICogVXNlZCB0byBtZXJnZSB0aGUgdXNlci1zdXBwbGllZCBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHRzIGZvciBhIGZ1bmN0aW9uLiBTcGVjaWFsIGNhc2VzIGEgc3RyaW5nIHRvIGJlIGVuY29kaW5nLlxuICogQHBhcmFtIHsqfSBvcHRpb25zIHVzZXItc3VwcGxpZWQgb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRzIGRlZmF1bHRzIHRvIHVzZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG4gIGNvbnN0IG9wdGlvbnNUeXBlID0gdHlwZW9mIG9wdGlvbnM7XG4gIHN3aXRjaCAob3B0aW9uc1R5cGUpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gVXNlIGNvcHkgb2YgZGVmYXVsdHMgYnV0IHdpdGggZW5jb2Rpbmcgc2V0IHRvIHRoZSAnb3B0aW9ucycgdmFsdWUhXG4gICAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cyk7XG4gICAgICBtZXJnZWQuZW5jb2RpbmcgPSBvcHRpb25zO1xuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgZGVmYXVsdDpcbiAgICAgIGFzc2VydEFyZ3VtZW50VHlwZShvcHRpb25zLCAnb3B0aW9ucycsICdvYmplY3QnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIHNob3VsZCBuZXZlciBnZXQgcmVhY2hlZFxuICB9XG59XG5cbi8qKlxuICogRW5mb3JjZXMgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgY2FsbGJhY2sgZnVuY3Rpb24uIFRocm93cyBUeXBlRXJyb3IgaWYgbm90LlxuICogQHBhcmFtIHsqfSBjYiBwb3NzaWJsZSBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICovXG5mdW5jdGlvbiBtYXliZUNhbGxiYWNrKGNiKSB7XG4gIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2I7XG4gIH1cbiAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcihgQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLiBSZWNlaXZlZCAke2NifWApO1xuICBlcnIuY29kZSA9ICdFUlJfSU5WQUxJRF9DQUxMQkFDSyc7XG4gIHRocm93IGVycjtcbn1cblxuLyoqXG4gKiByZXR1cm5zIHJhbmRvbWx5IGdlbmVyYXRlZCBjaGFyYWN0ZXJzIG9mIGdpdmVuIGxlbmd0aCAxLTE2XG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCAxIC0gMTZcbiAqIEBwYXJhbSB7c3RyaW5nfSBbX2VuY29kaW5nPSd1dGY4J10gZW5jb2Rpbmcgb2YgdGhlIHN0cmluZyBnZW5lcmF0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUNoYXJhY3RlcnMobGVuZ3RoLCBfZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgLy8gRklYTUU6IHVzZSB0aGUgZW5jb2Rpbmcgc3BlY2lmaWVkIVxuICByZXR1cm4gKE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpICsgJzAwMDAwMDAwMDAwMDAwMDAwJykuc2xpY2UoMiwgbGVuZ3RoICsgMik7XG59XG5mdW5jdGlvbiBtYWtlRXJyb3IoY29kZSwgbWVzc2FnZSwgZXJybm8sIHN5c2NhbGwsIHBhdGgpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7Y29kZX06ICR7bWVzc2FnZX0sICR7c3lzY2FsbH0gJyR7cGF0aH0nYCk7XG4gIGVycm9yLmVycm5vID0gZXJybm87XG4gIGVycm9yLnN5c2NhbGwgPSBzeXNjYWxsO1xuICBlcnJvci5jb2RlID0gY29kZTtcbiAgZXJyb3IucGF0aCA9IHBhdGg7XG4gIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2Rpbmcgd2hhdCB3ZSdyZSBlbmNvZGluZyB0b1xuICogQHBhcmFtIHtUaS5CdWZmZXJ9IHRpQnVmZmVyIFRpLkJ1ZmZlciBpbnN0YW5jZVxuICogQHJldHVybnMge0J1ZmZlcn0gbm9kZS1jb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBlbmNvZGVCdWZmZXIoZW5jb2RpbmcsIHRpQnVmZmVyKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdidWZmZXInOlxuICAgIGNhc2UgbnVsbDpcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSdyZSBhbHdheXMgcmVhZGluZyBhIGZpbGUgaW50byBhIFRpLkJ1ZmZlclxuICAgICAgLy8gV3JhcHBpbmcgVGkuQnVmZmVyIGlzIHN1cGVyLXNsb3cgYW5kIHNob3VsZCByZWFsbHkgb25seSBiZSBpZiB3ZSdyZSBnb2luZyB0byB3cml0ZSB0byBpdFxuICAgICAgLy8gR28gdGhlIGZhc3RlciBwYXRoIGJ5IGNvbnZlcnRpbmcgdG8gQXJyYXlCdWZmZXIgYW5kIHdyYXBwaW5nIHRoYXRcbiAgICAgIC8vIFRPRE86IEV4cGxpY2l0bHkgcmVsZWFzZSB0aGUgYmxvYiBhZnRlciBjb252ZXJzaW9uP1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRpQnVmZmVyLnRvQmxvYigpLnRvQXJyYXlCdWZmZXIoKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGhlcmUnIHdlcmUgY29udmVydGluZyB0byBhIHN0cmluZyBiYXNlZCBvbiBlbmNvZGluZy4gSW50ZXJuYWxseSBvdXIgZmFzdGVyIEJ1ZmZlciBpbXBsIHN0aWxsIGRlbGVnYXRlcyB0byBUaS5CdWZmZXIgaW4gbW9zdCBjYXNlc1xuICAgICAgLy8gc28gSSBkb24ndCB0aGluayB0aGVyZSdzIG11Y2ggYmVuZWZpdCBmcm9tIGNvbnZlcnRpbmcgdG8gQXJyYXlCdWZmZXIgZmlyc3RcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aUJ1ZmZlcikudG9TdHJpbmcoZW5jb2RpbmcpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge1RpLkZpbGVzeXN0ZW0uRmlsZX1cbiAqL1xuZnVuY3Rpb24gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCkge1xuICAvLyBUaGlzIGlzIGEgaGFjayB0aGF0IGlzIGxpa2VseSB0byB3b3JrIGluIG1vc3QgY2FzZXM/XG4gIC8vIEJhc2ljYWxseSBhc3N1bWVzIEJ1ZmZlciBpcyBob2xkaW5nIGEgdXRmLTggc3RyaW5nIGZpbGVuYW1lL3BhdGhcbiAgLy8gTm9kZSBqdXN0IGNvcGllcyB0aGUgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyIGFzLWlzIG9uIHRoZSBuYXRpdmUgc2lkZSBhbmQgYWRkcyBhIG51bGwgdGVybWluYXRvclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhdGgpKSB7XG4gICAgcGF0aCA9IHBhdGgudG9TdHJpbmcoKTsgLy8gYXNzdW1lcyB1dGYtOCBzdHJpbmdcbiAgfVxuICAvLyBGSVhNRTogSGFuZGxlIFVSTHMhIFdlIGRvbid0IGhhdmUgYW4gVVJMIHNoaW0geWV0LCBzbyBubyB3YXkgdG8gaGFuZGxlIHRob3NlIHlldFxuICBhc3NlcnRBcmd1bWVudFR5cGUocGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIHJldHVybiBUaS5GaWxlc3lzdGVtLmdldEZpbGUocGF0aCk7XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlQnVmZmVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIG9yaWdpbmFsIEJ1ZmZlciBiZWluZyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7d3JpdGVCdWZmZXJDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gd3JpdGVCdWZmZXIoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgcG9zaXRpb24gfHwgbGVuZ3RoIHx8IG9mZnNldCk7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJykge1xuICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICAvLyBvayBub3cgd2hhdD9cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIC8vIE1ha2UgdXNlIG9mIHRoZSBidWZmZXIgc2xpY2UgdGhhdCdzIHNwZWNpZmllZCBieSBvZmZzZXQvbGVuZ3RoXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG4gIHdyaXRlVGlGaWxlU3RyZWFtKHRpRmlsZVN0cmVhbSwgYnVmZmVyLCAoZXJyLCBieXRlc1Byb2Nlc3NlZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzUHJvY2Vzc2VkLCBidWZmZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mdW5jdGlvbiB3cml0ZUJ1ZmZlclN5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAtIG9mZnNldDtcbiAgfVxuICAvLyBvayBub3cgd2hhdD9cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIC8vIE1ha2UgdXNlIG9mIHRoZSBidWZmZXIgc2xpY2UgdGhhdCdzIHNwZWNpZmllZCBieSBvZmZzZXQvbGVuZ3RoXG4gIGlmIChvZmZzZXQgIT09IDAgfHwgbGVuZ3RoICE9PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG4gIHJldHVybiB0aUZpbGVTdHJlYW0ud3JpdGUoYnVmZmVyLnRvVGlCdWZmZXIoKSk7XG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlU3RyaW5nQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIG9yaWdpbmFsIHN0cmluZyBiZWluZyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge3dyaXRlU3RyaW5nQ2FsbGJhY2t9IFtjYWxsYmFja10gYXN5bmMgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gd3JpdGVTdHJpbmcoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgZW5jb2RpbmcgfHwgcG9zaXRpb24pO1xuICAvLyBwb3NpdGlvbiBjb3VsZCBiZTogbnVtYmVyLCBmdW5jdGlvbiAoY2FsbGJhY2spXG4gIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInKSB7XG4gICAgcG9zaXRpb24gPSBudWxsO1xuICB9XG4gIC8vIGVuY29kaW5nIGNvdWxkIGJlOiBmdW5jdGlvbiAoY2FsbGJhY2spIG9yIHN0cmluZ1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuICBzdHJpbmcgKz0gJyc7IC8vIGNvZXJjZSB0byBzdHJpbmdcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZyk7XG4gIC8vIFRPRE86IFN1cHBvcnQgdXNlIG9mIHBvc2l0aW9uIGFyZ3VtZW50LiBJIGFzc3VtZSB3ZSdkIG5lZWQgYSB3YXkgdG8gYWRkIGEgbWV0aG9kIHRvIG1vdmUgdG8gc3RyZWFtIHBvc2l0aW9uIHNvbWVob3dcbiAgd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIChlcnIsIGJ5dGVzUHJvY2Vzc2VkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgYnl0ZXNQcm9jZXNzZWQsIHN0cmluZyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ1N5bmMoZmQsIHN0cmluZywgcG9zaXRpb24sIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmluZyArPSAnJzsgLy8gY29lcmNlIHRvIHN0cmluZ1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShzdHJpbmcsIGVuY29kaW5nKTtcbiAgLy8gVE9ETzogU3VwcG9ydCB1c2Ugb2YgcG9zaXRpb24gYXJndW1lbnQuIEkgYXNzdW1lIHdlJ2QgbmVlZCBhIHdheSB0byBhZGQgYSBtZXRob2QgdG8gbW92ZSB0byBzdHJlYW0gcG9zaXRpb24gc29tZWhvd1xuICByZXR1cm4gdGlGaWxlU3RyZWFtLndyaXRlKGJ1ZmZlci50b1RpQnVmZmVyKCkpO1xufVxuXG5mdW5jdGlvbiBTdHJlYW0oX29wdHMpIHtcbiAgLy8gRklYTUU6IENhbid0IGNhbGwgRXZlbnRFbWl0dGVyIGFzIGEgZnVuY3Rpb24hXG4gIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgLy8gRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0cyk7XG4gIC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzP1xufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLCBFdmVudEVtaXR0ZXIpO1xuLy8gVXNlIHV0aWwuaW5oZXJpdHM/XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkge1xuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG4gIH1cblxuICAvLyBUT0RPOiByZWFkYWJsZVN0YXRlP1xuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICB9XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoX24pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2Qgbm90IGltcGxlbWVudGVkOiBfcmVhZCgpJyk7XG59O1xuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBjb25zdCBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgICB9XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgfVxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAvLyBUT0RPOiBQcm92aWRlIG1vcmUgdGhhbiBhbiBlbXB0eSBjbGFzcyFcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIC8vIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuLy8gQ29weSBXcml0YWJsZSBtZXRob2RzIHRvIER1cGxleCAoYmFzaWNhbGx5IHRoZSBvZGQgZG91YmxlLWluaGVyaXRhbmNlKVxuY29uc3Qgd3JpdGFibGVNZXRob2RzID0gT2JqZWN0LmtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGFibGVNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IG1ldGhvZCA9IHdyaXRhYmxlTWV0aG9kcztcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIHtcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgfVxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgLy8gVE9ETzogUHJvdmlkZSBtb3JlIHRoYW4gYW4gZW1wdHkgY2xhc3MhXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICAgIH1cbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cbiAgLy8gdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtOyAvLyBsZWdhY3kgY29tcGF0XG5TdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG5TdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcblN0cmVhbS5EdXBsZXggPSBEdXBsZXg7XG5cbi8vIExvYWQgYWxsIHRoZSBub2RlIGNvbXBhdGlibGUgY29yZSBtb2R1bGVzXG5yZWdpc3RlcigncGF0aCcsIHBhdGgpO1xucmVnaXN0ZXIoJ29zJywgT1MpO1xucmVnaXN0ZXIoJ3R0eScsIHR0eSk7XG5yZWdpc3RlcigndXRpbCcsIHV0aWwpO1xucmVnaXN0ZXIoJ2Fzc2VydCcsIGFzc2VydCk7XG5yZWdpc3RlcignZXZlbnRzJywgRXZlbnRFbWl0dGVyKTtcbnJlZ2lzdGVyKCdidWZmZXInLCBCdWZmZXJNb2R1bGUpO1xucmVnaXN0ZXIoJ3N0cmluZ19kZWNvZGVyJywgU3RyaW5nRGVjb2RlciQxKTtcbnJlZ2lzdGVyKCdmcycsIGZzKTtcbnJlZ2lzdGVyKCdzdHJlYW0nLCBTdHJlYW0pO1xuXG4vLyBSZWdpc3RlciByZXF1aXJlKCdidWZmZXInKS5CdWZmZXIgYXMgZ2xvYmFsXG5nbG9iYWwuQnVmZmVyID0gQnVmZmVyTW9kdWxlLkJ1ZmZlcjtcblxuLyoqXG4gKiBUaXRhbml1bSBTREtcbiAqIENvcHlyaWdodCBUaURldiwgSW5jLiAwNC8wNy8yMDIyLVByZXNlbnQuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICpcbiAqIERlc2NyaXB0aW9uOlxuICogVGhpcyBzY3JpcHQgbG9hZHMgYWxsIEphdmFTY3JpcHQgZmlsZXMgZW5kaW5nIHdpdGggdGhlIG5hbWUgXCIqLmJvb3RzdHJhcC5qc1wiIGFuZCB0aGVuIGV4ZWN1dGVzIHRoZW0uXG4gKiBUaGUgbWFpbiBpbnRlbnRpb24gb2YgdGhpcyBmZWF0dXJlIGlzIHRvIGFsbG93IEphdmFTY3JpcHQgZmlsZXMgdG8ga2ljay1vZmYgZnVuY3Rpb25hbGl0eSBvclxuICogZGlzcGxheSBVSSB0byB0aGUgZW5kLXVzZXIgYmVmb3JlIHRoZSBcImFwcC5qc1wiIGdldHMgbG9hZGVkLiBUaGlzIGZlYXR1cmUgaXMgdGhlIENvbW1vbkpTXG4gKiBlcXVpdmFsZW50IHRvIFRpdGFuaXVtJ3MgQW5kcm9pZCBtb2R1bGUgb25BcHBDcmVhdGUoKSBvciBpT1MgbW9kdWxlIGxvYWQoKSBmZWF0dXJlcy5cbiAqXG4gKiBVc2UtQ2FzZXM6XG4gKiAtIEF1dG9tYXRpY2FsbHkga2ljay1vZmYgYW5hbHl0aWNzIGZ1bmN0aW9uYWxpdHkgb24gYXBwIHN0YXJ0dXAuXG4gKiAtIEVuc3VyZSBcIkdvb2dsZSBQbGF5IFNlcnZpY2VzXCIgaXMgaW5zdGFsbGVkL3VwZGF0ZWQgb24gYXBwIHN0YXJ0dXAgb24gQW5kcm9pZC5cbiAqL1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGxvYWQgYWxsIGJvb3RzdHJhcHMgZnJvbSBhIFwiYm9vdHN0cmFwLmpzb25cIiBmaWxlIGNyZWF0ZWQgYnkgdGhlIGFwcCBidWlsZCBzeXN0ZW0uXG4gKiBUaGlzIGlzIGFuIG9wdGlvbmFsIGZlYXR1cmUgYW5kIGlzIHRoZSBmYXN0ZXN0IG1ldGhvZCBvZiBhY3F1aXJpbmcgYm9vc3RyYXBzIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBUaGlzIEpTT04gZmlsZSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIHRoaXMgc2NyaXB0LlxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICogUmV0dXJucyBhbiBhcnJheSBvZiByZXF1aXJlKCkgY29tcGF0aWJsZSBzdHJpbmdzIGlmIGJvb3RzdHJhcHMgd2VyZSBzdWNjZXNzZnVsbHkgbG9hZGVkIGZyb20gSlNPTi5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgSlNPTiBmaWxlIHdhcyBmb3VuZCwgYnV0IG5vIGJvb3RzdHJhcHMgd2VyZSBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogUmV0dXJucyBudWxsIGlmIEpTT04gZmlsZSB3YXMgbm90IGZvdW5kLlxuICovXG5mdW5jdGlvbiBmZXRjaFNjcmlwdHNGcm9tSnNvbigpIHtcbiAgY29uc3QgSlNPTl9GSUxFX05BTUUgPSAnYm9vdHN0cmFwLmpzb24nO1xuICB0cnkge1xuICAgIGNvbnN0IGpzb25GaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5LCBgdGkuaW50ZXJuYWwvJHtKU09OX0ZJTEVfTkFNRX1gKTtcbiAgICBpZiAoanNvbkZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gSlNPTi5wYXJzZShqc29uRmlsZS5yZWFkKCkudGV4dCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5zY3JpcHRzKSkge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3Muc2NyaXB0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgVGkuQVBJLmVycm9yKGBGYWlsZWQgdG8gcmVhZCBcIiR7SlNPTl9GSUxFX05BTUV9XCIuIFJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIHRoZSBcIlJlc291cmNlc1wiIGRpcmVjdG9yeSBmb3IgYWxsIFwiKi5ib290c3RyYXAuanNcIiBmaWxlcy5cbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVxdWlyZSgpIGNvbXBhdGlibGUgc3RyaW5ncyBmb3IgZWFjaCBib290c3RyYXAgZm91bmQgaW4gdGhlIHNlYXJjaC5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gYm9vdHN0cmFwIGZpbGVzIHdlcmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKSB7XG4gIGNvbnN0IHJlc291cmNlRGlyZWN0b3J5ID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5KTtcbiAgY29uc3QgcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoID0gcmVzb3VyY2VEaXJlY3RvcnkubmF0aXZlUGF0aC5sZW5ndGg7XG4gIGNvbnN0IGJvb3RzdHJhcFNjcmlwdHMgPSBbXTtcbiAgZnVuY3Rpb24gbG9hZEZyb20oZmlsZSkge1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBpZiAoZmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3RvcnkuIFJlY3Vyc2l2ZWx5IGxvb2sgZm9yIGJvb3RzdHJhcCBmaWxlcyB1bmRlciBpdC5cbiAgICAgICAgY29uc3QgZmlsZU5hbWVBcnJheSA9IGZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuICAgICAgICBpZiAoZmlsZU5hbWVBcnJheSkge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBmaWxlTmFtZUFycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgbG9hZEZyb20oVGkuRmlsZXN5c3RlbS5nZXRGaWxlKGZpbGUubmF0aXZlUGF0aCwgZmlsZU5hbWVBcnJheVtpbmRleF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlsZS5uYW1lLnNlYXJjaCgvLmJvb3RzdHJhcC5qcyQvKSA+PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBib290c3RyYXAgZmlsZS5cbiAgICAgICAgLy8gQ29udmVydCBpdHMgcGF0aCB0byBzb21ldGhpbmcgbG9hZGFibGUgdmlhIHJlcXVpcmUoKSBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheS5cbiAgICAgICAgbGV0IGJvb3RzdHJhcFBhdGggPSBmaWxlLm5hdGl2ZVBhdGg7XG4gICAgICAgIGJvb3RzdHJhcFBhdGggPSBib290c3RyYXBQYXRoLnN1YnN0cihyZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGgsIGJvb3RzdHJhcFBhdGgubGVuZ3RoIC0gcmVzb3VyY2VEaXJlY3RvcnlQYXRoTGVuZ3RoIC0gJy5qcycubGVuZ3RoKTtcbiAgICAgICAgYm9vdHN0cmFwU2NyaXB0cy5wdXNoKGJvb3RzdHJhcFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkRnJvbShyZXNvdXJjZURpcmVjdG9yeSk7XG4gIHJldHVybiBib290c3RyYXBTY3JpcHRzO1xufVxuXG4vKipcbiAqIE5vbi1ibG9ja2luZyBmdW5jdGlvbiB3aGljaCBsb2FkcyBhbmQgZXhlY3V0ZXMgYWxsIGJvb3RzdHJhcCBzY3JpcHRzIGNvbmZpZ3VyZWQgZm9yIHRoZSBhcHAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmaW5pc2hlZCBDYWxsYmFjayB0byBiZSBpbnZva2VkIG9uY2UgYWxsIGJvb3RzdHJhcHMgaGF2ZSBmaW5pc2hlZCBleGVjdXRpbmcuIENhbm5vdCBiZSBudWxsLlxuICovXG5mdW5jdGlvbiBsb2FkQXN5bmMoZmluaXNoZWQpIHtcbiAgLy8gQWNxdWlyZSBhbiBhcnJheSBvZiBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgaW5jbHVkZWQgd2l0aCB0aGUgYXBwLlxuICAvLyAtIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBhdHRlbXB0IHRvIGZldGNoIHNjcmlwdHMgdmlhIGFuIG9wdGlvbmFsIEpTT04gZmlsZSBjcmVhdGVkIGJ5IHRoZSBidWlsZCBzeXN0ZW0uXG4gIC8vIC0gSWYgSlNPTiBmaWxlIG5vdCBmb3VuZCAod2lsbCByZXR1cm4gbnVsbCksIHRoZW4gc2VhcmNoIFwiUmVzb3VyY2VzXCIgZGlyZWN0b3J5IGZvciBib290c3RyYXAgZmlsZXMuXG4gIGxldCBib290c3RyYXBTY3JpcHRzID0gZmV0Y2hTY3JpcHRzRnJvbUpzb24oKTtcbiAgaWYgKCFib290c3RyYXBTY3JpcHRzKSB7XG4gICAgYm9vdHN0cmFwU2NyaXB0cyA9IGZldGNoU2NyaXB0c0Zyb21SZXNvdXJjZXNEaXJlY3RvcnkoKTtcbiAgfVxuXG4gIC8vIERvIG5vdCBjb250aW51ZSBpZiBubyBib290c3RyYXBzIHdlcmUgZm91bmQuXG4gIGlmICghYm9vdHN0cmFwU2NyaXB0cyB8fCBib290c3RyYXBTY3JpcHRzLmxlbmd0aCA8PSAwKSB7XG4gICAgZmluaXNoZWQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTb3J0IHRoZSBib290c3RyYXBzIHNvIHRoYXQgdGhleSdsbCBiZSBsb2FkZWQgaW4gYSBjb25zaXN0ZW50IG9yZGVyIGJldHdlZW4gcGxhdGZvcm1zLlxuICBib290c3RyYXBTY3JpcHRzLnNvcnQoKTtcblxuICAvLyBMb2FkcyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgZm91bmQuXG4gIGZ1bmN0aW9uIGxvYWRCb290c3RyYXBTY3JpcHRzKGZpbmlzaGVkKSB7XG4gICAgbGV0IGJvb3RzdHJhcEluZGV4ID0gMDtcbiAgICBmdW5jdGlvbiBkb0xvYWQoKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGxvYWQgYWxsIGJvb3RzdHJhcCBzY3JpcHRzLlxuICAgICAgd2hpbGUgKGJvb3RzdHJhcEluZGV4IDwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTG9hZCB0aGUgbmV4dCBib290c3RyYXAuXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYm9vdHN0cmFwU2NyaXB0c1tib290c3RyYXBJbmRleF07XG4gICAgICAgIGNvbnN0IGJvb3RzdHJhcCA9IHJlcXVpcmUoZmlsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlY3VyaXR5L2RldGVjdC1ub24tbGl0ZXJhbC1yZXF1aXJlXG5cbiAgICAgICAgLy8gSW52b2tlIHRoZSBib290c3RyYXAncyBleGVjdXRlKCkgbWV0aG9kIGlmIGl0IGhhcyBvbmUuIChUaGlzIGlzIG9wdGlvbmFsLilcbiAgICAgICAgLy8gV2UgbXVzdCB3YWl0IGZvciB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBiZWZvcmUgbG9hZGluZyB0aGUgbmV4dCBzY3JpcHQuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgdXNlZCB0byBkaXNwbGF5IFVJIHRvIHRoZSBlbmQtdXNlci5cbiAgICAgICAgaWYgKGJvb3RzdHJhcC5leGVjdXRlKSB7XG4gICAgICAgICAgYm9vdHN0cmFwLmV4ZWN1dGUob25Cb290c3RyYXBFeGVjdXRpb25GaW5pc2hlZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UncmUgZG9uZSB3aXRoIHRoZSBjdXJyZW50IGJvb3RzdHJhcC4gVGltZSB0byBsb2FkIHRoZSBuZXh0IG9uZS5cbiAgICAgICAgYm9vdHN0cmFwSW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgLy8gSW52b2tlIGdpdmVuIGNhbGxiYWNrIHRvIGluZm9ybSBjYWxsZXIgdGhhdCBhbGwgbG9hZGluZyBpcyBkb25lLlxuICAgICAgZmluaXNoZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Cb290c3RyYXBFeGVjdXRpb25GaW5pc2hlZCgpIHtcbiAgICAgIC8vIExhc3QgYm9vdHN0cmFwIGhhcyBmaW5pc2hlZCBleGVjdXRpb24uIFRpbWUgdG8gbG9hZCB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBOb3RlOiBBZGQgYSB0aW55IGRlbGF5IHNvIHdoYXRldmVyIFVJIHRoZSBsYXN0IGJvb3RzdHJhcCBsb2FkZWQgaGFzIHRpbWUgdG8gY2xvc2UuXG4gICAgICBib290c3RyYXBJbmRleCsrO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBkb0xvYWQoKSwgMSk7XG4gICAgfVxuICAgIGRvTG9hZCgpO1xuICB9XG5cbiAgLy8gV2UndmUgZmluaXNoZWQgbG9hZGluZy9leGVjdXRpbmcgYWxsIGJvb3RzdHJhcCBzY3JpcHRzLlxuICAvLyBJbmZvcm0gY2FsbGVyIGJ5IGludm9raW5nIHRoZSBjYWxsYmFjayBnaXZlbiB0byBsb2FkQXN5bmMoKS5cbiAgbG9hZEJvb3RzdHJhcFNjcmlwdHMoZmluaXNoZWQpO1xufVxuXG4vKipcbiAqIFRpdGFuaXVtIFNES1xuICogQ29weXJpZ2h0IFRpRGV2LCBJbmMuIDA0LzA3LzIwMjItUHJlc2VudC4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKlxuICogVGhpcyBzY3JpcHQgaXMgbG9hZGVkIG9uIGFwcCBzdGFydHVwIG9uIGFsbCBwbGF0Zm9ybXMuIEl0IGlzIHVzZWQgdG8gZG8gdGhlIGZvbGxvd2luZzpcbiAqIC0gUHJvdmlkZSBjb25zaXN0ZW50IHN0YXJ0dXAgYmVoYXZpb3IgYmV0d2VlbiBwbGF0Zm9ybXMsIHN1Y2ggYXMgbG9nZ2luZyBUaXRhbml1bSB2ZXJzaW9uLlxuICogLSBMb2FkIFRpdGFuaXVtJ3MgY29yZSBKYXZhU2NyaXB0IGV4dGVuc2lvbnMgc2hhcmVkIGJ5IGFsbCBwbGF0Zm9ybXMuXG4gKiAtIFByb3ZpZGUgXCIqLmJvb3RzdHJhcC5qc1wiIHNjcmlwdCBzdXBwb3J0LiAoU2ltaWxhciB0byBuYXRpdmUgbW9kdWxlIG9uQXBwQ3JlYXRlKCkvbG9hZCgpIHN1cHBvcnQuKVxuICogLSBMb2FkIHRoZSBhcHAgZGV2ZWxvcGVyJ3MgbWFpbiBcImFwcC5qc1wiIHNjcmlwdCBhZnRlciBkb2luZyBhbGwgb2YgdGhlIGFib3ZlLlxuICovXG5cbi8vIExvZyB0aGUgYXBwIG5hbWUsIGFwcCB2ZXJzaW9uLCBhbmQgVGl0YW5pdW0gdmVyc2lvbiBvbiBzdGFydHVwLlxuVGkuQVBJLmluZm8oYCR7VGkuQXBwLm5hbWV9ICR7VGkuQXBwLnZlcnNpb259IChQb3dlcmVkIGJ5IFRpdGFuaXVtICR7XCIxMi41LjFcIn0uJHtcIjhhNGRhNmFkYmFcIn0pYCk7XG5sb2FkQXN5bmMoZnVuY3Rpb24gKCkge1xuICAvLyBXZSd2ZSBmaW5pc2hlZCBsb2FkaW5nL2V4ZWN1dGluZyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMuXG4gIC8vIFdlIGNhbiBub3cgcHJvY2VlZCB0byBydW4gdGhlIG1haW4gXCJhcHAuanNcIiBzY3JpcHQuXG4gIHJlcXVpcmUoJy4vYXBwJyk7XG5cbiAgLy8gVGhpcyBldmVudCBpcyB0byBiZSBmaXJlZCBhZnRlciBcImFwcC5qc1wiIGV4ZWN1dGlvbi4gUmVhc29uczpcbiAgLy8gLSBBbGxvdyBzeXN0ZW0gdG8gcXVldWUgc3RhcnR1cCByZWxhdGVkIGV2ZW50cyB1bnRpbCBcImFwcC5qc1wiIGhhcyBoYWQgYSBjaGFuY2UgdG8gYWRkIGxpc3RlbmVycy5cbiAgLy8gLSBGb3IgQWxsb3kgYXBwcywgd2Ugbm93IGtub3cgdGhhdCBBbGxveSBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgaXRzIGdsb2JhbHMgd2VyZSBhZGRlZC5cbiAgVGkuQXBwLmZpcmVFdmVudCgnc3RhcnRlZCcpO1xufSk7XG4iXSwidmVyc2lvbiI6M30=
